{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"wom.py <p>An asynchronous wrapper for the Wise Old Man API.</p> <p>The library aims to make it easy to interact with the Wise Old Man API by providing service methods matching all available endpoints and model classes for data consistency.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Stable</li> <li>Development</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>If you're new to using wom.py, check out our getting started guide.</p>"},{"location":"#problems","title":"Problems","text":"<p>If you're experiencing a problem with the library, please open an issue here, after first confirming a similar issue was not already created.</p>"},{"location":"#what-is-wise-old-man","title":"What is Wise Old Man","text":"<p>Wise Old Man is an open source Oldschool Runescape player progress tracker.</p> <p>If you're interested in learning more about the Wise Old Man project, consider checking out any of these links:</p> <ul> <li>Website</li> <li>API documentation</li> <li>Github repository</li> <li>Discord community</li> <li>Support the developers on Patreon</li> </ul> <p>Some of the popular features include:</p> <ul> <li>Experience tracking</li> <li>Boss killcounts</li> <li>Player achievements</li> <li>Group competitions</li> <li>Global leaderboards</li> <li>A discord bot for interacting with the API</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>wom.py is open to contributions. Check out the contributing guide to learn how.</p>"},{"location":"#license","title":"License","text":"<p>wom.py is licensed under the MIT License.</p>"},{"location":"getting-started/client/","title":"Using the client","text":"<p>The <code>Client</code> class is used to interact with the WOM API. You use the client to make requests via its difference service properties.</p> <p>Services available on the client include:</p> <ul> <li><code>CompetitionService</code> via <code>Client.competitions</code></li> <li><code>DeltaService</code> via <code>Client.deltas</code></li> <li><code>EfficiencyService</code> via <code>Client.efficiency</code></li> <li><code>GroupService</code> via <code>Client.groups</code></li> <li><code>NameChangeService</code> via <code>Client.name_changes</code></li> <li><code>PlayerService</code> via <code>Client.players</code></li> <li><code>RecordService</code> via <code>Client.records</code></li> </ul>"},{"location":"getting-started/client/#instantiating-the-client","title":"Instantiating the client","text":"<pre><code>import wom\n\nclient = wom.Client(\n    \"api_abc123\",  # The wom api key to use.\n    user_agent=\"@jonxslays\",\n    api_base_url=\"http://localhost:5000\",\n)\n</code></pre> <p>Api base url and user agent are both optional, but user agent is highly encouraged. The client defaults to using the production wom api url. If you are running a local instance of the wom api you can set the base url to your instance.</p> <p>Info</p> <p>You only need a single instance of the <code>Client</code> to make requests to WOM. If you feel like you need multiple <code>Client</code> instances you should reconsider the architecture of your application, and how you can reuse your existing <code>Client</code> resource. Some niche scenarios could warrant more than one <code>Client</code>, but these use cases aren't common for most users.</p>"},{"location":"getting-started/client/#handling-client-resources","title":"Handling client resources","text":"<p>The wom <code>Client</code> uses an <code>aiohttp.ClientSession</code> under the hood, so it is important that you call <code>Client.start</code> and <code>Client.close</code> appropriately.</p> <pre><code># ...continued from above\n\nawait client.start()\n\n# Make requests here...\n\nawait client.close()\n</code></pre> <p>You will receive errors/warnings if you do not properly start the client before using it, or close it before your program terminates.</p>"},{"location":"getting-started/client/#example-client-usage","title":"Example client usage","text":"<pre><code>import asyncio\n\nimport wom\n\n\nasync def main() -&gt; None:\n    # Instantiate the client\n    client = wom.Client()\n\n    # Start the client\n    await client.start()\n\n    # You can also alter some client properties after instantiation\n    client.set_api_base_url(\"http://localhost:5000\")\n    client.set_api_key(\"my-new-api-key\")\n    client.set_user_agent(\"@jonxslays\")\n\n    # Oops that api key was bogus, lets remove it\n    client.unset_api_key()\n\n    # Make requests with the client\n    result = await client.groups.get_details(139)\n\n    if result.is_ok:\n        # The result is ok, so we can unwrap here\n        details = result.unwrap()\n        print(details.group)\n        print(details.memberships)\n    else:\n        # Lets see what went wrong\n        print(f\"Error: {result.unwrap_err()}\")\n\n    # Close the client\n    await client.close()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Python version 3.8 or greater is required to use wom.py.</p>"},{"location":"getting-started/installation/#stable","title":"Stable","text":"<pre><code>pip install -U wom.py\n</code></pre>"},{"location":"getting-started/installation/#development","title":"Development","text":"<pre><code>pip install -U git+https://github.com/Jonxslays/wom.py\n</code></pre> <p>For more information on using <code>pip</code>, check out the pip documentation.</p>"},{"location":"getting-started/installation/#verify","title":"Verify","text":"<p>You can verify your install succeeded with the <code>wom</code> command:</p> <pre><code>$ wom\n</code></pre> <p>The output should look similar to this:</p> <pre><code>-------------------------------------------------------------------------\nPackage:     wom.py v1.0.0-rc.1 @ [HEAD]\n-------------------------------------------------------------------------\nLocation:    /home/projects/tester/.venv/lib/python3.11/site-packages/wom\n-------------------------------------------------------------------------\nInterpreter: CPython 3.11.8\n-------------------------------------------------------------------------\nCompiler:    GCC 13.2.1 20230801\n-------------------------------------------------------------------------\nOS/Arch:     Linux 6.6.22-1-lts / x86_64\n-------------------------------------------------------------------------\n</code></pre>"},{"location":"getting-started/result/","title":"The result type","text":"<p>Those of you familiar with Rust will feel right at home with the <code>Result</code> type this library implements. All requests that go out over the network via the <code>Client</code> come back to you in the form of a <code>Result</code>. The result can be one of two things: an <code>Ok</code> or an <code>Err</code>.</p> <p>Calling <code>unwrap()</code> on an <code>Err</code> will raise an exception.</p> <p>Calling <code>unwrap_err()</code> on an <code>Ok</code> will raise an exception.</p>"},{"location":"getting-started/result/#correct-usage","title":"Correct usage","text":"<pre><code>client = wom.Client(user_agent=\"@jonxslays\")\n\nawait client.start()\n\nresult = await client.players.update_player(\"jonxslays\")\n\nif result.is_ok:\n    print(result.unwrap())\nelse:\n    print(result.unwrap_err())\n\nawait client.close()\n</code></pre>"},{"location":"getting-started/result/#incorrect-usage","title":"Incorrect usage","text":"<pre><code>client = wom.Client(user_agent=\"@jonxslays\")\n\nawait client.start()\n\nresult = await client.players.update_player(\"eeeeeeeeeeeee\")\n\nprint(result.unwrap()) # &lt;-- Exception raised\n# Raises UnwrapError because username should have been 12 characters or less\n\n# .. Remember to close the client!\n</code></pre>"},{"location":"getting-started/services/","title":"Wom services","text":"<p>Services are important to understand when using <code>wom.py</code>.</p> <p>Each service is related to a particular area of the WOM API, and makes requests to those endpoints.</p>"},{"location":"getting-started/services/#available-services","title":"Available services","text":"<ul> <li><code>CompetitionService</code> for requests related to competitions.</li> <li><code>DeltaService</code> for requests related to deltas.</li> <li><code>EfficiencyService</code> for requests related to efficiency.</li> <li><code>GroupService</code> for requests related to groups.</li> <li><code>NameChangeService</code> for requests related to name changes.</li> <li><code>PlayerService</code> for requests related to players.</li> <li><code>RecordService</code> for requests related to records.</li> </ul>"},{"location":"getting-started/services/#usage","title":"Usage","text":"<p>Each of these services are available to you as properties on the <code>Client</code>.</p> <p>You should not personally be creating instances of these services, but instead use the client to make requests using the services.</p> <pre><code>client = wom.Client()\n\nawait client.start()\n\n# Use the name change service to submit a name change\nresult = await client.name_changes.submit_name_change(\"old name\", \"new name\")\n\n# ... Do something with the result here\n\nawait client.close()\n</code></pre>"},{"location":"migrating/v1/","title":"Migrating to V1","text":"<p>When upgrading from a pre <code>v1</code> version to <code>v1.*.*</code> there are some breaking changes to take into account.</p> <p>If you use any of the below methods you will want to change your model usage to match the After example.</p>"},{"location":"migrating/v1/#enums","title":"Enums","text":"<p>All skills, bosses, activities, and computed metrics were added to the <code>Metric</code> enum for ease of access from a single source.</p> <p>The following enums were converted into frozen sets containing the various <code>Metrics</code> they encompass so that you can still easily check if a metric is a skill, or boss, etc.</p> <ul> <li><code>Skills</code></li> <li><code>Bosses</code></li> <li><code>Activities</code></li> <li><code>ComputedMetrics</code></li> </ul> <p>This is probably the most wide-spread change of the release and may affect you in many places like if statements etc. The fix is very easy though, just convert most if not all of the places you used the old enums to <code>Metric</code>.</p> <p>The <code>from_str</code> and <code>from_str_maybe</code> methods were removed from the <code>Metric</code> enum.</p> <p>Before</p> <pre><code>print(wom.Skills.Attack)\nprint(wom.Bosses.Zulrah)\nprint(wom.Activities.LastManStanding)\nprint(wom.ComputedMetrics.Ehp)\n\nslayer = wom.Skills.Slayer\nassert slayer in wom.Skills\n</code></pre> <p>After</p> <pre><code>print(wom.Metric.Attack)\nprint(wom.Metric.Zulrah)\nprint(wom.Metric.LastManStanding)\nprint(wom.Metric.Ehp)\n\nslayer = wom.Metric.Slayer\nassert slayer in wom.Skills\n</code></pre>"},{"location":"migrating/v1/#players","title":"Players","text":""},{"location":"migrating/v1/#playerdetail","title":"PlayerDetail","text":"<p>The <code>PlayerDetail</code> model now inherits from <code>Player</code> and so the <code>player</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>PlayerService.update_player</code></li> <li><code>PlayerService.get_details</code></li> <li><code>PlayerService.get_details_by_id</code></li> </ul> <p>Before</p> <pre><code>result = await client.players.get_details(\"jonxslays\")\nplayer = result.unwrap()\nprint(player.player.username)\n</code></pre> <p>After</p> <pre><code>result = await client.players.get_details(\"jonxslays\")\nplayer = result.unwrap()\nprint(player.username)\n</code></pre>"},{"location":"migrating/v1/#playerachievementprogress","title":"PlayerAchievementProgress","text":"<p><code>PlayerAchievementProgress</code> now inherits from <code>AchievementProgress</code> and so the <code>achievement</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>PlayerService.get_achievement_progress</code></li> </ul> <p>Before</p> <pre><code>result = await client.players.get_achievement_progress(\"Jonxslays\")\nachievements = result.unwrap()\n\nfor achievement in achievements:\n    print(achievement.achievement.metric)\n</code></pre> <p>After</p> <pre><code>result = await client.players.get_achievement_progress(\"Jonxslays\")\nachievements = result.unwrap()\n\nfor achievement in achievements:\n    print(achievement.metric)\n</code></pre>"},{"location":"migrating/v1/#playercompetitionstanding","title":"PlayerCompetitionStanding","text":"<p><code>PlayerCompetitionStanding</code> now inherits from <code>PlayerParticipation</code> and so the <code>participation</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>PlayerService.get_competition_standings</code></li> </ul> <p>Before</p> <pre><code>result = await client.players.get_competition_standings(\n    \"Jonxslays\", wom.CompetitionStatus.Ongoing\n)\n\nstandings = result.unwrap()\n\nfor standing in standings:\n    print(standing.participation.competition.title)\n</code></pre> <p>After</p> <pre><code>result = await client.players.get_competition_standings(\n    \"Jonxslays\", wom.CompetitionStatus.Ongoing\n)\n\nstandings = result.unwrap()\n\nfor standing in standings:\n    print(standing.competition.title)\n</code></pre>"},{"location":"migrating/v1/#playerarchive","title":"PlayerArchive","text":"<p><code>PlayerArchive</code> now inherits from <code>Archive</code> and so the <code>archive</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>PlayerService.get_archives</code></li> </ul> <p>Before</p> <pre><code>result = await client.players.get_archives(\"Jonxslays\")\narchives = result.unwrap()\n\nfor archive in archives:\n    print(archive.archive.previous_username)\n</code></pre> <p>After</p> <pre><code>result = await client.players.get_archives(\"Jonxslays\")\narchives = result.unwrap()\n\nfor archive in archives:\n    print(archive.previous_username)\n</code></pre>"},{"location":"migrating/v1/#playermembership","title":"PlayerMembership","text":"<p><code>PlayerMembership</code> now inherits from <code>Membership</code> and so the <code>membership</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>PlayerService.get_group_memberships</code></li> </ul> <p>Before</p> <pre><code>result = await client.players.get_group_memberships(\"Jonxslays\")\nmemberships = result.unwrap()\n\nfor membership in memberships:\n    print(membership.membership.role)\n</code></pre> <p>After</p> <pre><code>result = await client.players.get_group_memberships(\"Jonxslays\")\nmemberships = result.unwrap()\n\nfor membership in memberships:\n    print(membership.role)\n</code></pre>"},{"location":"migrating/v1/#groups","title":"Groups","text":""},{"location":"migrating/v1/#groupmembership","title":"GroupMembership","text":"<p><code>GroupMembership</code> now inherits from <code>Membership</code> and so the <code>membership</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>GroupService.change_member_role</code></li> <li><code>GroupService.get_details</code></li> <li><code>GroupService.edit_group</code></li> <li><code>GroupService.create_group</code></li> </ul> <p>Before</p> <pre><code>result = await client.groups.change_member_role(\n    123, \"111-111-111\", \"Jonxslays\", wom.GroupRole.Admiral\n)\n\nmemberships = result.unwrap()\n\nfor membership in memberships:\n    print(membership.membership.role)\n</code></pre> <p>After</p> <pre><code>result = await client.groups.change_member_role(\n    123, \"111-111-111\", \"Jonxslays\", wom.GroupRole.Admiral\n)\n\nmemberships = result.unwrap()\n\nfor membership in memberships:\n    print(membership.role)\n</code></pre>"},{"location":"migrating/v1/#groupdetail","title":"GroupDetail","text":"<p><code>GroupDetail</code> now inherits from <code>Group</code> and so the <code>group</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>GroupService.get_details</code></li> <li><code>GroupService.edit_group</code></li> <li><code>GroupService.create_group</code></li> </ul> <p>Before</p> <pre><code>result = await client.groups.get_details(1234)\ngroup = result.unwrap()\nprint(group.group.homeworld)\n</code></pre> <p>After</p> <pre><code>result = await client.groups.get_details(1234)\ngroup = result.unwrap()\nprint(group.homeworld)\n</code></pre>"},{"location":"migrating/v1/#efficiency","title":"Efficiency","text":""},{"location":"migrating/v1/#get_global_leaderboard","title":"get_global_leaderboard","text":"<p>The <code>get_global_leaderboard</code> method was renamed to <code>get_global_leaderboards</code> to be in more line with the other leaderboard method names.</p> <p>Methods affected</p> <ul> <li><code>EfficiencyService.get_global_leaderboards</code></li> </ul> <p>Before</p> <pre><code>result = await client.efficiency.get_global_leaderboard(\n    player_type=wom.PlayerType.Ironman\n)\n</code></pre> <p>After</p> <pre><code>result = await client.efficiency.get_global_leaderboards(\n    player_type=wom.PlayerType.Ironman\n)\n</code></pre>"},{"location":"migrating/v1/#records","title":"Records","text":""},{"location":"migrating/v1/#get_global_record_leaderboards","title":"get_global_record_leaderboards","text":"<p>The <code>get_global_record_leaderboards</code> method was renamed to <code>get_global_leaderboards</code> to be more in line with the other leaderboard method names.</p> <p>Methods affected</p> <ul> <li><code>RecordService.get_global_record_leaderboards</code></li> </ul> <p>Before</p> <pre><code>await client.records.get_global_record_leaderboards(\n    wom.Metric.Attack,\n    wom.Period.Day,\n    country=wom.Country.Us,\n)\n</code></pre> <p>After</p> <pre><code>await client.records.get_global_leaderboards(\n    wom.Metric.Attack,\n    wom.Period.Day,\n    country=wom.Country.Us,\n)\n</code></pre>"},{"location":"migrating/v1/#recordleaderboardentry","title":"RecordLeaderboardEntry","text":"<p><code>RecordLeaderboardEntry</code> now inherits from <code>Record</code> and so the <code>record</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>RecordService.get_global_leaderboards</code></li> <li><code>GroupService.get_records</code></li> </ul> <p>Before</p> <pre><code>result = await client.records.get_global_leaderboards(\n    wom.Metric.Attack,\n    wom.Period.Day,\n    country=wom.Country.Us,\n)\n\nleaderboard = result.unwrap()\n\nfor record in leaderboard:\n    print(record.record.value)\n</code></pre> <p>After</p> <pre><code>result = await client.records.get_global_leaderboards(\n    wom.Metric.Attack,\n    wom.Period.Day,\n    country=wom.Country.Us,\n)\n\nleaderboard = result.unwrap()\n\nfor record in leaderboard:\n    print(record.value)\n</code></pre>"},{"location":"migrating/v1/#competitions","title":"Competitions","text":""},{"location":"migrating/v1/#competitionparticipationdetail","title":"CompetitionParticipationDetail","text":"<p><code>CompetitionParticipationDetail</code> now inherits from <code>CompetitionParticipation</code> and so the <code>participation</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>CompetitionService.get_details</code></li> </ul> <p>Before</p> <pre><code>result = await client.competitions.get_details(123)\ndetail = result.unwrap()\n\nfor participation in detail.participations:\n    print(participation.participation.team_name)\n</code></pre> <p>After</p> <pre><code>result = await client.competitions.get_details(123)\ndetail = result.unwrap()\n\nfor participation in detail.participations:\n    print(participation.team_name)\n</code></pre>"},{"location":"migrating/v1/#competitiondetail","title":"CompetitionDetail","text":"<p><code>CompetitionDetail</code> now inherits from <code>Competition</code> and so the <code>competition</code> property was removed.</p> <p>Methods affected</p> <ul> <li><code>CompetitionService.get_details</code></li> </ul> <p>Before</p> <pre><code>result = await client.competitions.get_details(123)\ncompetition = result.unwrap()\nprint(competition.competition.metric)\n</code></pre> <p>After</p> <pre><code>result = await client.competitions.get_details(123)\ncompetition = result.unwrap()\nprint(competition.metric)\n</code></pre>"},{"location":"migrating/v1/#competitionwithparticipations","title":"CompetitionWithParticipations","text":"<p><code>CompetitionWithParticipations</code> was renamed to <code>CreatedCompetitionDetail</code> because the <code>participations</code> property was removed and added to <code>Competition</code> and the name was no longer an accurate representation of the object.</p> <p>This means the <code>verification_code</code> on <code>CreatedCompetitionDetail</code> no longer has to be optional.</p> <p>Methods affected</p> <ul> <li><code>CompetitionService.create_competition</code></li> </ul> <p>Before</p> <pre><code>result = await client.competitions.create_competition(\n    \"Slayer week\",\n    wom.Metric.Slayer,\n    starts_at=datetime.now() + timedelta(days=7),\n    ends_at=datetime.now() + timedelta(days=14),\n    teams=[\n        wom.Team(\"The good team\", [\"jonxslays\", \"rro\"]),\n        wom.Team(\"The suspicious team\", [\"psikoi\", \"aluminoti\"]),\n    ],\n)\n\ndetail = result.unwrap()\n\n# We cant make this assertion with the previous model.\n# assert isinstance(detail.verification_code, str)\n\nfor participation in detail.participations:\n    print(participation)\n</code></pre> <p>After</p> <pre><code>result = await client.competitions.create_competition(\n    \"Slayer week\",\n    wom.Metric.Slayer,\n    starts_at=datetime.now() + timedelta(days=7),\n    ends_at=datetime.now() + timedelta(days=14),\n    teams=[\n        wom.Team(\"The good team\", [\"jonxslays\", \"rro\"]),\n        wom.Team(\"The suspicious team\", [\"psikoi\", \"aluminoti\"]),\n    ],\n)\n\ndetail = result.unwrap()\n\nassert isinstance(detail.verification_code, str)\n\nfor participation in detail.competition.participations:\n    print(participation)\n</code></pre>"},{"location":"migrating/v1/#edit_competition","title":"edit_competition","text":"<p>The <code>edit_competition</code> method now returns a <code>Competition</code> instead of a <code>CompetitionWithParticipations</code> (which was removed).</p> <p>Methods affected</p> <ul> <li><code>CompetitionService.edit_competition</code></li> </ul> <p>Before</p> <pre><code>result = await client.competitions.edit_competition(\n    123, \"111-111-111\", title=\"Skill of the month - Ranged\"\n)\n\ncompetition = result.unwrap()\nprint(competition.competition.title)\n</code></pre> <p>After</p> <pre><code>result = await client.competitions.edit_competition(\n    123, \"111-111-111\", title=\"Skill of the month - Ranged\"\n)\n\ncompetition = result.unwrap()\nprint(competition.title)\n</code></pre>"},{"location":"reference/client/","title":"client","text":"<p>This module houses the wom.py <code>Client</code>.</p> <p>Services related to different WOM endpoints are available for use on the client. All functionality is encompassed in these service methods.</p> <p>Example</p> <pre><code>from wom import Client\n\nclient = Client(user_agent=\"@your_discord_handle#1234\")\n\nawait client.start()\n\nresult = await client.players.search_players(\"Jonxslays\", limit=1)\n\nif result.is_ok:\n    print(result.unwrap())\nelse:\n    print(f\"ERROR: {result.unwrap_err()}\")\n\nawait client.close()\n</code></pre>"},{"location":"reference/client/#wom.client.Client","title":"Client","text":"<p>An asynchronous client used for interacting with the Wise Old Man API.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>The optional WOM api key to use with requests.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>user_agent</code> <code>Optional[str]</code> <p>The optional user agent to use with requests. If none is provided a library default will be used. Defaults to <code>None</code>.</p> <code>api_base_url</code> <code>Optional[str]</code> <p>The optional alternate api base url to use for requests. Useful for development against a local version of the WOM api. Defaults to <code>None</code>.</p> <p>Note</p> <p>None of the arguments are required, although user agent is highly encouraged.</p> Example <pre><code>from os import environ\n\nimport wom\n\nclient = wom.Client(\n    environ[\"WOM_API_KEY\"],\n    user_agent=\"@me#1234\",\n    api_base_url=environ[\"LOCAL_WOM_DOMAIN\"],\n)\n\nawait client.start()  # Start the client\n\n# ... Use the client\n\nawait client.close()  # Close the client\n</code></pre> Source code in <code>wom/client.py</code> <pre><code>class Client:\n    \"\"\"An asynchronous client used for interacting with the\n    Wise Old Man API.\n\n    Args:\n        api_key: The optional WOM api key to use with requests.\n\n    Keyword Args:\n        user_agent: The optional user agent to use with requests. If none is\n            provided a library default will be used. Defaults to `None`.\n\n        api_base_url: The optional alternate api base url to use for requests.\n            Useful for development against a local version of the WOM api.\n            Defaults to `None`.\n\n    !!! note\n\n        None of the arguments are required, although user agent is highly\n        encouraged.\n\n    ??? example\n\n        ```py\n        from os import environ\n\n        import wom\n\n        client = wom.Client(\n            environ[\"WOM_API_KEY\"],\n            user_agent=\"@me#1234\",\n            api_base_url=environ[\"LOCAL_WOM_DOMAIN\"],\n        )\n\n        await client.start()  # Start the client\n\n        # ... Use the client\n\n        await client.close()  # Close the client\n        ```\n    \"\"\"\n\n    __slots__ = (\n        \"_competitions\",\n        \"_deltas\",\n        \"_efficiency\",\n        \"_groups\",\n        \"_http\",\n        \"_names\",\n        \"_players\",\n        \"_records\",\n        \"_serializer\",\n    )\n\n    def __init__(\n        self,\n        api_key: t.Optional[str] = None,\n        *,\n        user_agent: t.Optional[str] = None,\n        api_base_url: t.Optional[str] = None,\n    ) -&gt; None:\n        self._serializer = serializer.Serializer()\n        self._http = services.HttpService(api_key, user_agent, api_base_url)\n        self.__init_core_services()\n\n    @property\n    def competitions(self) -&gt; services.CompetitionService:\n        \"\"\"The [`CompetitionService`][wom.CompetitionService] used to\n        make competition related requests.\n        \"\"\"\n        return self._competitions\n\n    @property\n    def deltas(self) -&gt; services.DeltaService:\n        \"\"\"The [`DeltaService`][wom.DeltaService] used to make delta\n        related requests.\n        \"\"\"\n        return self._deltas\n\n    @property\n    def efficiency(self) -&gt; services.EfficiencyService:\n        \"\"\"The [`EfficiencyService`][wom.EfficiencyService] used to make\n        efficiency related requests.\n        \"\"\"\n        return self._efficiency\n\n    @property\n    def groups(self) -&gt; services.GroupService:\n        \"\"\"The [`GroupService`][wom.GroupService] used to make group\n        related requests.\n        \"\"\"\n        return self._groups\n\n    @property\n    def names(self) -&gt; services.NameChangeService:\n        \"\"\"The [`NameChangeService`][wom.NameChangeService] used to make\n        name change related requests.\n        \"\"\"\n        return self._names\n\n    @property\n    def players(self) -&gt; services.PlayerService:\n        \"\"\"The [`PlayerService`][wom.PlayerService] used to\n        make player related requests.\n        \"\"\"\n        return self._players\n\n    @property\n    def records(self) -&gt; services.RecordService:\n        \"\"\"The [`RecordService`][wom.RecordService] used to\n        make record related requests.\n        \"\"\"\n        return self._records\n\n    def __init_service(self, service: t.Type[ServiceT]) -&gt; ServiceT:\n        if not issubclass(service, services.BaseService):\n            raise TypeError(f\"{service.__name__!r} can not be initialized as a service.\")\n\n        return service(self._http, self._serializer)\n\n    def __init_core_services(self) -&gt; None:\n        self._deltas = self.__init_service(services.DeltaService)\n        self._groups = self.__init_service(services.GroupService)\n        self._players = self.__init_service(services.PlayerService)\n        self._records = self.__init_service(services.RecordService)\n        self._names = self.__init_service(services.NameChangeService)\n        self._efficiency = self.__init_service(services.EfficiencyService)\n        self._competitions = self.__init_service(services.CompetitionService)\n\n    def set_api_key(self, api_key: str) -&gt; None:\n        \"\"\"Sets the api key used by the http service.\n\n        Args:\n            api_key: The new api key to use.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            client.set_api_key(\"abc123\")\n            ```\n        \"\"\"\n        self._http.set_api_key(api_key)\n\n    def unset_api_key(self) -&gt; None:\n        \"\"\"Un-sets the current api key so it isn't sent with requests.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(api_key=\"abc123\")\n\n            client.unset_api_key()\n            ```\n        \"\"\"\n        self._http.unset_api_key()\n\n    def set_user_agent(self, user_agent: str) -&gt; None:\n        \"\"\"Sets the user agent used by the http service.\n\n        Args:\n            user_agent: The new user agent to use.\n\n        !!! note\n\n            To remove a previously set user agent, call this method\n            with an empty string as the user agent.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            client.set_user_agent(\"@Hi#0000\")\n            ```\n        \"\"\"\n        self._http.set_user_agent(user_agent)\n\n    def set_api_base_url(self, base_url: str) -&gt; None:\n        \"\"\"Sets the api base url used by the http service.\n\n        Args:\n            base_url: The new base url to use.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            client.set_api_base_url(\"https://api.wiseoldman.net/v2\")\n            ```\n        \"\"\"\n        self._http.set_base_url(base_url)\n\n    async def start(self) -&gt; None:\n        \"\"\"Starts the client session to be used for http requests.\n\n        !!! warning\n\n            If this is not called before you use any of the services,\n            your program will crash with a `RuntimeError`.\n\n        !!! note\n\n            Don't forget to close the client!\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n            ```\n        \"\"\"\n        await self._http.start()\n\n    async def close(self) -&gt; None:\n        \"\"\"Closes the existing client session, if it's still open.\n\n        !!! tip\n\n            Only call this once, at the end of your program or if you are done\n            with the client completely.\n\n            This method will do nothing if the Client was never started.\n\n        !!! warning\n\n            If this is not called before your program terminates, you will\n            receive an error in your console.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.close()\n            ```\n        \"\"\"\n        await self._http.close()\n</code></pre>"},{"location":"reference/client/#wom.client.Client.competitions","title":"competitions  <code>property</code>","text":"<pre><code>competitions: CompetitionService\n</code></pre> <p>The <code>CompetitionService</code> used to make competition related requests.</p>"},{"location":"reference/client/#wom.client.Client.deltas","title":"deltas  <code>property</code>","text":"<pre><code>deltas: DeltaService\n</code></pre> <p>The <code>DeltaService</code> used to make delta related requests.</p>"},{"location":"reference/client/#wom.client.Client.efficiency","title":"efficiency  <code>property</code>","text":"<pre><code>efficiency: EfficiencyService\n</code></pre> <p>The <code>EfficiencyService</code> used to make efficiency related requests.</p>"},{"location":"reference/client/#wom.client.Client.groups","title":"groups  <code>property</code>","text":"<pre><code>groups: GroupService\n</code></pre> <p>The <code>GroupService</code> used to make group related requests.</p>"},{"location":"reference/client/#wom.client.Client.names","title":"names  <code>property</code>","text":"<pre><code>names: NameChangeService\n</code></pre> <p>The <code>NameChangeService</code> used to make name change related requests.</p>"},{"location":"reference/client/#wom.client.Client.players","title":"players  <code>property</code>","text":"<pre><code>players: PlayerService\n</code></pre> <p>The <code>PlayerService</code> used to make player related requests.</p>"},{"location":"reference/client/#wom.client.Client.records","title":"records  <code>property</code>","text":"<pre><code>records: RecordService\n</code></pre> <p>The <code>RecordService</code> used to make record related requests.</p>"},{"location":"reference/client/#wom.client.Client.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Closes the existing client session, if it's still open.</p> <p>Tip</p> <p>Only call this once, at the end of your program or if you are done with the client completely.</p> <p>This method will do nothing if the Client was never started.</p> <p>Warning</p> <p>If this is not called before your program terminates, you will receive an error in your console.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.close()\n</code></pre> Source code in <code>wom/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Closes the existing client session, if it's still open.\n\n    !!! tip\n\n        Only call this once, at the end of your program or if you are done\n        with the client completely.\n\n        This method will do nothing if the Client was never started.\n\n    !!! warning\n\n        If this is not called before your program terminates, you will\n        receive an error in your console.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.close()\n        ```\n    \"\"\"\n    await self._http.close()\n</code></pre>"},{"location":"reference/client/#wom.client.Client.set_api_base_url","title":"set_api_base_url","text":"<pre><code>set_api_base_url(base_url: str) -&gt; None\n</code></pre> <p>Sets the api base url used by the http service.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The new base url to use.</p> required Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nclient.set_api_base_url(\"https://api.wiseoldman.net/v2\")\n</code></pre> Source code in <code>wom/client.py</code> <pre><code>def set_api_base_url(self, base_url: str) -&gt; None:\n    \"\"\"Sets the api base url used by the http service.\n\n    Args:\n        base_url: The new base url to use.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        client.set_api_base_url(\"https://api.wiseoldman.net/v2\")\n        ```\n    \"\"\"\n    self._http.set_base_url(base_url)\n</code></pre>"},{"location":"reference/client/#wom.client.Client.set_api_key","title":"set_api_key","text":"<pre><code>set_api_key(api_key: str) -&gt; None\n</code></pre> <p>Sets the api key used by the http service.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The new api key to use.</p> required Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nclient.set_api_key(\"abc123\")\n</code></pre> Source code in <code>wom/client.py</code> <pre><code>def set_api_key(self, api_key: str) -&gt; None:\n    \"\"\"Sets the api key used by the http service.\n\n    Args:\n        api_key: The new api key to use.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        client.set_api_key(\"abc123\")\n        ```\n    \"\"\"\n    self._http.set_api_key(api_key)\n</code></pre>"},{"location":"reference/client/#wom.client.Client.set_user_agent","title":"set_user_agent","text":"<pre><code>set_user_agent(user_agent: str) -&gt; None\n</code></pre> <p>Sets the user agent used by the http service.</p> <p>Parameters:</p> Name Type Description Default <code>user_agent</code> <code>str</code> <p>The new user agent to use.</p> required <p>Note</p> <p>To remove a previously set user agent, call this method with an empty string as the user agent.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nclient.set_user_agent(\"@Hi#0000\")\n</code></pre> Source code in <code>wom/client.py</code> <pre><code>def set_user_agent(self, user_agent: str) -&gt; None:\n    \"\"\"Sets the user agent used by the http service.\n\n    Args:\n        user_agent: The new user agent to use.\n\n    !!! note\n\n        To remove a previously set user agent, call this method\n        with an empty string as the user agent.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        client.set_user_agent(\"@Hi#0000\")\n        ```\n    \"\"\"\n    self._http.set_user_agent(user_agent)\n</code></pre>"},{"location":"reference/client/#wom.client.Client.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Starts the client session to be used for http requests.</p> <p>Warning</p> <p>If this is not called before you use any of the services, your program will crash with a <code>RuntimeError</code>.</p> <p>Note</p> <p>Don't forget to close the client!</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n</code></pre> Source code in <code>wom/client.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Starts the client session to be used for http requests.\n\n    !!! warning\n\n        If this is not called before you use any of the services,\n        your program will crash with a `RuntimeError`.\n\n    !!! note\n\n        Don't forget to close the client!\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n        ```\n    \"\"\"\n    await self._http.start()\n</code></pre>"},{"location":"reference/client/#wom.client.Client.unset_api_key","title":"unset_api_key","text":"<pre><code>unset_api_key() -&gt; None\n</code></pre> <p>Un-sets the current api key so it isn't sent with requests.</p> Example <pre><code>import wom\n\nclient = wom.Client(api_key=\"abc123\")\n\nclient.unset_api_key()\n</code></pre> Source code in <code>wom/client.py</code> <pre><code>def unset_api_key(self) -&gt; None:\n    \"\"\"Un-sets the current api key so it isn't sent with requests.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(api_key=\"abc123\")\n\n        client.unset_api_key()\n        ```\n    \"\"\"\n    self._http.unset_api_key()\n</code></pre>"},{"location":"reference/enums/","title":"enums","text":"<p>Global enums used throughout the project.</p>"},{"location":"reference/enums/#wom.enums.Activities","title":"Activities  <code>module-attribute</code>","text":"<pre><code>Activities: FrozenSet[Metric] = frozenset(\n    {\n        LeaguePoints,\n        BountyHunterHunter,\n        BountyHunterRogue,\n        ClueScrollsAll,\n        ClueScrollsBeginner,\n        ClueScrollsEasy,\n        ClueScrollsMedium,\n        ClueScrollsHard,\n        ClueScrollsElite,\n        ClueScrollsMaster,\n        ColosseumGlory,\n        LastManStanding,\n        PvpArena,\n        SoulWarsZeal,\n        GuardiansOfTheRift,\n    }\n)\n</code></pre> <p>Set containing activities.</p>"},{"location":"reference/enums/#wom.enums.Bosses","title":"Bosses  <code>module-attribute</code>","text":"<pre><code>Bosses: FrozenSet[Metric] = frozenset(\n    {\n        AbyssalSire,\n        AlchemicalHydra,\n        Artio,\n        BarrowsChests,\n        Bryophyta,\n        Callisto,\n        Calvarion,\n        Cerberus,\n        ChambersOfXeric,\n        ChambersOfXericChallenge,\n        ChaosElemental,\n        ChaosFanatic,\n        CommanderZilyana,\n        CorporealBeast,\n        CrazyArchaeologist,\n        DagannothPrime,\n        DagannothRex,\n        DagannothSupreme,\n        DerangedArchaeologist,\n        DukeSucellus,\n        GeneralGraardor,\n        GiantMole,\n        GrotesqueGuardians,\n        Hespori,\n        KalphiteQueen,\n        KingBlackDragon,\n        Kraken,\n        Kreearra,\n        KrilTsutsaroth,\n        LunarChests,\n        Mimic,\n        Nex,\n        Nightmare,\n        PhosanisNightmare,\n        Obor,\n        PhantomMuspah,\n        Sarachnis,\n        Scorpia,\n        Scurrius,\n        Skotizo,\n        SolHeredit,\n        Spindel,\n        Tempoross,\n        TheGauntlet,\n        TheCorruptedGauntlet,\n        TheLeviathan,\n        TheWhisperer,\n        TheatreOfBlood,\n        TheatreOfBloodHard,\n        ThermonuclearSmokeDevil,\n        TombsOfAmascut,\n        TombsOfAmascutExpert,\n        TzKalZuk,\n        TzTokJad,\n        Vardorvis,\n        Venenatis,\n        Vetion,\n        Vorkath,\n        Wintertodt,\n        Zalcano,\n        Zulrah,\n    }\n)\n</code></pre> <p>Set containing bosses.</p>"},{"location":"reference/enums/#wom.enums.ComputedMetrics","title":"ComputedMetrics  <code>module-attribute</code>","text":"<pre><code>ComputedMetrics: FrozenSet[Metric] = frozenset({Ehp, Ehb})\n</code></pre> <p>Set containing all the types of computed metrics.</p>"},{"location":"reference/enums/#wom.enums.Skills","title":"Skills  <code>module-attribute</code>","text":"<pre><code>Skills: FrozenSet[Metric] = frozenset(\n    {\n        Overall,\n        Attack,\n        Defence,\n        Strength,\n        Hitpoints,\n        Ranged,\n        Prayer,\n        Magic,\n        Cooking,\n        Woodcutting,\n        Fletching,\n        Fishing,\n        Firemaking,\n        Crafting,\n        Smithing,\n        Mining,\n        Herblore,\n        Agility,\n        Thieving,\n        Slayer,\n        Farming,\n        Runecrafting,\n        Hunter,\n        Construction,\n    }\n)\n</code></pre> <p>Set containing skills.</p>"},{"location":"reference/enums/#wom.enums.BaseEnum","title":"BaseEnum","text":"<p>             Bases: <code>Enum</code></p> <p>The base enum all library enums inherit from.</p> Source code in <code>wom/enums.py</code> <pre><code>class BaseEnum(Enum):\n    \"\"\"The base enum all library enums inherit from.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return self.value  # type: ignore[no-any-return]\n\n    def __eq__(self, other: object) -&gt; bool:\n        if isinstance(other, BaseEnum):\n            return self.value == other.value  # type: ignore[no-any-return]\n\n        if isinstance(other, str):\n            return self.value == other  # type: ignore[no-any-return]\n\n        return super().__eq__(other)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.value)\n\n    @classmethod\n    def at_random(cls: t.Type[T]) -&gt; T:\n        \"\"\"Generates a random variant of this enum.\n\n        Returns:\n            The randomly generated enum.\n        \"\"\"\n        return random.choice(tuple(cls))\n</code></pre>"},{"location":"reference/enums/#wom.enums.BaseEnum.at_random","title":"at_random  <code>classmethod</code>","text":"<pre><code>at_random() -&gt; T\n</code></pre> <p>Generates a random variant of this enum.</p> <p>Returns:</p> Type Description <code>T</code> <p>The randomly generated enum.</p> Source code in <code>wom/enums.py</code> <pre><code>@classmethod\ndef at_random(cls: t.Type[T]) -&gt; T:\n    \"\"\"Generates a random variant of this enum.\n\n    Returns:\n        The randomly generated enum.\n    \"\"\"\n    return random.choice(tuple(cls))\n</code></pre>"},{"location":"reference/enums/#wom.enums.Metric","title":"Metric","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Represents all metrics including skills, bosses, activities, and computed metrics.</p> Source code in <code>wom/enums.py</code> <pre><code>class Metric(BaseEnum):\n    \"\"\"Represents all metrics including skills, bosses, activities, and\n    computed metrics.\n    \"\"\"\n\n    # Skills\n    Overall = \"overall\"\n    Attack = \"attack\"\n    Defence = \"defence\"\n    Strength = \"strength\"\n    Hitpoints = \"hitpoints\"\n    Ranged = \"ranged\"\n    Prayer = \"prayer\"\n    Magic = \"magic\"\n    Cooking = \"cooking\"\n    Woodcutting = \"woodcutting\"\n    Fletching = \"fletching\"\n    Fishing = \"fishing\"\n    Firemaking = \"firemaking\"\n    Crafting = \"crafting\"\n    Smithing = \"smithing\"\n    Mining = \"mining\"\n    Herblore = \"herblore\"\n    Agility = \"agility\"\n    Thieving = \"thieving\"\n    Slayer = \"slayer\"\n    Farming = \"farming\"\n    Runecrafting = \"runecrafting\"\n    Hunter = \"hunter\"\n    Construction = \"construction\"\n\n    # Activities\n    LeaguePoints = \"league_points\"\n    BountyHunterHunter = \"bounty_hunter_hunter\"\n    BountyHunterRogue = \"bounty_hunter_rogue\"\n    ClueScrollsAll = \"clue_scrolls_all\"\n    ClueScrollsBeginner = \"clue_scrolls_beginner\"\n    ClueScrollsEasy = \"clue_scrolls_easy\"\n    ClueScrollsMedium = \"clue_scrolls_medium\"\n    ClueScrollsHard = \"clue_scrolls_hard\"\n    ClueScrollsElite = \"clue_scrolls_elite\"\n    ClueScrollsMaster = \"clue_scrolls_master\"\n    ColosseumGlory = \"colosseum_glory\"\n    LastManStanding = \"last_man_standing\"\n    PvpArena = \"pvp_arena\"\n    SoulWarsZeal = \"soul_wars_zeal\"\n    GuardiansOfTheRift = \"guardians_of_the_rift\"\n\n    # Bosses\n    AbyssalSire = \"abyssal_sire\"\n    AlchemicalHydra = \"alchemical_hydra\"\n    Artio = \"artio\"\n    BarrowsChests = \"barrows_chests\"\n    Bryophyta = \"bryophyta\"\n    Callisto = \"callisto\"\n    Calvarion = \"calvarion\"\n    Cerberus = \"cerberus\"\n    ChambersOfXeric = \"chambers_of_xeric\"\n    ChambersOfXericChallenge = \"chambers_of_xeric_challenge_mode\"\n    ChaosElemental = \"chaos_elemental\"\n    ChaosFanatic = \"chaos_fanatic\"\n    CommanderZilyana = \"commander_zilyana\"\n    CorporealBeast = \"corporeal_beast\"\n    CrazyArchaeologist = \"crazy_archaeologist\"\n    DagannothPrime = \"dagannoth_prime\"\n    DagannothRex = \"dagannoth_rex\"\n    DagannothSupreme = \"dagannoth_supreme\"\n    DerangedArchaeologist = \"deranged_archaeologist\"\n    DukeSucellus = \"duke_sucellus\"\n    GeneralGraardor = \"general_graardor\"\n    GiantMole = \"giant_mole\"\n    GrotesqueGuardians = \"grotesque_guardians\"\n    Hespori = \"hespori\"\n    KalphiteQueen = \"kalphite_queen\"\n    KingBlackDragon = \"king_black_dragon\"\n    Kraken = \"kraken\"\n    Kreearra = \"kreearra\"\n    KrilTsutsaroth = \"kril_tsutsaroth\"\n    LunarChests = \"lunar_chests\"\n    Mimic = \"mimic\"\n    Nex = \"nex\"\n    Nightmare = \"nightmare\"\n    PhosanisNightmare = \"phosanis_nightmare\"\n    Obor = \"obor\"\n    PhantomMuspah = \"phantom_muspah\"\n    Sarachnis = \"sarachnis\"\n    Scorpia = \"scorpia\"\n    Scurrius = \"scurrius\"\n    Skotizo = \"skotizo\"\n    SolHeredit = \"sol_heredit\"\n    Spindel = \"spindel\"\n    Tempoross = \"tempoross\"\n    TheGauntlet = \"the_gauntlet\"\n    TheCorruptedGauntlet = \"the_corrupted_gauntlet\"\n    TheLeviathan = \"the_leviathan\"\n    TheWhisperer = \"the_whisperer\"\n    TheatreOfBlood = \"theatre_of_blood\"\n    TheatreOfBloodHard = \"theatre_of_blood_hard_mode\"\n    ThermonuclearSmokeDevil = \"thermonuclear_smoke_devil\"\n    TombsOfAmascut = \"tombs_of_amascut\"\n    TombsOfAmascutExpert = \"tombs_of_amascut_expert\"\n    TzKalZuk = \"tzkal_zuk\"\n    TzTokJad = \"tztok_jad\"\n    Vardorvis = \"vardorvis\"\n    Venenatis = \"venenatis\"\n    Vetion = \"vetion\"\n    Vorkath = \"vorkath\"\n    Wintertodt = \"wintertodt\"\n    Zalcano = \"zalcano\"\n    Zulrah = \"zulrah\"\n\n    # Computed Metrics\n    Ehp = \"ehp\"\n    Ehb = \"ehb\"\n</code></pre>"},{"location":"reference/enums/#wom.enums.Period","title":"Period","text":"<p>             Bases: <code>BaseEnum</code></p> <p>A period of time used by the API.</p> Source code in <code>wom/enums.py</code> <pre><code>class Period(BaseEnum):\n    \"\"\"A period of time used by the API.\"\"\"\n\n    FiveMins = \"five_min\"\n    Day = \"day\"\n    Week = \"week\"\n    Month = \"month\"\n    Year = \"year\"\n</code></pre>"},{"location":"reference/errors/","title":"errors","text":"<p>This module contains various exceptions used by the project.</p>"},{"location":"reference/errors/#wom.errors.UnwrapError","title":"UnwrapError","text":"<p>             Bases: <code>WomError</code></p> <p>Raised when calling <code>unwrap()</code> or <code>unwrap_err()</code> incorrectly.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The error message.</p> required Source code in <code>wom/errors.py</code> <pre><code>class UnwrapError(WomError):\n    \"\"\"Raised when calling [`unwrap()`][wom.Result.unwrap] or\n    [`unwrap_err()`][wom.Result.unwrap_err] incorrectly.\n\n    Args:\n        message: The error message.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, message: str) -&gt; None:\n        super().__init__(f\"Unwrap failed: {message}\")\n</code></pre>"},{"location":"reference/errors/#wom.errors.WomError","title":"WomError","text":"<p>             Bases: <code>Exception</code></p> <p>The base error all wom errors inherit from.</p> Source code in <code>wom/errors.py</code> <pre><code>class WomError(Exception):\n    \"\"\"The base error all wom errors inherit from.\"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"reference/models/","title":"models","text":"<p>This module contains the models used to represent data returned by the WOM API.</p> <p>Enums related to specific services are also housed in the module.</p> <p>Tip</p> <p>Most of the models here you won't create, but a few you will. Those will be documented as such.</p>"},{"location":"reference/models/#wom.models.Achievement","title":"Achievement","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents an achievement made by a player.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class Achievement(BaseModel):\n    \"\"\"Represents an achievement made by a player.\"\"\"\n\n    player_id: int\n    \"\"\"The unique ID of the player.\"\"\"\n\n    name: str\n    \"\"\"The name of the achievement.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The [`Metric`][wom.Metric] for this achievement.\"\"\"\n\n    measure: AchievementMeasure\n    \"\"\"The [`AchievementMeasure`][wom.AchievementMeasure] that\n    the player obtained.\n    \"\"\"\n\n    threshold: int\n    \"\"\"The threshold for this achievement.\"\"\"\n\n    created_at: datetime\n    \"\"\"The date the achievement was achieved.\"\"\"\n\n    accuracy: t.Optional[int]\n    \"\"\"The margin of error for the achievements creation date.\n\n    !!! note\n\n        Can be `None` if the achievement hasn't been recalculated since\n        the addition of this field (~ Feb 2023). It can also be -1 for\n        achievements with unknown dates.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Achievement.accuracy","title":"accuracy  <code>instance-attribute</code>","text":"<pre><code>accuracy: Optional[int]\n</code></pre> <p>The margin of error for the achievements creation date.</p> <p>Note</p> <p>Can be <code>None</code> if the achievement hasn't been recalculated since the addition of this field (~ Feb 2023). It can also be -1 for achievements with unknown dates.</p>"},{"location":"reference/models/#wom.models.Achievement.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The date the achievement was achieved.</p>"},{"location":"reference/models/#wom.models.Achievement.measure","title":"measure  <code>instance-attribute</code>","text":"<pre><code>measure: AchievementMeasure\n</code></pre> <p>The <code>AchievementMeasure</code> that the player obtained.</p>"},{"location":"reference/models/#wom.models.Achievement.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The <code>Metric</code> for this achievement.</p>"},{"location":"reference/models/#wom.models.Achievement.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the achievement.</p>"},{"location":"reference/models/#wom.models.Achievement.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The unique ID of the player.</p>"},{"location":"reference/models/#wom.models.Achievement.threshold","title":"threshold  <code>instance-attribute</code>","text":"<pre><code>threshold: int\n</code></pre> <p>The threshold for this achievement.</p>"},{"location":"reference/models/#wom.models.AchievementMeasure","title":"AchievementMeasure","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Measures used to categorize achievements.</p> Source code in <code>wom/models/players/enums.py</code> <pre><code>class AchievementMeasure(BaseEnum):\n    \"\"\"Measures used to categorize achievements.\"\"\"\n\n    Levels = \"levels\"\n    Experience = \"experience\"\n    Kills = \"kills\"\n    Score = \"score\"\n    Value = \"value\"\n</code></pre>"},{"location":"reference/models/#wom.models.AchievementProgress","title":"AchievementProgress","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents progress made toward an achievement.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class AchievementProgress(BaseModel):\n    \"\"\"Represents progress made toward an achievement.\"\"\"\n\n    player_id: int\n    \"\"\"The unique ID of the player.\"\"\"\n\n    name: str\n    \"\"\"The name of the achievement.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The [`Metric`][wom.Metric] for this achievement.\"\"\"\n\n    measure: AchievementMeasure\n    \"\"\"The [`AchievementMeasure`][wom.AchievementMeasure] that\n    the player obtained.\n    \"\"\"\n\n    threshold: int\n    \"\"\"The threshold for this achievement.\"\"\"\n\n    created_at: t.Optional[datetime]\n    \"\"\"The date the achievement was achieved, or `None` if it has not\n    been achieved.\n    \"\"\"\n\n    accuracy: t.Optional[int]\n    \"\"\"The margin of error for the achievements creation date.\n\n    !!! note\n\n        Can be `None` if the achievement hasn't been recalculated since\n        the addition of this field (~ Feb 2023). It can also be -1 for\n        achievements with unknown dates.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.AchievementProgress.accuracy","title":"accuracy  <code>instance-attribute</code>","text":"<pre><code>accuracy: Optional[int]\n</code></pre> <p>The margin of error for the achievements creation date.</p> <p>Note</p> <p>Can be <code>None</code> if the achievement hasn't been recalculated since the addition of this field (~ Feb 2023). It can also be -1 for achievements with unknown dates.</p>"},{"location":"reference/models/#wom.models.AchievementProgress.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: Optional[datetime]\n</code></pre> <p>The date the achievement was achieved, or <code>None</code> if it has not been achieved.</p>"},{"location":"reference/models/#wom.models.AchievementProgress.measure","title":"measure  <code>instance-attribute</code>","text":"<pre><code>measure: AchievementMeasure\n</code></pre> <p>The <code>AchievementMeasure</code> that the player obtained.</p>"},{"location":"reference/models/#wom.models.AchievementProgress.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The <code>Metric</code> for this achievement.</p>"},{"location":"reference/models/#wom.models.AchievementProgress.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the achievement.</p>"},{"location":"reference/models/#wom.models.AchievementProgress.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The unique ID of the player.</p>"},{"location":"reference/models/#wom.models.AchievementProgress.threshold","title":"threshold  <code>instance-attribute</code>","text":"<pre><code>threshold: int\n</code></pre> <p>The threshold for this achievement.</p>"},{"location":"reference/models/#wom.models.Activity","title":"Activity","text":"<p>             Bases: <code>BaseModel</code></p> <p>Details regarding a particular activity.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class Activity(BaseModel):\n    \"\"\"Details regarding a particular activity.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The activity being measured.\"\"\"\n\n    rank: int\n    \"\"\"The players rank in the activity.\"\"\"\n\n    score: int\n    \"\"\"The players score in the activity.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Activity.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The activity being measured.</p>"},{"location":"reference/models/#wom.models.Activity.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The players rank in the activity.</p>"},{"location":"reference/models/#wom.models.Activity.score","title":"score  <code>instance-attribute</code>","text":"<pre><code>score: int\n</code></pre> <p>The players score in the activity.</p>"},{"location":"reference/models/#wom.models.ActivityGains","title":"ActivityGains","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents activity gains made by a player.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class ActivityGains(BaseModel):\n    \"\"\"Represents activity gains made by a player.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The activity being measured.\"\"\"\n\n    rank: Gains\n    \"\"\"The rank [`Gains`][wom.Gains].\"\"\"\n\n    score: Gains\n    \"\"\"The score [`Gains`][wom.Gains].\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.ActivityGains.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The activity being measured.</p>"},{"location":"reference/models/#wom.models.ActivityGains.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: Gains\n</code></pre> <p>The rank <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.ActivityGains.score","title":"score  <code>instance-attribute</code>","text":"<pre><code>score: Gains\n</code></pre> <p>The score <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.ActivityLeader","title":"ActivityLeader","text":"<p>             Bases: <code>MetricLeader</code></p> <p>Represents a leader in a particular activity.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class ActivityLeader(MetricLeader):\n    \"\"\"Represents a leader in a particular activity.\"\"\"\n\n    score: int\n    \"\"\"The players score in the activity.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.ActivityLeader.score","title":"score  <code>instance-attribute</code>","text":"<pre><code>score: int\n</code></pre> <p>The players score in the activity.</p>"},{"location":"reference/models/#wom.models.Archive","title":"Archive","text":"<p>             Bases: <code>BaseModel</code></p> <p>Information detailing a player that has been archived.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class Archive(BaseModel):\n    \"\"\"Information detailing a player that has been archived.\"\"\"\n\n    player_id: int\n    \"\"\"The ID of the parent player that was archived.\"\"\"\n\n    previous_username: str\n    \"\"\"The players previous username before the archive.\"\"\"\n\n    archive_username: str\n    \"\"\"The players placeholder username after the archive.\"\"\"\n\n    restored_username: t.Optional[str]\n    \"\"\"The players new username after restoration from archive. Can be\n    `None` if the player has not been restored.\"\"\"\n\n    created_at: datetime\n    \"\"\"The date the archive was created.\"\"\"\n\n    restored_at: t.Optional[datetime]\n    \"\"\"The date the player was restored, if they have been.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Archive.archive_username","title":"archive_username  <code>instance-attribute</code>","text":"<pre><code>archive_username: str\n</code></pre> <p>The players placeholder username after the archive.</p>"},{"location":"reference/models/#wom.models.Archive.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The date the archive was created.</p>"},{"location":"reference/models/#wom.models.Archive.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The ID of the parent player that was archived.</p>"},{"location":"reference/models/#wom.models.Archive.previous_username","title":"previous_username  <code>instance-attribute</code>","text":"<pre><code>previous_username: str\n</code></pre> <p>The players previous username before the archive.</p>"},{"location":"reference/models/#wom.models.Archive.restored_at","title":"restored_at  <code>instance-attribute</code>","text":"<pre><code>restored_at: Optional[datetime]\n</code></pre> <p>The date the player was restored, if they have been.</p>"},{"location":"reference/models/#wom.models.Archive.restored_username","title":"restored_username  <code>instance-attribute</code>","text":"<pre><code>restored_username: Optional[str]\n</code></pre> <p>The players new username after restoration from archive. Can be <code>None</code> if the player has not been restored.</p>"},{"location":"reference/models/#wom.models.BaseModel","title":"BaseModel","text":"<p>             Bases: <code>Struct</code></p> <p>The base model all library models inherit from.</p> Source code in <code>wom/models/base.py</code> <pre><code>class BaseModel(msgspec.Struct, rename=\"camel\"):\n    \"\"\"The base model all library models inherit from.\"\"\"\n\n    def to_dict(self) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Converts this class into a dictionary.\n\n        Returns:\n            The requested dictionary.\n        \"\"\"\n        return msgspec.structs.asdict(self)\n</code></pre>"},{"location":"reference/models/#wom.models.BaseModel.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; t.Dict[str, t.Any]\n</code></pre> <p>Converts this class into a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The requested dictionary.</p> Source code in <code>wom/models/base.py</code> <pre><code>def to_dict(self) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Converts this class into a dictionary.\n\n    Returns:\n        The requested dictionary.\n    \"\"\"\n    return msgspec.structs.asdict(self)\n</code></pre>"},{"location":"reference/models/#wom.models.Boss","title":"Boss","text":"<p>             Bases: <code>BaseModel</code></p> <p>Details regarding a particular boss.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class Boss(BaseModel):\n    \"\"\"Details regarding a particular boss.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The boss being measured.\"\"\"\n\n    rank: int\n    \"\"\"The players rank in killing the boss.\"\"\"\n\n    kills: int\n    \"\"\"The number of kills the player has.\"\"\"\n\n    ehb: float\n    \"\"\"The players efficient hours bossed for the boss.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Boss.ehb","title":"ehb  <code>instance-attribute</code>","text":"<pre><code>ehb: float\n</code></pre> <p>The players efficient hours bossed for the boss.</p>"},{"location":"reference/models/#wom.models.Boss.kills","title":"kills  <code>instance-attribute</code>","text":"<pre><code>kills: int\n</code></pre> <p>The number of kills the player has.</p>"},{"location":"reference/models/#wom.models.Boss.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The boss being measured.</p>"},{"location":"reference/models/#wom.models.Boss.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The players rank in killing the boss.</p>"},{"location":"reference/models/#wom.models.BossGains","title":"BossGains","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents boss gains made by a player.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class BossGains(BaseModel):\n    \"\"\"Represents boss gains made by a player.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The boss being measured.\"\"\"\n\n    ehb: Gains\n    \"\"\"The efficient hours bossed [`Gains`][wom.Gains].\"\"\"\n\n    rank: Gains\n    \"\"\"The rank [`Gains`][wom.Gains].\"\"\"\n\n    kills: Gains\n    \"\"\"The boss kill [`Gains`][wom.Gains].\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.BossGains.ehb","title":"ehb  <code>instance-attribute</code>","text":"<pre><code>ehb: Gains\n</code></pre> <p>The efficient hours bossed <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.BossGains.kills","title":"kills  <code>instance-attribute</code>","text":"<pre><code>kills: Gains\n</code></pre> <p>The boss kill <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.BossGains.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The boss being measured.</p>"},{"location":"reference/models/#wom.models.BossGains.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: Gains\n</code></pre> <p>The rank <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.BossLeader","title":"BossLeader","text":"<p>             Bases: <code>MetricLeader</code></p> <p>Represents a leader in a particular boss.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class BossLeader(MetricLeader):\n    \"\"\"Represents a leader in a particular boss.\"\"\"\n\n    kills: int\n    \"\"\"The number of kills the player has.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.BossLeader.kills","title":"kills  <code>instance-attribute</code>","text":"<pre><code>kills: int\n</code></pre> <p>The number of kills the player has.</p>"},{"location":"reference/models/#wom.models.Competition","title":"Competition","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a competition.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class Competition(BaseModel):\n    \"\"\"Represents a competition.\"\"\"\n\n    id: int\n    \"\"\"The unique ID of the competition.\"\"\"\n\n    title: str\n    \"\"\"The title of the competition.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The metric being measured.\"\"\"\n\n    type: CompetitionType\n    \"\"\"The [CompetitionType][wom.CompetitionType].\"\"\"\n\n    starts_at: datetime\n    \"\"\"The date the competition started at.\"\"\"\n\n    ends_at: datetime\n    \"\"\"The date the competition ended at.\"\"\"\n\n    group_id: t.Optional[int]\n    \"\"\"The optional group id associated with the competition.\"\"\"\n\n    score: int\n    \"\"\"The competition's score.\"\"\"\n\n    created_at: datetime\n    \"\"\"The date the competition was created.\"\"\"\n\n    updated_at: datetime\n    \"\"\"The date the competition was updated.\"\"\"\n\n    participant_count: int\n    \"\"\"The number of players participating.\"\"\"\n\n    group: t.Optional[Group] = None\n    \"\"\"The [`Group`][wom.Group] associated with the competition, if\n    there is one.\n    \"\"\"\n\n    participations: t.List[CompetitionParticipation] = []\n    \"\"\"A list containing the [`CompetitionParticipations`]\n    [wom.CompetitionParticipation].\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Competition.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The date the competition was created.</p>"},{"location":"reference/models/#wom.models.Competition.ends_at","title":"ends_at  <code>instance-attribute</code>","text":"<pre><code>ends_at: datetime\n</code></pre> <p>The date the competition ended at.</p>"},{"location":"reference/models/#wom.models.Competition.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: Optional[Group] = None\n</code></pre> <p>The <code>Group</code> associated with the competition, if there is one.</p>"},{"location":"reference/models/#wom.models.Competition.group_id","title":"group_id  <code>instance-attribute</code>","text":"<pre><code>group_id: Optional[int]\n</code></pre> <p>The optional group id associated with the competition.</p>"},{"location":"reference/models/#wom.models.Competition.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique ID of the competition.</p>"},{"location":"reference/models/#wom.models.Competition.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The metric being measured.</p>"},{"location":"reference/models/#wom.models.Competition.participant_count","title":"participant_count  <code>instance-attribute</code>","text":"<pre><code>participant_count: int\n</code></pre> <p>The number of players participating.</p>"},{"location":"reference/models/#wom.models.Competition.participations","title":"participations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>participations: List[CompetitionParticipation] = []\n</code></pre> <p>A list containing the <code>CompetitionParticipations</code>.</p>"},{"location":"reference/models/#wom.models.Competition.score","title":"score  <code>instance-attribute</code>","text":"<pre><code>score: int\n</code></pre> <p>The competition's score.</p>"},{"location":"reference/models/#wom.models.Competition.starts_at","title":"starts_at  <code>instance-attribute</code>","text":"<pre><code>starts_at: datetime\n</code></pre> <p>The date the competition started at.</p>"},{"location":"reference/models/#wom.models.Competition.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre> <p>The title of the competition.</p>"},{"location":"reference/models/#wom.models.Competition.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: CompetitionType\n</code></pre> <p>The CompetitionType.</p>"},{"location":"reference/models/#wom.models.Competition.updated_at","title":"updated_at  <code>instance-attribute</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>The date the competition was updated.</p>"},{"location":"reference/models/#wom.models.CompetitionCSVTableType","title":"CompetitionCSVTableType","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Table types used to return competition CSV details.</p> Source code in <code>wom/models/competitions/enums.py</code> <pre><code>class CompetitionCSVTableType(BaseEnum):\n    \"\"\"Table types used to return competition CSV details.\"\"\"\n\n    Participants = \"participants\"\n    Team = \"team\"\n    Teams = \"teams\"\n</code></pre>"},{"location":"reference/models/#wom.models.CompetitionDetail","title":"CompetitionDetail","text":"<p>             Bases: <code>Competition</code></p> <p>Represents competition details.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class CompetitionDetail(Competition):\n    \"\"\"Represents competition details.\"\"\"\n\n    participations: t.List[CompetitionParticipationDetail] = []  # type: ignore[assignment]\n    \"\"\"A list of [`CompetitionParticipationDetail`]\n    [wom.CompetitionParticipationDetail] participations for this\n    competition.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.CompetitionDetail.participations","title":"participations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>participations: List[CompetitionParticipationDetail] = []\n</code></pre> <p>A list of <code>CompetitionParticipationDetail</code> participations for this competition.</p>"},{"location":"reference/models/#wom.models.CompetitionHistoryDataPoint","title":"CompetitionHistoryDataPoint","text":"<p>             Bases: <code>BaseModel</code></p> <p>A competition history data point.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class CompetitionHistoryDataPoint(BaseModel):\n    \"\"\"A competition history data point.\"\"\"\n\n    date: datetime\n    \"\"\"The date this data point occurred.\"\"\"\n\n    value: int\n    \"\"\"The value of the data point.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.CompetitionHistoryDataPoint.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: datetime\n</code></pre> <p>The date this data point occurred.</p>"},{"location":"reference/models/#wom.models.CompetitionHistoryDataPoint.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: int\n</code></pre> <p>The value of the data point.</p>"},{"location":"reference/models/#wom.models.CompetitionParticipation","title":"CompetitionParticipation","text":"<p>             Bases: <code>Participation</code></p> <p>Represents a competition participation.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class CompetitionParticipation(Participation):\n    \"\"\"Represents a competition participation.\"\"\"\n\n    player: Player\n    \"\"\"The [`Player`][wom.Player] that participated in this competition.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.CompetitionParticipation.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The <code>Player</code> that participated in this competition.</p>"},{"location":"reference/models/#wom.models.CompetitionParticipationDetail","title":"CompetitionParticipationDetail","text":"<p>             Bases: <code>CompetitionParticipation</code></p> <p>Represents competition participation details.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class CompetitionParticipationDetail(CompetitionParticipation):\n    \"\"\"Represents competition participation details.\"\"\"\n\n    progress: CompetitionProgress\n    \"\"\"The [`CompetitionProgress`][wom.CompetitionProgress] that was\n    made.\n    \"\"\"\n\n    levels: CompetitionProgress\n    \"\"\"The [`CompetitionProgress`][wom.CompetitionProgress] as it relates to\n    the number of levels gained. Only contains useful information for skilling\n    competitions.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.CompetitionParticipationDetail.levels","title":"levels  <code>instance-attribute</code>","text":"<pre><code>levels: CompetitionProgress\n</code></pre> <p>The <code>CompetitionProgress</code> as it relates to the number of levels gained. Only contains useful information for skilling competitions.</p>"},{"location":"reference/models/#wom.models.CompetitionParticipationDetail.progress","title":"progress  <code>instance-attribute</code>","text":"<pre><code>progress: CompetitionProgress\n</code></pre> <p>The <code>CompetitionProgress</code> that was made.</p>"},{"location":"reference/models/#wom.models.CompetitionProgress","title":"CompetitionProgress","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents progress in a competition.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class CompetitionProgress(BaseModel):\n    \"\"\"Represents progress in a competition.\"\"\"\n\n    start: int\n    \"\"\"The starting value for the competition's metric.\"\"\"\n\n    end: int\n    \"\"\"The ending value for the competition's metric.\"\"\"\n\n    gained: int\n    \"\"\"The amount of progress gained in the metric.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.CompetitionProgress.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: int\n</code></pre> <p>The ending value for the competition's metric.</p>"},{"location":"reference/models/#wom.models.CompetitionProgress.gained","title":"gained  <code>instance-attribute</code>","text":"<pre><code>gained: int\n</code></pre> <p>The amount of progress gained in the metric.</p>"},{"location":"reference/models/#wom.models.CompetitionProgress.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: int\n</code></pre> <p>The starting value for the competition's metric.</p>"},{"location":"reference/models/#wom.models.CompetitionStatus","title":"CompetitionStatus","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Potential competition statuses.</p> Source code in <code>wom/models/competitions/enums.py</code> <pre><code>class CompetitionStatus(BaseEnum):\n    \"\"\"Potential competition statuses.\"\"\"\n\n    Upcoming = \"upcoming\"\n    Ongoing = \"ongoing\"\n    Finished = \"finished\"\n</code></pre>"},{"location":"reference/models/#wom.models.CompetitionType","title":"CompetitionType","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Competition types available on WOM.</p> Source code in <code>wom/models/competitions/enums.py</code> <pre><code>class CompetitionType(BaseEnum):\n    \"\"\"Competition types available on WOM.\"\"\"\n\n    Classic = \"classic\"\n    Team = \"team\"\n</code></pre>"},{"location":"reference/models/#wom.models.ComputedGains","title":"ComputedGains","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents computed gains made by a player.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class ComputedGains(BaseModel):\n    \"\"\"Represents computed gains made by a player.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The computed metric being measured.\"\"\"\n\n    rank: Gains\n    \"\"\"The rank [`Gains`][wom.Gains].\"\"\"\n\n    value: Gains\n    \"\"\"The value [`Gains`][wom.Gains].\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.ComputedGains.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The computed metric being measured.</p>"},{"location":"reference/models/#wom.models.ComputedGains.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: Gains\n</code></pre> <p>The rank <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.ComputedGains.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Gains\n</code></pre> <p>The value <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.ComputedMetric","title":"ComputedMetric","text":"<p>             Bases: <code>BaseModel</code></p> <p>Details regarding a computed metric.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class ComputedMetric(BaseModel):\n    \"\"\"Details regarding a computed metric.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The computed metric being measured.\"\"\"\n\n    rank: int\n    \"\"\"The players rank in the computed metric.\"\"\"\n\n    value: float\n    \"\"\"The value of the computed metric.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.ComputedMetric.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The computed metric being measured.</p>"},{"location":"reference/models/#wom.models.ComputedMetric.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The players rank in the computed metric.</p>"},{"location":"reference/models/#wom.models.ComputedMetric.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: float\n</code></pre> <p>The value of the computed metric.</p>"},{"location":"reference/models/#wom.models.ComputedMetricLeader","title":"ComputedMetricLeader","text":"<p>             Bases: <code>MetricLeader</code></p> <p>Represents a leader in a particular computed metric.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class ComputedMetricLeader(MetricLeader):\n    \"\"\"Represents a leader in a particular computed metric.\"\"\"\n\n    value: float\n    \"\"\"The value of the computed metric.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.ComputedMetricLeader.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: float\n</code></pre> <p>The value of the computed metric.</p>"},{"location":"reference/models/#wom.models.Country","title":"Country","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Countries in the world.</p> Source code in <code>wom/models/players/enums.py</code> <pre><code>class Country(BaseEnum):\n    \"\"\"Countries in the world.\"\"\"\n\n    Ad = \"AD\"\n    Ae = \"AE\"\n    Af = \"AF\"\n    Ag = \"AG\"\n    Ai = \"AI\"\n    Al = \"AL\"\n    Am = \"AM\"\n    Ao = \"AO\"\n    Aq = \"AQ\"\n    Ar = \"AR\"\n    As = \"AS\"\n    At = \"AT\"\n    Au = \"AU\"\n    Aw = \"AW\"\n    Ax = \"AX\"\n    Az = \"AZ\"\n    Ba = \"BA\"\n    Bb = \"BB\"\n    Bd = \"BD\"\n    Be = \"BE\"\n    Bf = \"BF\"\n    Bg = \"BG\"\n    Bh = \"BH\"\n    Bi = \"BI\"\n    Bj = \"BJ\"\n    Bl = \"BL\"\n    Bm = \"BM\"\n    Bn = \"BN\"\n    Bo = \"BO\"\n    Bq = \"BQ\"\n    Br = \"BR\"\n    Bs = \"BS\"\n    Bt = \"BT\"\n    Bv = \"BV\"\n    Bw = \"BW\"\n    By = \"BY\"\n    Bz = \"BZ\"\n    Ca = \"CA\"\n    Cc = \"CC\"\n    Cd = \"CD\"\n    Cf = \"CF\"\n    Cg = \"CG\"\n    Ch = \"CH\"\n    Ci = \"CI\"\n    Ck = \"CK\"\n    Cl = \"CL\"\n    Cm = \"CM\"\n    Cn = \"CN\"\n    Co = \"CO\"\n    Cr = \"CR\"\n    Cu = \"CU\"\n    Cv = \"CV\"\n    Cw = \"CW\"\n    Cx = \"CX\"\n    Cy = \"CY\"\n    Cz = \"CZ\"\n    De = \"DE\"\n    Dj = \"DJ\"\n    Dk = \"DK\"\n    Dm = \"DM\"\n    Do = \"DO\"\n    Dz = \"DZ\"\n    Ec = \"EC\"\n    Ee = \"EE\"\n    Eg = \"EG\"\n    Eh = \"EH\"\n    Er = \"ER\"\n    Es = \"ES\"\n    Et = \"ET\"\n    Fi = \"FI\"\n    Fj = \"FJ\"\n    Fk = \"FK\"\n    Fm = \"FM\"\n    Fo = \"FO\"\n    Fr = \"FR\"\n    Ga = \"GA\"\n    Gb = \"GB\"\n    Gd = \"GD\"\n    Ge = \"GE\"\n    Gf = \"GF\"\n    Gg = \"GG\"\n    Gh = \"GH\"\n    Gi = \"GI\"\n    Gl = \"GL\"\n    Gm = \"GM\"\n    Gn = \"GN\"\n    Gp = \"GP\"\n    Gq = \"GQ\"\n    Gr = \"GR\"\n    Gs = \"GS\"\n    Gt = \"GT\"\n    Gu = \"GU\"\n    Gw = \"GW\"\n    Gy = \"GY\"\n    Hk = \"HK\"\n    Hm = \"HM\"\n    Hn = \"HN\"\n    Hr = \"HR\"\n    Ht = \"HT\"\n    Hu = \"HU\"\n    Id = \"ID\"\n    Ie = \"IE\"\n    Il = \"IL\"\n    Im = \"IM\"\n    In = \"IN\"\n    Io = \"IO\"\n    Iq = \"IQ\"\n    Ir = \"IR\"\n    Is = \"IS\"\n    It = \"IT\"\n    Je = \"JE\"\n    Jm = \"JM\"\n    Jo = \"JO\"\n    Jp = \"JP\"\n    Ke = \"KE\"\n    Kg = \"KG\"\n    Kh = \"KH\"\n    Ki = \"KI\"\n    Km = \"KM\"\n    Kn = \"KN\"\n    Kp = \"KP\"\n    Kr = \"KR\"\n    Kw = \"KW\"\n    Ky = \"KY\"\n    Kz = \"KZ\"\n    La = \"LA\"\n    Lb = \"LB\"\n    Lc = \"LC\"\n    Li = \"LI\"\n    Lk = \"LK\"\n    Lr = \"LR\"\n    Ls = \"LS\"\n    Lt = \"LT\"\n    Lu = \"LU\"\n    Lv = \"LV\"\n    Ly = \"LY\"\n    Ma = \"MA\"\n    Mc = \"MC\"\n    Md = \"MD\"\n    Me = \"ME\"\n    Mf = \"MF\"\n    Mg = \"MG\"\n    Mh = \"MH\"\n    Mk = \"MK\"\n    Ml = \"ML\"\n    Mm = \"MM\"\n    Mn = \"MN\"\n    Mo = \"MO\"\n    Mp = \"MP\"\n    Mq = \"MQ\"\n    Mr = \"MR\"\n    Ms = \"MS\"\n    Mt = \"MT\"\n    Mu = \"MU\"\n    Mv = \"MV\"\n    Mw = \"MW\"\n    Mx = \"MX\"\n    My = \"MY\"\n    Mz = \"MZ\"\n    Na = \"NA\"\n    Nc = \"NC\"\n    Ne = \"NE\"\n    Nf = \"NF\"\n    Ng = \"NG\"\n    Ni = \"NI\"\n    Nl = \"NL\"\n    No = \"NO\"\n    Np = \"NP\"\n    Nr = \"NR\"\n    Nu = \"NU\"\n    Nz = \"NZ\"\n    Om = \"OM\"\n    Pa = \"PA\"\n    Pe = \"PE\"\n    Pf = \"PF\"\n    Pg = \"PG\"\n    Ph = \"PH\"\n    Pk = \"PK\"\n    Pl = \"PL\"\n    Pm = \"PM\"\n    Pn = \"PN\"\n    Pr = \"PR\"\n    Ps = \"PS\"\n    Pt = \"PT\"\n    Pw = \"PW\"\n    Py = \"PY\"\n    Qa = \"QA\"\n    Re = \"RE\"\n    Ro = \"RO\"\n    Rs = \"RS\"\n    Ru = \"RU\"\n    Rw = \"RW\"\n    Sa = \"SA\"\n    Sb = \"SB\"\n    Sc = \"SC\"\n    Sd = \"SD\"\n    Se = \"SE\"\n    Sg = \"SG\"\n    Sh = \"SH\"\n    Si = \"SI\"\n    Sj = \"SJ\"\n    Sk = \"SK\"\n    Sl = \"SL\"\n    Sm = \"SM\"\n    Sn = \"SN\"\n    So = \"SO\"\n    Sr = \"SR\"\n    Ss = \"SS\"\n    St = \"ST\"\n    Sv = \"SV\"\n    Sx = \"SX\"\n    Sy = \"SY\"\n    Sz = \"SZ\"\n    Tc = \"TC\"\n    Td = \"TD\"\n    Tf = \"TF\"\n    Tg = \"TG\"\n    Th = \"TH\"\n    Tj = \"TJ\"\n    Tk = \"TK\"\n    Tl = \"TL\"\n    Tm = \"TM\"\n    Tn = \"TN\"\n    To = \"TO\"\n    Tr = \"TR\"\n    Tt = \"TT\"\n    Tv = \"TV\"\n    Tw = \"TW\"\n    Tz = \"TZ\"\n    Ua = \"UA\"\n    Ug = \"UG\"\n    Um = \"UM\"\n    Us = \"US\"\n    Uy = \"UY\"\n    Uz = \"UZ\"\n    Va = \"VA\"\n    Vc = \"VC\"\n    Ve = \"VE\"\n    Vg = \"VG\"\n    Vi = \"VI\"\n    Vn = \"VN\"\n    Vu = \"VU\"\n    Wf = \"WF\"\n    Ws = \"WS\"\n    Ye = \"YE\"\n    Yt = \"YT\"\n    Za = \"ZA\"\n    Zm = \"ZM\"\n    Zw = \"ZW\"\n</code></pre>"},{"location":"reference/models/#wom.models.CreatedCompetitionDetail","title":"CreatedCompetitionDetail","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a competition that was just created.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class CreatedCompetitionDetail(BaseModel):\n    \"\"\"Represents a competition that was just created.\"\"\"\n\n    competition: Competition\n    \"\"\"The [`Competition`][wom.Competition] itself.\"\"\"\n\n    verification_code: str\n    \"\"\"The verification code for the competition.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.CreatedCompetitionDetail.competition","title":"competition  <code>instance-attribute</code>","text":"<pre><code>competition: Competition\n</code></pre> <p>The <code>Competition</code> itself.</p>"},{"location":"reference/models/#wom.models.CreatedCompetitionDetail.verification_code","title":"verification_code  <code>instance-attribute</code>","text":"<pre><code>verification_code: str\n</code></pre> <p>The verification code for the competition.</p>"},{"location":"reference/models/#wom.models.CreatedGroupDetail","title":"CreatedGroupDetail","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a newly created group.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class CreatedGroupDetail(BaseModel):\n    \"\"\"Represents a newly created group.\"\"\"\n\n    group: GroupDetail\n    \"\"\"The details about the group.\"\"\"\n\n    verification_code: str\n    \"\"\"The verification code for the group.\n\n    !!! note\n\n        This should be kept safe and only shared trusted clan members.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.CreatedGroupDetail.group","title":"group  <code>instance-attribute</code>","text":"<pre><code>group: GroupDetail\n</code></pre> <p>The details about the group.</p>"},{"location":"reference/models/#wom.models.CreatedGroupDetail.verification_code","title":"verification_code  <code>instance-attribute</code>","text":"<pre><code>verification_code: str\n</code></pre> <p>The verification code for the group.</p> <p>Note</p> <p>This should be kept safe and only shared trusted clan members.</p>"},{"location":"reference/models/#wom.models.DeltaLeaderboardEntry","title":"DeltaLeaderboardEntry","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a leaderboard entry over the given delta.</p> Source code in <code>wom/models/deltas/models.py</code> <pre><code>class DeltaLeaderboardEntry(BaseModel):\n    \"\"\"Represents a leaderboard entry over the given delta.\"\"\"\n\n    player_id: int\n    \"\"\"The ID of the player holding this leaderboard entry.\"\"\"\n\n    gained: int\n    \"\"\"The value gained over the delta.\"\"\"\n\n    start_date: datetime\n    \"\"\"The start date of the delta.\"\"\"\n\n    end_date: datetime\n    \"\"\"The end date of the delta.\"\"\"\n\n    player: Player\n    \"\"\"The [`Player`][wom.Player] holding this leaderboard entry.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.DeltaLeaderboardEntry.end_date","title":"end_date  <code>instance-attribute</code>","text":"<pre><code>end_date: datetime\n</code></pre> <p>The end date of the delta.</p>"},{"location":"reference/models/#wom.models.DeltaLeaderboardEntry.gained","title":"gained  <code>instance-attribute</code>","text":"<pre><code>gained: int\n</code></pre> <p>The value gained over the delta.</p>"},{"location":"reference/models/#wom.models.DeltaLeaderboardEntry.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The <code>Player</code> holding this leaderboard entry.</p>"},{"location":"reference/models/#wom.models.DeltaLeaderboardEntry.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The ID of the player holding this leaderboard entry.</p>"},{"location":"reference/models/#wom.models.DeltaLeaderboardEntry.start_date","title":"start_date  <code>instance-attribute</code>","text":"<pre><code>start_date: datetime\n</code></pre> <p>The start date of the delta.</p>"},{"location":"reference/models/#wom.models.Gains","title":"Gains","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents gains made by a player.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class Gains(BaseModel):\n    \"\"\"Represents gains made by a player.\"\"\"\n\n    gained: float\n    \"\"\"The amount gained.\"\"\"\n\n    start: float\n    \"\"\"The starting amount.\"\"\"\n\n    end: float\n    \"\"\"The ending amount.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Gains.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: float\n</code></pre> <p>The ending amount.</p>"},{"location":"reference/models/#wom.models.Gains.gained","title":"gained  <code>instance-attribute</code>","text":"<pre><code>gained: float\n</code></pre> <p>The amount gained.</p>"},{"location":"reference/models/#wom.models.Gains.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: float\n</code></pre> <p>The starting amount.</p>"},{"location":"reference/models/#wom.models.Group","title":"Group","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a group of players on WOM.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class Group(BaseModel):\n    \"\"\"Represents a group of players on WOM.\"\"\"\n\n    id: int\n    \"\"\"The unique ID for this group.\"\"\"\n\n    name: str\n    \"\"\"The groups name.\"\"\"\n\n    clan_chat: str\n    \"\"\"The clan chat for this group.\"\"\"\n\n    description: t.Optional[str]\n    \"\"\"The groups optional description.\"\"\"\n\n    homeworld: t.Optional[int]\n    \"\"\"The groups optional homeworld.\"\"\"\n\n    verified: bool\n    \"\"\"Whether or not this group is verified.\"\"\"\n\n    patron: bool\n    \"\"\"Whether or not this group is subscribed via Patreon.\"\"\"\n\n    profile_image: t.Optional[str]\n    \"\"\"The profile image url for this group, if any.\"\"\"\n\n    banner_image: t.Optional[str]\n    \"\"\"The banner image url for this group, if any.\"\"\"\n\n    score: int\n    \"\"\"The groups score.\"\"\"\n\n    created_at: datetime\n    \"\"\"The date the group was created.\"\"\"\n\n    updated_at: datetime\n    \"\"\"The date the group was updated.\"\"\"\n\n    member_count: int\n    \"\"\"The number of members in the group.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Group.banner_image","title":"banner_image  <code>instance-attribute</code>","text":"<pre><code>banner_image: Optional[str]\n</code></pre> <p>The banner image url for this group, if any.</p>"},{"location":"reference/models/#wom.models.Group.clan_chat","title":"clan_chat  <code>instance-attribute</code>","text":"<pre><code>clan_chat: str\n</code></pre> <p>The clan chat for this group.</p>"},{"location":"reference/models/#wom.models.Group.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The date the group was created.</p>"},{"location":"reference/models/#wom.models.Group.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>The groups optional description.</p>"},{"location":"reference/models/#wom.models.Group.homeworld","title":"homeworld  <code>instance-attribute</code>","text":"<pre><code>homeworld: Optional[int]\n</code></pre> <p>The groups optional homeworld.</p>"},{"location":"reference/models/#wom.models.Group.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique ID for this group.</p>"},{"location":"reference/models/#wom.models.Group.member_count","title":"member_count  <code>instance-attribute</code>","text":"<pre><code>member_count: int\n</code></pre> <p>The number of members in the group.</p>"},{"location":"reference/models/#wom.models.Group.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The groups name.</p>"},{"location":"reference/models/#wom.models.Group.patron","title":"patron  <code>instance-attribute</code>","text":"<pre><code>patron: bool\n</code></pre> <p>Whether or not this group is subscribed via Patreon.</p>"},{"location":"reference/models/#wom.models.Group.profile_image","title":"profile_image  <code>instance-attribute</code>","text":"<pre><code>profile_image: Optional[str]\n</code></pre> <p>The profile image url for this group, if any.</p>"},{"location":"reference/models/#wom.models.Group.score","title":"score  <code>instance-attribute</code>","text":"<pre><code>score: int\n</code></pre> <p>The groups score.</p>"},{"location":"reference/models/#wom.models.Group.updated_at","title":"updated_at  <code>instance-attribute</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>The date the group was updated.</p>"},{"location":"reference/models/#wom.models.Group.verified","title":"verified  <code>instance-attribute</code>","text":"<pre><code>verified: bool\n</code></pre> <p>Whether or not this group is verified.</p>"},{"location":"reference/models/#wom.models.GroupActivity","title":"GroupActivity","text":"<p>             Bases: <code>BaseModel</code></p> <p>An activity that occurred in a group.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupActivity(BaseModel):\n    \"\"\"An activity that occurred in a group.\"\"\"\n\n    group_id: int\n    \"\"\"The unique ID of the group this activity occurred for.\"\"\"\n\n    player_id: int\n    \"\"\"The unique ID of the player associated with this activity.\"\"\"\n\n    type: GroupActivityType\n    \"\"\"The type of activity that occurred.\"\"\"\n\n    role: t.Optional[GroupRole]\n    \"\"\"The players role in the group, if they have one.\"\"\"\n\n    previous_role: t.Optional[GroupRole]\n    \"\"\"The players previous role in the group, if they had one.\"\"\"\n\n    created_at: datetime\n    \"\"\"The datetime indicating when this activity occurred.\"\"\"\n\n    player: Player\n    \"\"\"The player associated with this activity.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupActivity.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The datetime indicating when this activity occurred.</p>"},{"location":"reference/models/#wom.models.GroupActivity.group_id","title":"group_id  <code>instance-attribute</code>","text":"<pre><code>group_id: int\n</code></pre> <p>The unique ID of the group this activity occurred for.</p>"},{"location":"reference/models/#wom.models.GroupActivity.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The player associated with this activity.</p>"},{"location":"reference/models/#wom.models.GroupActivity.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The unique ID of the player associated with this activity.</p>"},{"location":"reference/models/#wom.models.GroupActivity.previous_role","title":"previous_role  <code>instance-attribute</code>","text":"<pre><code>previous_role: Optional[GroupRole]\n</code></pre> <p>The players previous role in the group, if they had one.</p>"},{"location":"reference/models/#wom.models.GroupActivity.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Optional[GroupRole]\n</code></pre> <p>The players role in the group, if they have one.</p>"},{"location":"reference/models/#wom.models.GroupActivity.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: GroupActivityType\n</code></pre> <p>The type of activity that occurred.</p>"},{"location":"reference/models/#wom.models.GroupActivityType","title":"GroupActivityType","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Activities that can occur for a group.</p> Source code in <code>wom/models/groups/enums.py</code> <pre><code>class GroupActivityType(BaseEnum):\n    \"\"\"Activities that can occur for a group.\"\"\"\n\n    ChangedRole = \"changed_role\"\n    Joined = \"joined\"\n    Left = \"left\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupDetail","title":"GroupDetail","text":"<p>             Bases: <code>Group</code></p> <p>Represents details about a group.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupDetail(Group):\n    \"\"\"Represents details about a group.\"\"\"\n\n    memberships: t.List[GroupMembership]\n    \"\"\"A list of [`GroupMemberships`][wom.GroupMembership].\"\"\"\n\n    social_links: SocialLinks\n    \"\"\"The social links for this group.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupDetail.memberships","title":"memberships  <code>instance-attribute</code>","text":"<pre><code>memberships: List[GroupMembership]\n</code></pre> <p>A list of <code>GroupMemberships</code>.</p>"},{"location":"reference/models/#wom.models.GroupDetail.social_links","title":"social_links  <code>instance-attribute</code>","text":"<pre><code>social_links: SocialLinks\n</code></pre> <p>The social links for this group.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresActivityItem","title":"GroupHiscoresActivityItem","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a group hiscores item for activities.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupHiscoresActivityItem(BaseModel, tag=\"activity\"):\n    \"\"\"Represents a group hiscores item for activities.\"\"\"\n\n    rank: int\n    \"\"\"The rank of the hiscore.\"\"\"\n\n    score: int\n    \"\"\"The activity score.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupHiscoresActivityItem.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The rank of the hiscore.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresActivityItem.score","title":"score  <code>instance-attribute</code>","text":"<pre><code>score: int\n</code></pre> <p>The activity score.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresBossItem","title":"GroupHiscoresBossItem","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a group hiscores item for bosses.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupHiscoresBossItem(BaseModel, tag=\"boss\"):\n    \"\"\"Represents a group hiscores item for bosses.\"\"\"\n\n    rank: int\n    \"\"\"The rank of the hiscore.\"\"\"\n\n    kills: int\n    \"\"\"The number of boss kills.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupHiscoresBossItem.kills","title":"kills  <code>instance-attribute</code>","text":"<pre><code>kills: int\n</code></pre> <p>The number of boss kills.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresBossItem.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The rank of the hiscore.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresComputedMetricItem","title":"GroupHiscoresComputedMetricItem","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a group hiscores item for computed metrics.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupHiscoresComputedMetricItem(BaseModel, tag=\"computed\"):\n    \"\"\"Represents a group hiscores item for computed metrics.\"\"\"\n\n    rank: int\n    \"\"\"The rank of the hiscore.\"\"\"\n\n    value: int\n    \"\"\"The value of the computed metric.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupHiscoresComputedMetricItem.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The rank of the hiscore.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresComputedMetricItem.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: int\n</code></pre> <p>The value of the computed metric.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresEntry","title":"GroupHiscoresEntry","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a group hiscores entry.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupHiscoresEntry(BaseModel):\n    \"\"\"Represents a group hiscores entry.\"\"\"\n\n    player: Player\n    \"\"\"The [`Player`][wom.Player] responsible for the entry.\"\"\"\n\n    data: t.Union[\n        GroupHiscoresActivityItem,\n        GroupHiscoresBossItem,\n        GroupHiscoresSkillItem,\n        GroupHiscoresComputedMetricItem,\n    ]\n    \"\"\"The data for this hiscores entry.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupHiscoresEntry.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: Union[\n    GroupHiscoresActivityItem,\n    GroupHiscoresBossItem,\n    GroupHiscoresSkillItem,\n    GroupHiscoresComputedMetricItem,\n]\n</code></pre> <p>The data for this hiscores entry.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresEntry.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The <code>Player</code> responsible for the entry.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresSkillItem","title":"GroupHiscoresSkillItem","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a group hiscores item for skills.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupHiscoresSkillItem(BaseModel, tag=\"skill\"):\n    \"\"\"Represents a group hiscores item for skills.\"\"\"\n\n    rank: int\n    \"\"\"The rank of the hiscore.\"\"\"\n\n    level: int\n    \"\"\"The level of the skill.\"\"\"\n\n    experience: int\n    \"\"\"The experience in the skill.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupHiscoresSkillItem.experience","title":"experience  <code>instance-attribute</code>","text":"<pre><code>experience: int\n</code></pre> <p>The experience in the skill.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresSkillItem.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level: int\n</code></pre> <p>The level of the skill.</p>"},{"location":"reference/models/#wom.models.GroupHiscoresSkillItem.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The rank of the hiscore.</p>"},{"location":"reference/models/#wom.models.GroupMemberFragment","title":"GroupMemberFragment","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a condensed group member.</p> <p>Tip</p> <p>This is a model class that you will create in order to send data to some endpoints.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupMemberFragment(BaseModel):\n    \"\"\"Represents a condensed group member.\n\n    !!! tip\n\n        This is a model class that you will create in order to send\n        data to some endpoints.\n    \"\"\"\n\n    username: str\n    \"\"\"The group members username.\"\"\"\n\n    role: t.Optional[GroupRole] = None\n    \"\"\"The optional [`GroupRole`][wom.GroupRole] for the member.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupMemberFragment.role","title":"role  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>role: Optional[GroupRole] = None\n</code></pre> <p>The optional <code>GroupRole</code> for the member.</p>"},{"location":"reference/models/#wom.models.GroupMemberFragment.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>The group members username.</p>"},{"location":"reference/models/#wom.models.GroupMemberGains","title":"GroupMemberGains","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a leaderboard entry over the given delta.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupMemberGains(BaseModel):\n    \"\"\"Represents a leaderboard entry over the given delta.\"\"\"\n\n    start_date: datetime\n    \"\"\"The start date of the gains.\"\"\"\n\n    end_date: datetime\n    \"\"\"The end date of the gains.\"\"\"\n\n    player: Player\n    \"\"\"The [`Player`][wom.Player] that attained these gains.\"\"\"\n\n    data: Gains\n    \"\"\"The [`Gains`][wom.Gains] for this group member.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupMemberGains.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: Gains\n</code></pre> <p>The <code>Gains</code> for this group member.</p>"},{"location":"reference/models/#wom.models.GroupMemberGains.end_date","title":"end_date  <code>instance-attribute</code>","text":"<pre><code>end_date: datetime\n</code></pre> <p>The end date of the gains.</p>"},{"location":"reference/models/#wom.models.GroupMemberGains.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The <code>Player</code> that attained these gains.</p>"},{"location":"reference/models/#wom.models.GroupMemberGains.start_date","title":"start_date  <code>instance-attribute</code>","text":"<pre><code>start_date: datetime\n</code></pre> <p>The start date of the gains.</p>"},{"location":"reference/models/#wom.models.GroupMembership","title":"GroupMembership","text":"<p>             Bases: <code>Membership</code></p> <p>Represents a group membership.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupMembership(Membership):\n    \"\"\"Represents a group membership.\"\"\"\n\n    player: Player\n    \"\"\"The [`Player`][wom.Player] that is a member.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupMembership.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The <code>Player</code> that is a member.</p>"},{"location":"reference/models/#wom.models.GroupRole","title":"GroupRole","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Roles that can be assigned to group members.</p> Source code in <code>wom/models/groups/enums.py</code> <pre><code>class GroupRole(BaseEnum):\n    \"\"\"Roles that can be assigned to group members.\"\"\"\n\n    Achiever = \"achiever\"\n    Adamant = \"adamant\"\n    Adept = \"adept\"\n    Administrator = \"administrator\"\n    Admiral = \"admiral\"\n    Adventurer = \"adventurer\"\n    Air = \"air\"\n    Anchor = \"anchor\"\n    Apothecary = \"apothecary\"\n    Archer = \"archer\"\n    Armadylean = \"armadylean\"\n    Artillery = \"artillery\"\n    Artisan = \"artisan\"\n    Asgarnian = \"asgarnian\"\n    Assassin = \"assassin\"\n    Assistant = \"assistant\"\n    Astral = \"astral\"\n    Athlete = \"athlete\"\n    Attacker = \"attacker\"\n    Bandit = \"bandit\"\n    Bandosian = \"bandosian\"\n    Barbarian = \"barbarian\"\n    Battlemage = \"battlemage\"\n    Beast = \"beast\"\n    Berserker = \"berserker\"\n    Blisterwood = \"blisterwood\"\n    Blood = \"blood\"\n    Blue = \"blue\"\n    Bob = \"bob\"\n    Body = \"body\"\n    Brassican = \"brassican\"\n    Brawler = \"brawler\"\n    Brigadier = \"brigadier\"\n    Brigand = \"brigand\"\n    Bronze = \"bronze\"\n    Bruiser = \"bruiser\"\n    Bulwark = \"bulwark\"\n    Burglar = \"burglar\"\n    Burnt = \"burnt\"\n    Cadet = \"cadet\"\n    Captain = \"captain\"\n    Carry = \"carry\"\n    Champion = \"champion\"\n    Chaos = \"chaos\"\n    Cleric = \"cleric\"\n    Collector = \"collector\"\n    Colonel = \"colonel\"\n    Commander = \"commander\"\n    Competitor = \"competitor\"\n    Completionist = \"completionist\"\n    Constructor = \"constructor\"\n    Cook = \"cook\"\n    Coordinator = \"coordinator\"\n    Corporal = \"corporal\"\n    Cosmic = \"cosmic\"\n    Councillor = \"councillor\"\n    Crafter = \"crafter\"\n    Crew = \"crew\"\n    Crusader = \"crusader\"\n    Cutpurse = \"cutpurse\"\n    Death = \"death\"\n    Defender = \"defender\"\n    Defiler = \"defiler\"\n    Deputy_owner = \"deputy_owner\"\n    Destroyer = \"destroyer\"\n    Diamond = \"diamond\"\n    Diseased = \"diseased\"\n    Doctor = \"doctor\"\n    Dogsbody = \"dogsbody\"\n    Dragon = \"dragon\"\n    Dragonstone = \"dragonstone\"\n    Druid = \"druid\"\n    Duellist = \"duellist\"\n    Earth = \"earth\"\n    Elite = \"elite\"\n    Emerald = \"emerald\"\n    Enforcer = \"enforcer\"\n    Epic = \"epic\"\n    Executive = \"executive\"\n    Expert = \"expert\"\n    Explorer = \"explorer\"\n    Farmer = \"farmer\"\n    Feeder = \"feeder\"\n    Fighter = \"fighter\"\n    Fire = \"fire\"\n    Firemaker = \"firemaker\"\n    Firestarter = \"firestarter\"\n    Fisher = \"fisher\"\n    Fletcher = \"fletcher\"\n    Forager = \"forager\"\n    Fremennik = \"fremennik\"\n    Gamer = \"gamer\"\n    Gatherer = \"gatherer\"\n    General = \"general\"\n    Gnome_child = \"gnome_child\"\n    Gnome_elder = \"gnome_elder\"\n    Goblin = \"goblin\"\n    Gold = \"gold\"\n    Goon = \"goon\"\n    Green = \"green\"\n    Grey = \"grey\"\n    Guardian = \"guardian\"\n    Guthixian = \"guthixian\"\n    Harpoon = \"harpoon\"\n    Healer = \"healer\"\n    Hellcat = \"hellcat\"\n    Helper = \"helper\"\n    Herbologist = \"herbologist\"\n    Hero = \"hero\"\n    Holy = \"holy\"\n    Hoarder = \"hoarder\"\n    Hunter = \"hunter\"\n    Ignitor = \"ignitor\"\n    Illusionist = \"illusionist\"\n    Imp = \"imp\"\n    Infantry = \"infantry\"\n    Inquisitor = \"inquisitor\"\n    Iron = \"iron\"\n    Jade = \"jade\"\n    Justiciar = \"justiciar\"\n    Kandarin = \"kandarin\"\n    Karamjan = \"karamjan\"\n    Kharidian = \"kharidian\"\n    Kitten = \"kitten\"\n    Knight = \"knight\"\n    Labourer = \"labourer\"\n    Law = \"law\"\n    Leader = \"leader\"\n    Learner = \"learner\"\n    Legacy = \"legacy\"\n    Legend = \"legend\"\n    Legionnaire = \"legionnaire\"\n    Lieutenant = \"lieutenant\"\n    Looter = \"looter\"\n    Lumberjack = \"lumberjack\"\n    Magic = \"magic\"\n    Magician = \"magician\"\n    Major = \"major\"\n    Maple = \"maple\"\n    Marshal = \"marshal\"\n    Master = \"master\"\n    Maxed = \"maxed\"\n    Mediator = \"mediator\"\n    Medic = \"medic\"\n    Mentor = \"mentor\"\n    Member = \"member\"\n    Merchant = \"merchant\"\n    Mind = \"mind\"\n    Miner = \"miner\"\n    Minion = \"minion\"\n    Misthalinian = \"misthalinian\"\n    Mithril = \"mithril\"\n    Moderator = \"moderator\"\n    Monarch = \"monarch\"\n    Morytanian = \"morytanian\"\n    Mystic = \"mystic\"\n    Myth = \"myth\"\n    Natural = \"natural\"\n    Nature = \"nature\"\n    Necromancer = \"necromancer\"\n    Ninja = \"ninja\"\n    Noble = \"noble\"\n    Novice = \"novice\"\n    Nurse = \"nurse\"\n    Oak = \"oak\"\n    Officer = \"officer\"\n    Onyx = \"onyx\"\n    Opal = \"opal\"\n    Oracle = \"oracle\"\n    Orange = \"orange\"\n    Owner = \"owner\"\n    Page = \"page\"\n    Paladin = \"paladin\"\n    Pawn = \"pawn\"\n    Pilgrim = \"pilgrim\"\n    Pine = \"pine\"\n    Pink = \"pink\"\n    Prefect = \"prefect\"\n    Priest = \"priest\"\n    Private = \"private\"\n    Prodigy = \"prodigy\"\n    Proselyte = \"proselyte\"\n    Prospector = \"prospector\"\n    Protector = \"protector\"\n    Pure = \"pure\"\n    Purple = \"purple\"\n    Pyromancer = \"pyromancer\"\n    Quester = \"quester\"\n    Racer = \"racer\"\n    Raider = \"raider\"\n    Ranger = \"ranger\"\n    Record_chaser = \"record_chaser\"\n    Recruit = \"recruit\"\n    Recruiter = \"recruiter\"\n    Red_topaz = \"red_topaz\"\n    Red = \"red\"\n    Rogue = \"rogue\"\n    Ruby = \"ruby\"\n    Rune = \"rune\"\n    Runecrafter = \"runecrafter\"\n    Sage = \"sage\"\n    Sapphire = \"sapphire\"\n    Saradominist = \"saradominist\"\n    Saviour = \"saviour\"\n    Scavenger = \"scavenger\"\n    Scholar = \"scholar\"\n    Scourge = \"scourge\"\n    Scout = \"scout\"\n    Scribe = \"scribe\"\n    Seer = \"seer\"\n    Senator = \"senator\"\n    Sentry = \"sentry\"\n    Serenist = \"serenist\"\n    Sergeant = \"sergeant\"\n    Shaman = \"shaman\"\n    Sheriff = \"sheriff\"\n    Short_green_guy = \"short_green_guy\"\n    Skiller = \"skiller\"\n    Skulled = \"skulled\"\n    Slayer = \"slayer\"\n    Smiter = \"smiter\"\n    Smith = \"smith\"\n    Smuggler = \"smuggler\"\n    Sniper = \"sniper\"\n    Soul = \"soul\"\n    Specialist = \"specialist\"\n    Speed_runner = \"speed_runner\"\n    Spellcaster = \"spellcaster\"\n    Squire = \"squire\"\n    Staff = \"staff\"\n    Steel = \"steel\"\n    Strider = \"strider\"\n    Striker = \"striker\"\n    Summoner = \"summoner\"\n    Superior = \"superior\"\n    Supervisor = \"supervisor\"\n    Teacher = \"teacher\"\n    Templar = \"templar\"\n    Therapist = \"therapist\"\n    Thief = \"thief\"\n    Tirannian = \"tirannian\"\n    Trialist = \"trialist\"\n    Trickster = \"trickster\"\n    Tzkal = \"tzkal\"\n    Tztok = \"tztok\"\n    Unholy = \"unholy\"\n    Vagrant = \"vagrant\"\n    Vanguard = \"vanguard\"\n    Walker = \"walker\"\n    Wanderer = \"wanderer\"\n    Warden = \"warden\"\n    Warlock = \"warlock\"\n    Warrior = \"warrior\"\n    Water = \"water\"\n    Wild = \"wild\"\n    Willow = \"willow\"\n    Wily = \"wily\"\n    Wintumber = \"wintumber\"\n    Witch = \"witch\"\n    Wizard = \"wizard\"\n    Worker = \"worker\"\n    Wrath = \"wrath\"\n    Xerician = \"xerician\"\n    Yellow = \"yellow\"\n    Yew = \"yew\"\n    Zamorakian = \"zamorakian\"\n    Zarosian = \"zarosian\"\n    Zealot = \"zealot\"\n    Zenyte = \"zenyte\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupStatistics","title":"GroupStatistics","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents accumulated group statistics.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class GroupStatistics(\n    BaseModel,\n    rename={\n        \"maxed_combat_count\": \"maxedCombatCount\",\n        \"maxed_total_count\": \"maxedTotalCount\",\n        \"maxed_200ms_count\": \"maxed200msCount\",\n        \"average_stats\": \"averageStats\",\n        \"metric_leaders\": \"metricLeaders\",\n    },\n):\n    \"\"\"Represents accumulated group statistics.\"\"\"\n\n    maxed_combat_count: int\n    \"\"\"The number of maxed combat players in the group.\"\"\"\n\n    maxed_total_count: int\n    \"\"\"The number of maxed total level players in the group.\"\"\"\n\n    maxed_200ms_count: int\n    \"\"\"The number of maxed 200M xp players in the group.\"\"\"\n\n    average_stats: Snapshot\n    \"\"\"The average group statistics in a [`Snapshot`][wom.Snapshot].\"\"\"\n\n    metric_leaders: MetricLeaders\n    \"\"\"The [`MetricLeaders`][wom.MetricLeaders] in this group for each\n    metric.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.GroupStatistics.average_stats","title":"average_stats  <code>instance-attribute</code>","text":"<pre><code>average_stats: Snapshot\n</code></pre> <p>The average group statistics in a <code>Snapshot</code>.</p>"},{"location":"reference/models/#wom.models.GroupStatistics.maxed_200ms_count","title":"maxed_200ms_count  <code>instance-attribute</code>","text":"<pre><code>maxed_200ms_count: int\n</code></pre> <p>The number of maxed 200M xp players in the group.</p>"},{"location":"reference/models/#wom.models.GroupStatistics.maxed_combat_count","title":"maxed_combat_count  <code>instance-attribute</code>","text":"<pre><code>maxed_combat_count: int\n</code></pre> <p>The number of maxed combat players in the group.</p>"},{"location":"reference/models/#wom.models.GroupStatistics.maxed_total_count","title":"maxed_total_count  <code>instance-attribute</code>","text":"<pre><code>maxed_total_count: int\n</code></pre> <p>The number of maxed total level players in the group.</p>"},{"location":"reference/models/#wom.models.GroupStatistics.metric_leaders","title":"metric_leaders  <code>instance-attribute</code>","text":"<pre><code>metric_leaders: MetricLeaders\n</code></pre> <p>The <code>MetricLeaders</code> in this group for each metric.</p>"},{"location":"reference/models/#wom.models.HttpErrorResponse","title":"HttpErrorResponse","text":"<p>             Bases: <code>BaseModel</code></p> <p>Indicates something went wrong during the request.</p> Source code in <code>wom/models/http.py</code> <pre><code>class HttpErrorResponse(BaseModel):\n    \"\"\"Indicates something went wrong during the request.\"\"\"\n\n    message: str\n    \"\"\"The error message.\"\"\"\n\n    status: int = -1\n    \"\"\"The HTTP status code.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.HttpErrorResponse.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>The error message.</p>"},{"location":"reference/models/#wom.models.HttpErrorResponse.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: int = -1\n</code></pre> <p>The HTTP status code.</p>"},{"location":"reference/models/#wom.models.HttpSuccessResponse","title":"HttpSuccessResponse","text":"<p>             Bases: <code>BaseModel</code></p> <p>Indicates a successful HTTP response.</p> Source code in <code>wom/models/http.py</code> <pre><code>class HttpSuccessResponse(BaseModel):\n    \"\"\"Indicates a successful HTTP response.\"\"\"\n\n    message: str\n    \"\"\"The success message.\"\"\"\n\n    status: int = -1\n    \"\"\"The HTTP status code.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.HttpSuccessResponse.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>The success message.</p>"},{"location":"reference/models/#wom.models.HttpSuccessResponse.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: int = -1\n</code></pre> <p>The HTTP status code.</p>"},{"location":"reference/models/#wom.models.Membership","title":"Membership","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a membership in a group.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class Membership(BaseModel):\n    \"\"\"Represents a membership in a group.\"\"\"\n\n    player_id: int\n    \"\"\"The unique ID of the player in this membership.\"\"\"\n\n    group_id: int\n    \"\"\"The group ID this membership belongs to.\"\"\"\n\n    role: t.Optional[GroupRole]\n    \"\"\"The optional [`GroupRole`][wom.GroupRole] for this membership.\"\"\"\n\n    created_at: datetime\n    \"\"\"The date this membership was created.\"\"\"\n\n    updated_at: datetime\n    \"\"\"The date this membership was updated.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Membership.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The date this membership was created.</p>"},{"location":"reference/models/#wom.models.Membership.group_id","title":"group_id  <code>instance-attribute</code>","text":"<pre><code>group_id: int\n</code></pre> <p>The group ID this membership belongs to.</p>"},{"location":"reference/models/#wom.models.Membership.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The unique ID of the player in this membership.</p>"},{"location":"reference/models/#wom.models.Membership.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Optional[GroupRole]\n</code></pre> <p>The optional <code>GroupRole</code> for this membership.</p>"},{"location":"reference/models/#wom.models.Membership.updated_at","title":"updated_at  <code>instance-attribute</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>The date this membership was updated.</p>"},{"location":"reference/models/#wom.models.MetricLeader","title":"MetricLeader","text":"<p>             Bases: <code>BaseModel</code></p> <p>Base class used to derive leaders in different metrics.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class MetricLeader(BaseModel):\n    \"\"\"Base class used to derive leaders in different metrics.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The metric being measured.\"\"\"\n\n    rank: int\n    \"\"\"The players rank in the metric.\"\"\"\n\n    player: t.Optional[Player]\n    \"\"\"The player leading in this metric, or `None` if none do.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.MetricLeader.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The metric being measured.</p>"},{"location":"reference/models/#wom.models.MetricLeader.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Optional[Player]\n</code></pre> <p>The player leading in this metric, or <code>None</code> if none do.</p>"},{"location":"reference/models/#wom.models.MetricLeader.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The players rank in the metric.</p>"},{"location":"reference/models/#wom.models.MetricLeaders","title":"MetricLeaders","text":"<p>             Bases: <code>BaseModel</code></p> <p>The leaders for each metric in a group.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class MetricLeaders(BaseModel):\n    \"\"\"The leaders for each metric in a group.\"\"\"\n\n    skills: t.Dict[enums.Metric, SkillLeader]\n    \"\"\"A mapping of skill keys to [`SkillLeader`][wom.SkillLeader] values.\"\"\"\n\n    bosses: t.Dict[enums.Metric, BossLeader]\n    \"\"\"A mapping of boss keys to [`BossLeader`][wom.BossLeader] values.\"\"\"\n\n    activities: t.Dict[enums.Metric, ActivityLeader]\n    \"\"\"A mapping of activity keys to [`ActivityLeader`]\n    [wom.ActivityLeader] values.\n    \"\"\"\n\n    computed: t.Dict[enums.Metric, ComputedMetricLeader]\n    \"\"\"A mapping of computed metric keys to\n    [`ComputedMetricLeader`][wom.ComputedMetricLeader] values.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.MetricLeaders.activities","title":"activities  <code>instance-attribute</code>","text":"<pre><code>activities: Dict[Metric, ActivityLeader]\n</code></pre> <p>A mapping of activity keys to <code>ActivityLeader</code> values.</p>"},{"location":"reference/models/#wom.models.MetricLeaders.bosses","title":"bosses  <code>instance-attribute</code>","text":"<pre><code>bosses: Dict[Metric, BossLeader]\n</code></pre> <p>A mapping of boss keys to <code>BossLeader</code> values.</p>"},{"location":"reference/models/#wom.models.MetricLeaders.computed","title":"computed  <code>instance-attribute</code>","text":"<pre><code>computed: Dict[Metric, ComputedMetricLeader]\n</code></pre> <p>A mapping of computed metric keys to <code>ComputedMetricLeader</code> values.</p>"},{"location":"reference/models/#wom.models.MetricLeaders.skills","title":"skills  <code>instance-attribute</code>","text":"<pre><code>skills: Dict[Metric, SkillLeader]\n</code></pre> <p>A mapping of skill keys to <code>SkillLeader</code> values.</p>"},{"location":"reference/models/#wom.models.NameChange","title":"NameChange","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a player name change.</p> Source code in <code>wom/models/names/models.py</code> <pre><code>class NameChange(BaseModel):\n    \"\"\"Represents a player name change.\"\"\"\n\n    id: int\n    \"\"\"The unique ID of this name change.\"\"\"\n\n    player_id: int\n    \"\"\"The player ID associated with the name change.\"\"\"\n\n    old_name: str\n    \"\"\"The old username of the player.\"\"\"\n\n    new_name: str\n    \"\"\"The new username of the player.\"\"\"\n\n    status: NameChangeStatus\n    \"\"\"The [`status`][wom.NameChangeStatus] of the name change.\"\"\"\n\n    review_context: t.Optional[NameChangeReviewContext]\n    \"\"\"The [review context][wom.NameChangeReviewContext] associated with\n    this name change, if it was denied or skipped.\n    \"\"\"\n\n    resolved_at: t.Optional[datetime]\n    \"\"\"The date the name change was approved or denied.\"\"\"\n\n    updated_at: datetime\n    \"\"\"The date the name change was updated.\"\"\"\n\n    created_at: datetime\n    \"\"\"The date the name change was created.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.NameChange.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The date the name change was created.</p>"},{"location":"reference/models/#wom.models.NameChange.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique ID of this name change.</p>"},{"location":"reference/models/#wom.models.NameChange.new_name","title":"new_name  <code>instance-attribute</code>","text":"<pre><code>new_name: str\n</code></pre> <p>The new username of the player.</p>"},{"location":"reference/models/#wom.models.NameChange.old_name","title":"old_name  <code>instance-attribute</code>","text":"<pre><code>old_name: str\n</code></pre> <p>The old username of the player.</p>"},{"location":"reference/models/#wom.models.NameChange.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The player ID associated with the name change.</p>"},{"location":"reference/models/#wom.models.NameChange.resolved_at","title":"resolved_at  <code>instance-attribute</code>","text":"<pre><code>resolved_at: Optional[datetime]\n</code></pre> <p>The date the name change was approved or denied.</p>"},{"location":"reference/models/#wom.models.NameChange.review_context","title":"review_context  <code>instance-attribute</code>","text":"<pre><code>review_context: Optional[NameChangeReviewContext]\n</code></pre> <p>The review context associated with this name change, if it was denied or skipped.</p>"},{"location":"reference/models/#wom.models.NameChange.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status: NameChangeStatus\n</code></pre> <p>The <code>status</code> of the name change.</p>"},{"location":"reference/models/#wom.models.NameChange.updated_at","title":"updated_at  <code>instance-attribute</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>The date the name change was updated.</p>"},{"location":"reference/models/#wom.models.NameChangeReviewContext","title":"NameChangeReviewContext","text":"<p>             Bases: <code>BaseModel</code></p> <p>The review context for a name change that was not approved.</p> Source code in <code>wom/models/names/models.py</code> <pre><code>class NameChangeReviewContext(BaseModel):\n    \"\"\"The review context for a name change that was not approved.\"\"\"\n\n    reason: NameChangeReviewReason\n    \"\"\"The reason this name change was denied.\"\"\"\n\n    # TODO: Setting everything to None here is painful.\n    # Determine with Ruben whether we want to keep this\n    # public on the name change endpoints and if we do\n    # determine how to handle it in a cleaner way.\n\n    negative_gains: t.Optional[t.Dict[enums.Metric, int]] = None\n    \"\"\"The negative gains that were observed, if there were any. Only populated\n    when the reason is `NegativeGains`.\n    \"\"\"\n\n    max_hours_diff: t.Optional[int] = None\n    \"\"\"The max number of hours in the transition period. Only populated when\n    reason is `TransitionTooLong`.\n    \"\"\"\n\n    hours_diff: t.Optional[int] = None\n    \"\"\"The actual number of hours in the transition period. Only populated when\n    reason is `TransitionTooLong` or `ExcessiveGains`.\n    \"\"\"\n\n    ehp_diff: t.Optional[int] = None\n    \"\"\"The number difference between the old and new names ehp. Only populated\n    when the reason is `ExcessiveGains`.\n    \"\"\"\n\n    ehb_diff: t.Optional[int] = None\n    \"\"\"The number difference between the old and new names ehb. Only populated\n    when the reason is `ExcessiveGains`.\n    \"\"\"\n\n    min_total_level: t.Optional[int] = None\n    \"\"\"The minimum total level allowed for this name change. Only populated\n    when the reason is `TotalLevelTooLow`.\n    \"\"\"\n\n    total_level: t.Optional[int] = None\n    \"\"\"The number difference between the old and new names ehb. Only populated\n    when the reason is `TotalLevelTooLow`.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.NameChangeReviewContext.ehb_diff","title":"ehb_diff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ehb_diff: Optional[int] = None\n</code></pre> <p>The number difference between the old and new names ehb. Only populated when the reason is <code>ExcessiveGains</code>.</p>"},{"location":"reference/models/#wom.models.NameChangeReviewContext.ehp_diff","title":"ehp_diff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ehp_diff: Optional[int] = None\n</code></pre> <p>The number difference between the old and new names ehp. Only populated when the reason is <code>ExcessiveGains</code>.</p>"},{"location":"reference/models/#wom.models.NameChangeReviewContext.hours_diff","title":"hours_diff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hours_diff: Optional[int] = None\n</code></pre> <p>The actual number of hours in the transition period. Only populated when reason is <code>TransitionTooLong</code> or <code>ExcessiveGains</code>.</p>"},{"location":"reference/models/#wom.models.NameChangeReviewContext.max_hours_diff","title":"max_hours_diff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_hours_diff: Optional[int] = None\n</code></pre> <p>The max number of hours in the transition period. Only populated when reason is <code>TransitionTooLong</code>.</p>"},{"location":"reference/models/#wom.models.NameChangeReviewContext.min_total_level","title":"min_total_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_total_level: Optional[int] = None\n</code></pre> <p>The minimum total level allowed for this name change. Only populated when the reason is <code>TotalLevelTooLow</code>.</p>"},{"location":"reference/models/#wom.models.NameChangeReviewContext.negative_gains","title":"negative_gains  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>negative_gains: Optional[Dict[Metric, int]] = None\n</code></pre> <p>The negative gains that were observed, if there were any. Only populated when the reason is <code>NegativeGains</code>.</p>"},{"location":"reference/models/#wom.models.NameChangeReviewContext.reason","title":"reason  <code>instance-attribute</code>","text":"<pre><code>reason: NameChangeReviewReason\n</code></pre> <p>The reason this name change was denied.</p>"},{"location":"reference/models/#wom.models.NameChangeReviewContext.total_level","title":"total_level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_level: Optional[int] = None\n</code></pre> <p>The number difference between the old and new names ehb. Only populated when the reason is <code>TotalLevelTooLow</code>.</p>"},{"location":"reference/models/#wom.models.NameChangeStatus","title":"NameChangeStatus","text":"<p>             Bases: <code>BaseEnum</code></p> <p>The available name change statuses.</p> Source code in <code>wom/models/names/enums.py</code> <pre><code>class NameChangeStatus(BaseEnum):\n    \"\"\"The available name change statuses.\"\"\"\n\n    Pending = \"pending\"\n    Approved = \"approved\"\n    Denied = \"denied\"\n</code></pre>"},{"location":"reference/models/#wom.models.Participation","title":"Participation","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents participation in a competition.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class Participation(BaseModel):\n    \"\"\"Represents participation in a competition.\"\"\"\n\n    player_id: int\n    \"\"\"The ID of the player associated with this participation.\"\"\"\n\n    competition_id: int\n    \"\"\"The ID of the competition associated with this participation.\"\"\"\n\n    team_name: t.Optional[str]\n    \"\"\"The optional team name associated with this participation.\"\"\"\n\n    created_at: datetime\n    \"\"\"The date this participation was created.\"\"\"\n\n    updated_at: datetime\n    \"\"\"The date this participation was updated.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Participation.competition_id","title":"competition_id  <code>instance-attribute</code>","text":"<pre><code>competition_id: int\n</code></pre> <p>The ID of the competition associated with this participation.</p>"},{"location":"reference/models/#wom.models.Participation.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The date this participation was created.</p>"},{"location":"reference/models/#wom.models.Participation.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The ID of the player associated with this participation.</p>"},{"location":"reference/models/#wom.models.Participation.team_name","title":"team_name  <code>instance-attribute</code>","text":"<pre><code>team_name: Optional[str]\n</code></pre> <p>The optional team name associated with this participation.</p>"},{"location":"reference/models/#wom.models.Participation.updated_at","title":"updated_at  <code>instance-attribute</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>The date this participation was updated.</p>"},{"location":"reference/models/#wom.models.Player","title":"Player","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a player on WOM.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class Player(BaseModel):\n    \"\"\"Represents a player on WOM.\"\"\"\n\n    id: int\n    \"\"\"The players unique ID.\"\"\"\n\n    username: str\n    \"\"\"The players username, always lowercase and 1-12 chars.\"\"\"\n\n    display_name: str\n    \"\"\"The players display name, supports capitalization .\"\"\"\n\n    type: PlayerType\n    \"\"\"The [`PlayerType`][wom.PlayerType] for this player.\"\"\"\n\n    build: PlayerBuild\n    \"\"\"The [`PlayerBuild`][wom.PlayerBuild] for this player.\"\"\"\n\n    country: t.Optional[Country]\n    \"\"\"The players [`Country`][wom.Country] country of origin, if they\n    have one set.\n    \"\"\"\n\n    status: PlayerStatus\n    \"\"\"The players status, i.e. flagged, archived, etc.\"\"\"\n\n    exp: int\n    \"\"\"The players overall experience.\"\"\"\n\n    ehp: float\n    \"\"\"The players efficient hours played.\"\"\"\n\n    ehb: float\n    \"\"\"The players efficient hours bossed.\"\"\"\n\n    ttm: float\n    \"\"\"The players time to max, in hours.\"\"\"\n\n    tt200m: float\n    \"\"\"The players time to 200m xp all skills, in hours.\"\"\"\n\n    registered_at: datetime\n    \"\"\"The date the player was registered with WOM.\"\"\"\n\n    updated_at: t.Optional[datetime]\n    \"\"\"The date the player was last successfully updated with WOM.\"\"\"\n\n    last_changed_at: t.Optional[datetime]\n    \"\"\"The date of the players last change (xp gain, boss kc, etc).\"\"\"\n\n    last_imported_at: t.Optional[datetime]\n    \"\"\"The date of the last player history import.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Player.build","title":"build  <code>instance-attribute</code>","text":"<pre><code>build: PlayerBuild\n</code></pre> <p>The <code>PlayerBuild</code> for this player.</p>"},{"location":"reference/models/#wom.models.Player.country","title":"country  <code>instance-attribute</code>","text":"<pre><code>country: Optional[Country]\n</code></pre> <p>The players <code>Country</code> country of origin, if they have one set.</p>"},{"location":"reference/models/#wom.models.Player.display_name","title":"display_name  <code>instance-attribute</code>","text":"<pre><code>display_name: str\n</code></pre> <p>The players display name, supports capitalization .</p>"},{"location":"reference/models/#wom.models.Player.ehb","title":"ehb  <code>instance-attribute</code>","text":"<pre><code>ehb: float\n</code></pre> <p>The players efficient hours bossed.</p>"},{"location":"reference/models/#wom.models.Player.ehp","title":"ehp  <code>instance-attribute</code>","text":"<pre><code>ehp: float\n</code></pre> <p>The players efficient hours played.</p>"},{"location":"reference/models/#wom.models.Player.exp","title":"exp  <code>instance-attribute</code>","text":"<pre><code>exp: int\n</code></pre> <p>The players overall experience.</p>"},{"location":"reference/models/#wom.models.Player.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The players unique ID.</p>"},{"location":"reference/models/#wom.models.Player.last_changed_at","title":"last_changed_at  <code>instance-attribute</code>","text":"<pre><code>last_changed_at: Optional[datetime]\n</code></pre> <p>The date of the players last change (xp gain, boss kc, etc).</p>"},{"location":"reference/models/#wom.models.Player.last_imported_at","title":"last_imported_at  <code>instance-attribute</code>","text":"<pre><code>last_imported_at: Optional[datetime]\n</code></pre> <p>The date of the last player history import.</p>"},{"location":"reference/models/#wom.models.Player.registered_at","title":"registered_at  <code>instance-attribute</code>","text":"<pre><code>registered_at: datetime\n</code></pre> <p>The date the player was registered with WOM.</p>"},{"location":"reference/models/#wom.models.Player.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status: PlayerStatus\n</code></pre> <p>The players status, i.e. flagged, archived, etc.</p>"},{"location":"reference/models/#wom.models.Player.tt200m","title":"tt200m  <code>instance-attribute</code>","text":"<pre><code>tt200m: float\n</code></pre> <p>The players time to 200m xp all skills, in hours.</p>"},{"location":"reference/models/#wom.models.Player.ttm","title":"ttm  <code>instance-attribute</code>","text":"<pre><code>ttm: float\n</code></pre> <p>The players time to max, in hours.</p>"},{"location":"reference/models/#wom.models.Player.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: PlayerType\n</code></pre> <p>The <code>PlayerType</code> for this player.</p>"},{"location":"reference/models/#wom.models.Player.updated_at","title":"updated_at  <code>instance-attribute</code>","text":"<pre><code>updated_at: Optional[datetime]\n</code></pre> <p>The date the player was last successfully updated with WOM.</p>"},{"location":"reference/models/#wom.models.Player.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>The players username, always lowercase and 1-12 chars.</p>"},{"location":"reference/models/#wom.models.PlayerAchievementProgress","title":"PlayerAchievementProgress","text":"<p>             Bases: <code>AchievementProgress</code></p> <p>Represents a players progress toward an achievement.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class PlayerAchievementProgress(AchievementProgress):\n    \"\"\"Represents a players progress toward an achievement.\"\"\"\n\n    current_value: int\n    \"\"\"The current value for the achievement's metric.\"\"\"\n\n    absolute_progress: float\n    \"\"\"The players current absolute progress toward the achievement.\n\n    Scale of 0-1 with 1 being 100% progress.\n    \"\"\"\n\n    relative_progress: float\n    \"\"\"The players current relative progress toward the achievement\n    starting from the previous achievement.\n\n    Scale of 0-1 with 1 being 100% progress.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerAchievementProgress.absolute_progress","title":"absolute_progress  <code>instance-attribute</code>","text":"<pre><code>absolute_progress: float\n</code></pre> <p>The players current absolute progress toward the achievement.</p> <p>Scale of 0-1 with 1 being 100% progress.</p>"},{"location":"reference/models/#wom.models.PlayerAchievementProgress.current_value","title":"current_value  <code>instance-attribute</code>","text":"<pre><code>current_value: int\n</code></pre> <p>The current value for the achievement's metric.</p>"},{"location":"reference/models/#wom.models.PlayerAchievementProgress.relative_progress","title":"relative_progress  <code>instance-attribute</code>","text":"<pre><code>relative_progress: float\n</code></pre> <p>The players current relative progress toward the achievement starting from the previous achievement.</p> <p>Scale of 0-1 with 1 being 100% progress.</p>"},{"location":"reference/models/#wom.models.PlayerArchive","title":"PlayerArchive","text":"<p>             Bases: <code>Archive</code></p> <p>Information detailing a player that has been archived, including the <code>Player</code> object.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class PlayerArchive(Archive):\n    \"\"\"Information detailing a player that has been archived, including the\n    [`Player`][wom.Player] object.\"\"\"\n\n    player: Player\n    \"\"\"The player information.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerArchive.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The player information.</p>"},{"location":"reference/models/#wom.models.PlayerBuild","title":"PlayerBuild","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Potential account builds.</p> Source code in <code>wom/models/players/enums.py</code> <pre><code>class PlayerBuild(BaseEnum):\n    \"\"\"Potential account builds.\"\"\"\n\n    Main = \"main\"\n    F2p = \"f2p\"\n    Lvl3 = \"lvl3\"\n    Zerker = \"zerker\"\n    Def1 = \"def1\"\n    Hp10 = \"hp10\"\n    F2pLvl3 = \"f2p_lvl3\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerCompetitionStanding","title":"PlayerCompetitionStanding","text":"<p>             Bases: <code>PlayerParticipation</code></p> <p>Represents a players standing in a competition.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class PlayerCompetitionStanding(PlayerParticipation):\n    \"\"\"Represents a players standing in a competition.\"\"\"\n\n    progress: CompetitionProgress\n    \"\"\"The [`CompetitionProgress`][wom.CompetitionProgress] that was\n    made.\n    \"\"\"\n\n    levels: CompetitionProgress\n    \"\"\"The [`CompetitionProgress`][wom.CompetitionProgress] that was\n    made. Only contains useful information for skilling competitions.\n    \"\"\"\n\n    rank: int\n    \"\"\"The rank in the competition standings.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerCompetitionStanding.levels","title":"levels  <code>instance-attribute</code>","text":"<pre><code>levels: CompetitionProgress\n</code></pre> <p>The <code>CompetitionProgress</code> that was made. Only contains useful information for skilling competitions.</p>"},{"location":"reference/models/#wom.models.PlayerCompetitionStanding.progress","title":"progress  <code>instance-attribute</code>","text":"<pre><code>progress: CompetitionProgress\n</code></pre> <p>The <code>CompetitionProgress</code> that was made.</p>"},{"location":"reference/models/#wom.models.PlayerCompetitionStanding.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The rank in the competition standings.</p>"},{"location":"reference/models/#wom.models.PlayerDetail","title":"PlayerDetail","text":"<p>             Bases: <code>Player</code></p> <p>Represents details about a player.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class PlayerDetail(Player):\n    \"\"\"Represents details about a player.\"\"\"\n\n    combat_level: int\n    \"\"\"The players combat level.\"\"\"\n\n    latest_snapshot: t.Optional[Snapshot]\n    \"\"\"The latest snapshot for the player, if there is one.\"\"\"\n\n    archive: t.Optional[Archive] = None\n    \"\"\"The players archive information, if any.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerDetail.archive","title":"archive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>archive: Optional[Archive] = None\n</code></pre> <p>The players archive information, if any.</p>"},{"location":"reference/models/#wom.models.PlayerDetail.combat_level","title":"combat_level  <code>instance-attribute</code>","text":"<pre><code>combat_level: int\n</code></pre> <p>The players combat level.</p>"},{"location":"reference/models/#wom.models.PlayerDetail.latest_snapshot","title":"latest_snapshot  <code>instance-attribute</code>","text":"<pre><code>latest_snapshot: Optional[Snapshot]\n</code></pre> <p>The latest snapshot for the player, if there is one.</p>"},{"location":"reference/models/#wom.models.PlayerGains","title":"PlayerGains","text":"<p>             Bases: <code>BaseModel</code></p> <p>Gains made by a player.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class PlayerGains(BaseModel):\n    \"\"\"Gains made by a player.\"\"\"\n\n    starts_at: datetime\n    \"\"\"The date the gains started at.\"\"\"\n\n    ends_at: datetime\n    \"\"\"The date the gains ended at.\"\"\"\n\n    data: PlayerGainsData\n    \"\"\"The [`PlayerGainsData`][wom.PlayerGainsData] for the player.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerGains.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: PlayerGainsData\n</code></pre> <p>The <code>PlayerGainsData</code> for the player.</p>"},{"location":"reference/models/#wom.models.PlayerGains.ends_at","title":"ends_at  <code>instance-attribute</code>","text":"<pre><code>ends_at: datetime\n</code></pre> <p>The date the gains ended at.</p>"},{"location":"reference/models/#wom.models.PlayerGains.starts_at","title":"starts_at  <code>instance-attribute</code>","text":"<pre><code>starts_at: datetime\n</code></pre> <p>The date the gains started at.</p>"},{"location":"reference/models/#wom.models.PlayerGainsData","title":"PlayerGainsData","text":"<p>             Bases: <code>BaseModel</code></p> <p>Contains all the player gains data.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class PlayerGainsData(BaseModel):\n    \"\"\"Contains all the player gains data.\"\"\"\n\n    skills: t.Dict[enums.Metric, SkillGains]\n    \"\"\"A mapping of skill keys to [`SkillGains`] [wom.SkillGains] values.\"\"\"\n\n    bosses: t.Dict[enums.Metric, BossGains]\n    \"\"\"A mapping of boss keys to [`BossGains`][wom.BossGains] values.\"\"\"\n\n    activities: t.Dict[enums.Metric, ActivityGains]\n    \"\"\"A mapping of activity keys to [`ActivityGains`][wom.ActivityGains]\n    values.\n    \"\"\"\n\n    computed: t.Dict[enums.Metric, ComputedGains]\n    \"\"\"A mapping of computed metric keys to [`ComputedGains`]\n    [wom.ComputedGains] values.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerGainsData.activities","title":"activities  <code>instance-attribute</code>","text":"<pre><code>activities: Dict[Metric, ActivityGains]\n</code></pre> <p>A mapping of activity keys to <code>ActivityGains</code> values.</p>"},{"location":"reference/models/#wom.models.PlayerGainsData.bosses","title":"bosses  <code>instance-attribute</code>","text":"<pre><code>bosses: Dict[Metric, BossGains]\n</code></pre> <p>A mapping of boss keys to <code>BossGains</code> values.</p>"},{"location":"reference/models/#wom.models.PlayerGainsData.computed","title":"computed  <code>instance-attribute</code>","text":"<pre><code>computed: Dict[Metric, ComputedGains]\n</code></pre> <p>A mapping of computed metric keys to <code>ComputedGains</code> values.</p>"},{"location":"reference/models/#wom.models.PlayerGainsData.skills","title":"skills  <code>instance-attribute</code>","text":"<pre><code>skills: Dict[Metric, SkillGains]\n</code></pre> <p>A mapping of skill keys to <code>SkillGains</code> values.</p>"},{"location":"reference/models/#wom.models.PlayerMembership","title":"PlayerMembership","text":"<p>             Bases: <code>Membership</code></p> <p>Represents a player membership.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class PlayerMembership(Membership):\n    \"\"\"Represents a player membership.\"\"\"\n\n    group: Group\n    \"\"\"The [`Group`][wom.Group] the player is a member of.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerMembership.group","title":"group  <code>instance-attribute</code>","text":"<pre><code>group: Group\n</code></pre> <p>The <code>Group</code> the player is a member of.</p>"},{"location":"reference/models/#wom.models.PlayerParticipation","title":"PlayerParticipation","text":"<p>             Bases: <code>Participation</code></p> <p>Represents a players participation in a competition.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class PlayerParticipation(Participation):\n    \"\"\"Represents a players participation in a competition.\"\"\"\n\n    competition: Competition\n    \"\"\"The [`Competition`][wom.Competition] that the player participated\n    in.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerParticipation.competition","title":"competition  <code>instance-attribute</code>","text":"<pre><code>competition: Competition\n</code></pre> <p>The <code>Competition</code> that the player participated in.</p>"},{"location":"reference/models/#wom.models.PlayerStatus","title":"PlayerStatus","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Status for the players account.</p> Source code in <code>wom/models/players/enums.py</code> <pre><code>class PlayerStatus(BaseEnum):\n    \"\"\"Status for the players account.\"\"\"\n\n    Active = \"active\"\n    Unranked = \"unranked\"\n    Flagged = \"flagged\"\n    Archived = \"archived\"\n    Banned = \"banned\"\n</code></pre>"},{"location":"reference/models/#wom.models.PlayerType","title":"PlayerType","text":"<p>             Bases: <code>BaseEnum</code></p> <p>Different types of players.</p> Source code in <code>wom/models/players/enums.py</code> <pre><code>class PlayerType(BaseEnum):\n    \"\"\"Different types of players.\"\"\"\n\n    Unknown = \"unknown\"\n    Regular = \"regular\"\n    Ironman = \"ironman\"\n    Hardcore = \"hardcore\"\n    Ultimate = \"ultimate\"\n    FreshStart = \"fresh_start\"\n</code></pre>"},{"location":"reference/models/#wom.models.Record","title":"Record","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a record held by a player.</p> Source code in <code>wom/models/records/models.py</code> <pre><code>class Record(BaseModel):\n    \"\"\"Represents a record held by a player.\"\"\"\n\n    id: int\n    \"\"\"The unique ID for this record.\"\"\"\n\n    player_id: int\n    \"\"\"The player ID associated with this record.\"\"\"\n\n    period: enums.Period\n    \"\"\"The [`Period`][wom.Period] over which this record was achieved.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The [`Metric`][wom.Metric] measured in this record.\"\"\"\n\n    value: float\n    \"\"\"The records gained value.\"\"\"\n\n    updated_at: datetime\n    \"\"\"The records creation/modification date.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Record.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique ID for this record.</p>"},{"location":"reference/models/#wom.models.Record.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The <code>Metric</code> measured in this record.</p>"},{"location":"reference/models/#wom.models.Record.period","title":"period  <code>instance-attribute</code>","text":"<pre><code>period: Period\n</code></pre> <p>The <code>Period</code> over which this record was achieved.</p>"},{"location":"reference/models/#wom.models.Record.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The player ID associated with this record.</p>"},{"location":"reference/models/#wom.models.Record.updated_at","title":"updated_at  <code>instance-attribute</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>The records creation/modification date.</p>"},{"location":"reference/models/#wom.models.Record.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: float\n</code></pre> <p>The records gained value.</p>"},{"location":"reference/models/#wom.models.RecordLeaderboardEntry","title":"RecordLeaderboardEntry","text":"<p>             Bases: <code>Record</code></p> <p>Represents a player's record leaderboard entry.</p> Source code in <code>wom/models/records/models.py</code> <pre><code>class RecordLeaderboardEntry(Record):\n    \"\"\"Represents a player's record leaderboard entry.\"\"\"\n\n    player: Player\n    \"\"\"The [`Player`][wom.Player] holding this leaderboard entry.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.RecordLeaderboardEntry.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The <code>Player</code> holding this leaderboard entry.</p>"},{"location":"reference/models/#wom.models.Skill","title":"Skill","text":"<p>             Bases: <code>BaseModel</code></p> <p>Details regarding a particular skill.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class Skill(BaseModel):\n    \"\"\"Details regarding a particular skill.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The skill being measured.\"\"\"\n\n    rank: int\n    \"\"\"The players rank in the skill.\"\"\"\n\n    level: int\n    \"\"\"The players level in the skill.\"\"\"\n\n    experience: int\n    \"\"\"The players experience in the skill.\"\"\"\n\n    ehp: float\n    \"\"\"The players efficient hours played for the skill.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Skill.ehp","title":"ehp  <code>instance-attribute</code>","text":"<pre><code>ehp: float\n</code></pre> <p>The players efficient hours played for the skill.</p>"},{"location":"reference/models/#wom.models.Skill.experience","title":"experience  <code>instance-attribute</code>","text":"<pre><code>experience: int\n</code></pre> <p>The players experience in the skill.</p>"},{"location":"reference/models/#wom.models.Skill.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level: int\n</code></pre> <p>The players level in the skill.</p>"},{"location":"reference/models/#wom.models.Skill.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The skill being measured.</p>"},{"location":"reference/models/#wom.models.Skill.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The players rank in the skill.</p>"},{"location":"reference/models/#wom.models.SkillGains","title":"SkillGains","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents skill gains made by a player.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class SkillGains(BaseModel):\n    \"\"\"Represents skill gains made by a player.\"\"\"\n\n    metric: enums.Metric\n    \"\"\"The skill being measured.\"\"\"\n\n    experience: Gains\n    \"\"\"The experience [`Gains`][wom.Gains].\"\"\"\n\n    ehp: Gains\n    \"\"\"The efficient hours played [`Gains`][wom.Gains].\"\"\"\n\n    rank: Gains\n    \"\"\"The rank [`Gains`][wom.Gains].\"\"\"\n\n    level: Gains\n    \"\"\"The level [`Gains`][wom.Gains].\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.SkillGains.ehp","title":"ehp  <code>instance-attribute</code>","text":"<pre><code>ehp: Gains\n</code></pre> <p>The efficient hours played <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.SkillGains.experience","title":"experience  <code>instance-attribute</code>","text":"<pre><code>experience: Gains\n</code></pre> <p>The experience <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.SkillGains.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level: Gains\n</code></pre> <p>The level <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.SkillGains.metric","title":"metric  <code>instance-attribute</code>","text":"<pre><code>metric: Metric\n</code></pre> <p>The skill being measured.</p>"},{"location":"reference/models/#wom.models.SkillGains.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: Gains\n</code></pre> <p>The rank <code>Gains</code>.</p>"},{"location":"reference/models/#wom.models.SkillLeader","title":"SkillLeader","text":"<p>             Bases: <code>MetricLeader</code></p> <p>Represents a leader in a particular skill.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class SkillLeader(MetricLeader):\n    \"\"\"Represents a leader in a particular skill.\"\"\"\n\n    level: int\n    \"\"\"The players level in the skill.\"\"\"\n\n    experience: int\n    \"\"\"The players experience in the skill.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.SkillLeader.experience","title":"experience  <code>instance-attribute</code>","text":"<pre><code>experience: int\n</code></pre> <p>The players experience in the skill.</p>"},{"location":"reference/models/#wom.models.SkillLeader.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level: int\n</code></pre> <p>The players level in the skill.</p>"},{"location":"reference/models/#wom.models.Snapshot","title":"Snapshot","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a player snapshot.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class Snapshot(BaseModel):\n    \"\"\"Represents a player snapshot.\"\"\"\n\n    id: int\n    \"\"\"The unique ID of the snapshot.\"\"\"\n\n    player_id: int\n    \"\"\"The unique ID of the player for this snapshot.\"\"\"\n\n    imported_at: t.Optional[datetime]\n    \"\"\"The date the snapshot was imported, if it was.\"\"\"\n\n    data: SnapshotData\n    \"\"\"The [`SnapshotData`][wom.SnapshotData] for the snapshot.\"\"\"\n\n    created_at: datetime\n    \"\"\"The date the snapshot was created.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Snapshot.created_at","title":"created_at  <code>instance-attribute</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>The date the snapshot was created.</p>"},{"location":"reference/models/#wom.models.Snapshot.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: SnapshotData\n</code></pre> <p>The <code>SnapshotData</code> for the snapshot.</p>"},{"location":"reference/models/#wom.models.Snapshot.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>The unique ID of the snapshot.</p>"},{"location":"reference/models/#wom.models.Snapshot.imported_at","title":"imported_at  <code>instance-attribute</code>","text":"<pre><code>imported_at: Optional[datetime]\n</code></pre> <p>The date the snapshot was imported, if it was.</p>"},{"location":"reference/models/#wom.models.Snapshot.player_id","title":"player_id  <code>instance-attribute</code>","text":"<pre><code>player_id: int\n</code></pre> <p>The unique ID of the player for this snapshot.</p>"},{"location":"reference/models/#wom.models.SnapshotData","title":"SnapshotData","text":"<p>             Bases: <code>BaseModel</code></p> <p>The data associated with this snapshot.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class SnapshotData(BaseModel):\n    \"\"\"The data associated with this snapshot.\"\"\"\n\n    skills: t.Dict[enums.Metric, Skill]\n    \"\"\"A mapping of skill keys to skill values from this snapshot.\"\"\"\n\n    bosses: t.Dict[enums.Metric, Boss]\n    \"\"\"A mapping of boss keys to boss values from this snapshot.\"\"\"\n\n    activities: t.Dict[enums.Metric, Activity]\n    \"\"\"A mapping of activity keys to activity values from this snapshot.\"\"\"\n\n    computed: t.Dict[enums.Metric, ComputedMetric]\n    \"\"\"A mapping of computed metric keys to computed metric values from\n    this snapshot.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.SnapshotData.activities","title":"activities  <code>instance-attribute</code>","text":"<pre><code>activities: Dict[Metric, Activity]\n</code></pre> <p>A mapping of activity keys to activity values from this snapshot.</p>"},{"location":"reference/models/#wom.models.SnapshotData.bosses","title":"bosses  <code>instance-attribute</code>","text":"<pre><code>bosses: Dict[Metric, Boss]\n</code></pre> <p>A mapping of boss keys to boss values from this snapshot.</p>"},{"location":"reference/models/#wom.models.SnapshotData.computed","title":"computed  <code>instance-attribute</code>","text":"<pre><code>computed: Dict[Metric, ComputedMetric]\n</code></pre> <p>A mapping of computed metric keys to computed metric values from this snapshot.</p>"},{"location":"reference/models/#wom.models.SnapshotData.skills","title":"skills  <code>instance-attribute</code>","text":"<pre><code>skills: Dict[Metric, Skill]\n</code></pre> <p>A mapping of skill keys to skill values from this snapshot.</p>"},{"location":"reference/models/#wom.models.SnapshotTimelineEntry","title":"SnapshotTimelineEntry","text":"<p>             Bases: <code>BaseModel</code></p> <p>An entry representing a point in time of a players gains.</p> Source code in <code>wom/models/players/models.py</code> <pre><code>class SnapshotTimelineEntry(BaseModel):\n    \"\"\"An entry representing a point in time of a players gains.\"\"\"\n\n    value: int\n    \"\"\"The players value for a specific metric, at a specific point in\n    time.\"\"\"\n\n    rank: int\n    \"\"\"The players rank for a specific metric, at a specific point in\n    time.\"\"\"\n\n    date: datetime\n    \"\"\"The date this timeline entry was recorded.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.SnapshotTimelineEntry.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: datetime\n</code></pre> <p>The date this timeline entry was recorded.</p>"},{"location":"reference/models/#wom.models.SnapshotTimelineEntry.rank","title":"rank  <code>instance-attribute</code>","text":"<pre><code>rank: int\n</code></pre> <p>The players rank for a specific metric, at a specific point in time.</p>"},{"location":"reference/models/#wom.models.SnapshotTimelineEntry.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: int\n</code></pre> <p>The players value for a specific metric, at a specific point in time.</p>"},{"location":"reference/models/#wom.models.SocialLinks","title":"SocialLinks","text":"<p>             Bases: <code>BaseModel</code></p> <p>A groups social links.</p> Source code in <code>wom/models/groups/models.py</code> <pre><code>class SocialLinks(BaseModel):\n    \"\"\"A groups social links.\"\"\"\n\n    website: t.Optional[str] = None\n    \"\"\"The groups website url.\"\"\"\n\n    discord: t.Optional[str] = None\n    \"\"\"The groups discord invite url.\"\"\"\n\n    twitter: t.Optional[str] = None\n    \"\"\"The groups twitter url.\"\"\"\n\n    youtube: t.Optional[str] = None\n    \"\"\"The groups youtube url.\"\"\"\n\n    twitch: t.Optional[str] = None\n    \"\"\"The groups twitch url.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.SocialLinks.discord","title":"discord  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>discord: Optional[str] = None\n</code></pre> <p>The groups discord invite url.</p>"},{"location":"reference/models/#wom.models.SocialLinks.twitch","title":"twitch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>twitch: Optional[str] = None\n</code></pre> <p>The groups twitch url.</p>"},{"location":"reference/models/#wom.models.SocialLinks.twitter","title":"twitter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>twitter: Optional[str] = None\n</code></pre> <p>The groups twitter url.</p>"},{"location":"reference/models/#wom.models.SocialLinks.website","title":"website  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>website: Optional[str] = None\n</code></pre> <p>The groups website url.</p>"},{"location":"reference/models/#wom.models.SocialLinks.youtube","title":"youtube  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>youtube: Optional[str] = None\n</code></pre> <p>The groups youtube url.</p>"},{"location":"reference/models/#wom.models.Team","title":"Team","text":"<p>             Bases: <code>BaseModel</code></p> <p>Represents a competition team.</p> <p>Tip</p> <p>This is a model class that you will create in order to send data to some endpoints.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class Team(BaseModel):\n    \"\"\"Represents a competition team.\n\n    !!! tip\n\n        This is a model class that you will create in order to send\n        data to some endpoints.\n    \"\"\"\n\n    name: str\n    \"\"\"The name of the team.\"\"\"\n\n    participants: t.List[str]\n    \"\"\"A list of participant usernames on the team.\"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Team.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the team.</p>"},{"location":"reference/models/#wom.models.Team.participants","title":"participants  <code>instance-attribute</code>","text":"<pre><code>participants: List[str]\n</code></pre> <p>A list of participant usernames on the team.</p>"},{"location":"reference/models/#wom.models.Top5ProgressResult","title":"Top5ProgressResult","text":"<p>             Bases: <code>BaseModel</code></p> <p>A top 5 progress result for a competition.</p> Source code in <code>wom/models/competitions/models.py</code> <pre><code>class Top5ProgressResult(BaseModel):\n    \"\"\"A top 5 progress result for a competition.\"\"\"\n\n    player: Player\n    \"\"\"The [`Player`][wom.Player] who made top 5 progress.\"\"\"\n\n    history: t.List[CompetitionHistoryDataPoint]\n    \"\"\"A list of [CompetitionHistoryDataPoints]\n    [wom.CompetitionHistoryDataPoint] making up the history\n    of this top 5 progress result.\n    \"\"\"\n</code></pre>"},{"location":"reference/models/#wom.models.Top5ProgressResult.history","title":"history  <code>instance-attribute</code>","text":"<pre><code>history: List[CompetitionHistoryDataPoint]\n</code></pre> <p>A list of CompetitionHistoryDataPoints making up the history of this top 5 progress result.</p>"},{"location":"reference/models/#wom.models.Top5ProgressResult.player","title":"player  <code>instance-attribute</code>","text":"<pre><code>player: Player\n</code></pre> <p>The <code>Player</code> who made top 5 progress.</p>"},{"location":"reference/result/","title":"result","text":"<p>This module contains the <code>Result</code> variants returned by all <code>Client</code> calls.</p> <p>Correct usage</p> <pre><code>client = wom.Client()\n\nawait client.start()\n\nresult = await client.players.update_player(\"Jonxslays\")\n\nif result.is_ok:\n    print(result.unwrap())\nelse:\n    print(result.unwrap_err())\n</code></pre> <p>Incorrect usage</p> <pre><code>client = wom.Client()\n\nawait client.start()\n\nresult = await client.players.update_player(\"eeeeeeeeeeeee\")\n\nprint(result.unwrap()) # &lt;-- Exception raised\n# Raises UnwrapError because the username was too long\n</code></pre>"},{"location":"reference/result/#wom.result.Err","title":"Err","text":"<p>             Bases: <code>Result[T, E]</code></p> <p>The <code>Err</code> variant of a <code>Result</code>.</p> <p>Info</p> <p>You will receive instances of this class as a result of calling <code>Client</code> methods, and should not have to instantiate it yourself.</p> Source code in <code>wom/result.py</code> <pre><code>@t.final\nclass Err(Result[T, E]):\n    \"\"\"The [`Err`][wom.Err] variant of a [`Result`][wom.Result].\n\n    !!! info\n\n        You will receive instances of this class as a result of\n        calling [`Client`][wom.Client] methods, and should not have to\n        instantiate it yourself.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, error: E) -&gt; None:\n        self._error = error\n\n    @property\n    def is_ok(self) -&gt; bool:\n        \"\"\"Always returns `False` for the [`Err`][wom.Err] variant.\"\"\"\n        return False\n\n    @property\n    def is_err(self) -&gt; bool:\n        \"\"\"Always returns `True` for the [`Err`][wom.Err] variant.\"\"\"\n        return True\n\n    def unwrap(self) -&gt; T:\n        \"\"\"Always throws an exception for the [`Err`][wom.Err] variant.\n\n        Raises:\n            UnwrapError: Because the result was an [`Err`][wom.Err]\n                variant.\n        \"\"\"\n        raise errors.UnwrapError(f\"Called unwrap on an error value - {self._error}\")\n\n    def unwrap_err(self) -&gt; E:\n        \"\"\"Unwraps the result to produce the error.\n\n        Returns:\n            The unwrapped error.\n        \"\"\"\n        return self._error\n\n    def to_dict(self) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Converts the result into a dictionary.\n\n        Returns:\n            The requested dictionary.\n        \"\"\"\n        error = msgspec.to_builtins(self._error)\n        return {\"value\": None, \"error\": error}\n</code></pre>"},{"location":"reference/result/#wom.result.Err.is_err","title":"is_err  <code>property</code>","text":"<pre><code>is_err: bool\n</code></pre> <p>Always returns <code>True</code> for the <code>Err</code> variant.</p>"},{"location":"reference/result/#wom.result.Err.is_ok","title":"is_ok  <code>property</code>","text":"<pre><code>is_ok: bool\n</code></pre> <p>Always returns <code>False</code> for the <code>Err</code> variant.</p>"},{"location":"reference/result/#wom.result.Err.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; t.Dict[str, t.Any]\n</code></pre> <p>Converts the result into a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The requested dictionary.</p> Source code in <code>wom/result.py</code> <pre><code>def to_dict(self) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Converts the result into a dictionary.\n\n    Returns:\n        The requested dictionary.\n    \"\"\"\n    error = msgspec.to_builtins(self._error)\n    return {\"value\": None, \"error\": error}\n</code></pre>"},{"location":"reference/result/#wom.result.Err.unwrap","title":"unwrap","text":"<pre><code>unwrap() -&gt; T\n</code></pre> <p>Always throws an exception for the <code>Err</code> variant.</p> <p>Raises:</p> Type Description <code>UnwrapError</code> <p>Because the result was an <code>Err</code> variant.</p> Source code in <code>wom/result.py</code> <pre><code>def unwrap(self) -&gt; T:\n    \"\"\"Always throws an exception for the [`Err`][wom.Err] variant.\n\n    Raises:\n        UnwrapError: Because the result was an [`Err`][wom.Err]\n            variant.\n    \"\"\"\n    raise errors.UnwrapError(f\"Called unwrap on an error value - {self._error}\")\n</code></pre>"},{"location":"reference/result/#wom.result.Err.unwrap_err","title":"unwrap_err","text":"<pre><code>unwrap_err() -&gt; E\n</code></pre> <p>Unwraps the result to produce the error.</p> <p>Returns:</p> Type Description <code>E</code> <p>The unwrapped error.</p> Source code in <code>wom/result.py</code> <pre><code>def unwrap_err(self) -&gt; E:\n    \"\"\"Unwraps the result to produce the error.\n\n    Returns:\n        The unwrapped error.\n    \"\"\"\n    return self._error\n</code></pre>"},{"location":"reference/result/#wom.result.Ok","title":"Ok","text":"<p>             Bases: <code>Result[T, E]</code></p> <p>The <code>Ok</code> variant of a <code>Result</code>.</p> <p>Info</p> <p>You will receive instances of this class as a result of calling <code>Client</code> methods, and should not have to instantiate it yourself.</p> Source code in <code>wom/result.py</code> <pre><code>@t.final\nclass Ok(Result[T, E]):\n    \"\"\"The [`Ok`][wom.Ok] variant of a [`Result`][wom.Result].\n\n    !!! info\n\n        You will receive instances of this class as a result of\n        calling [`Client`][wom.Client] methods, and should not have to\n        instantiate it yourself.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, value: T) -&gt; None:\n        self._value = value\n\n    @property\n    def is_ok(self) -&gt; bool:\n        \"\"\"Always returns `True` for the [`Ok`][wom.Ok] variant.\"\"\"\n        return True\n\n    @property\n    def is_err(self) -&gt; bool:\n        \"\"\"Always returns `False` for the [`Ok`][wom.Ok] variant.\"\"\"\n        return False\n\n    def unwrap(self) -&gt; T:\n        \"\"\"Unwraps the result to produce the value.\n\n        Returns:\n            The unwrapped value.\n        \"\"\"\n        return self._value\n\n    def unwrap_err(self) -&gt; E:\n        \"\"\"Always throws an exception for the [`Ok`][wom.Ok] variant.\n\n        Raises:\n            UnwrapError: Because the result was an [`Ok`][wom.Ok]\n                variant.\n        \"\"\"\n        actual = self._value.__class__.__name__\n        raise errors.UnwrapError(f\"Called unwrap error on a non error value of type {actual!r}\")\n\n    def to_dict(self) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Converts the result into a dictionary.\n\n        Returns:\n            The requested dictionary.\n        \"\"\"\n        value = msgspec.to_builtins(self._value)\n        return {\"value\": value, \"error\": None}\n</code></pre>"},{"location":"reference/result/#wom.result.Ok.is_err","title":"is_err  <code>property</code>","text":"<pre><code>is_err: bool\n</code></pre> <p>Always returns <code>False</code> for the <code>Ok</code> variant.</p>"},{"location":"reference/result/#wom.result.Ok.is_ok","title":"is_ok  <code>property</code>","text":"<pre><code>is_ok: bool\n</code></pre> <p>Always returns <code>True</code> for the <code>Ok</code> variant.</p>"},{"location":"reference/result/#wom.result.Ok.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; t.Dict[str, t.Any]\n</code></pre> <p>Converts the result into a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The requested dictionary.</p> Source code in <code>wom/result.py</code> <pre><code>def to_dict(self) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Converts the result into a dictionary.\n\n    Returns:\n        The requested dictionary.\n    \"\"\"\n    value = msgspec.to_builtins(self._value)\n    return {\"value\": value, \"error\": None}\n</code></pre>"},{"location":"reference/result/#wom.result.Ok.unwrap","title":"unwrap","text":"<pre><code>unwrap() -&gt; T\n</code></pre> <p>Unwraps the result to produce the value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The unwrapped value.</p> Source code in <code>wom/result.py</code> <pre><code>def unwrap(self) -&gt; T:\n    \"\"\"Unwraps the result to produce the value.\n\n    Returns:\n        The unwrapped value.\n    \"\"\"\n    return self._value\n</code></pre>"},{"location":"reference/result/#wom.result.Ok.unwrap_err","title":"unwrap_err","text":"<pre><code>unwrap_err() -&gt; E\n</code></pre> <p>Always throws an exception for the <code>Ok</code> variant.</p> <p>Raises:</p> Type Description <code>UnwrapError</code> <p>Because the result was an <code>Ok</code> variant.</p> Source code in <code>wom/result.py</code> <pre><code>def unwrap_err(self) -&gt; E:\n    \"\"\"Always throws an exception for the [`Ok`][wom.Ok] variant.\n\n    Raises:\n        UnwrapError: Because the result was an [`Ok`][wom.Ok]\n            variant.\n    \"\"\"\n    actual = self._value.__class__.__name__\n    raise errors.UnwrapError(f\"Called unwrap error on a non error value of type {actual!r}\")\n</code></pre>"},{"location":"reference/result/#wom.result.Result","title":"Result","text":"<p>             Bases: <code>Generic[T, E]</code>, <code>ABC</code></p> <p>Represents a potential <code>Ok</code> or <code>Err</code> result.</p> <p>Note</p> <p>This class cannot be instantiated, only its variants can be.</p> Source code in <code>wom/result.py</code> <pre><code>class Result(t.Generic[T, E], abc.ABC):\n    \"\"\"Represents a potential [`Ok`][wom.Ok] or [`Err`][wom.Err] result.\n\n    !!! note\n\n        This class cannot be instantiated, only its variants can be.\n    \"\"\"\n\n    __slots__ = (\"_error\", \"_value\")\n\n    def __repr__(self) -&gt; str:\n        inner = self._value if self.is_ok else self._error  # type: ignore [attr-defined]\n        return f\"{self.__class__.__name__}({inner})\"\n\n    @property\n    @abc.abstractmethod\n    def is_ok(self) -&gt; bool:\n        \"\"\"`True` if this result is the [`Ok`][wom.Ok] variant.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def is_err(self) -&gt; bool:\n        \"\"\"`True` if this result is the [`Err`][wom.Err] variant.\"\"\"\n\n    @abc.abstractmethod\n    def unwrap(self) -&gt; T:\n        \"\"\"Unwraps the result to produce the value.\n\n        Returns:\n            The unwrapped value.\n\n        Raises:\n            UnwrapError: If the result was an [`Err`][wom.Err] and not\n                [`Ok`][wom.Ok].\n        \"\"\"\n\n    @abc.abstractmethod\n    def unwrap_err(self) -&gt; E:\n        \"\"\"Unwraps the result to produce the error.\n\n        Returns:\n            The unwrapped error.\n\n        Raises:\n            UnwrapError: If the result was [`Ok`][wom.Ok] and not an\n                [`Err`][wom.Err].\n        \"\"\"\n\n    @abc.abstractmethod\n    def to_dict(self) -&gt; t.Dict[str, t.Any]:\n        \"\"\"Converts the result into a dictionary.\n\n        If this result is [`Ok`][wom.Ok], the \"value\" property will be set.\n\n        If this result is [`Err`][wom.Err], the \"error\" property will be set.\n\n        Returns:\n            The requested dictionary.\n        \"\"\"\n</code></pre>"},{"location":"reference/result/#wom.result.Result.is_err","title":"is_err  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>is_err: bool\n</code></pre> <p><code>True</code> if this result is the <code>Err</code> variant.</p>"},{"location":"reference/result/#wom.result.Result.is_ok","title":"is_ok  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>is_ok: bool\n</code></pre> <p><code>True</code> if this result is the <code>Ok</code> variant.</p>"},{"location":"reference/result/#wom.result.Result.to_dict","title":"to_dict  <code>abstractmethod</code>","text":"<pre><code>to_dict() -&gt; t.Dict[str, t.Any]\n</code></pre> <p>Converts the result into a dictionary.</p> <p>If this result is <code>Ok</code>, the \"value\" property will be set.</p> <p>If this result is <code>Err</code>, the \"error\" property will be set.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The requested dictionary.</p> Source code in <code>wom/result.py</code> <pre><code>@abc.abstractmethod\ndef to_dict(self) -&gt; t.Dict[str, t.Any]:\n    \"\"\"Converts the result into a dictionary.\n\n    If this result is [`Ok`][wom.Ok], the \"value\" property will be set.\n\n    If this result is [`Err`][wom.Err], the \"error\" property will be set.\n\n    Returns:\n        The requested dictionary.\n    \"\"\"\n</code></pre>"},{"location":"reference/result/#wom.result.Result.unwrap","title":"unwrap  <code>abstractmethod</code>","text":"<pre><code>unwrap() -&gt; T\n</code></pre> <p>Unwraps the result to produce the value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The unwrapped value.</p> <p>Raises:</p> Type Description <code>UnwrapError</code> <p>If the result was an <code>Err</code> and not <code>Ok</code>.</p> Source code in <code>wom/result.py</code> <pre><code>@abc.abstractmethod\ndef unwrap(self) -&gt; T:\n    \"\"\"Unwraps the result to produce the value.\n\n    Returns:\n        The unwrapped value.\n\n    Raises:\n        UnwrapError: If the result was an [`Err`][wom.Err] and not\n            [`Ok`][wom.Ok].\n    \"\"\"\n</code></pre>"},{"location":"reference/result/#wom.result.Result.unwrap_err","title":"unwrap_err  <code>abstractmethod</code>","text":"<pre><code>unwrap_err() -&gt; E\n</code></pre> <p>Unwraps the result to produce the error.</p> <p>Returns:</p> Type Description <code>E</code> <p>The unwrapped error.</p> <p>Raises:</p> Type Description <code>UnwrapError</code> <p>If the result was <code>Ok</code> and not an <code>Err</code>.</p> Source code in <code>wom/result.py</code> <pre><code>@abc.abstractmethod\ndef unwrap_err(self) -&gt; E:\n    \"\"\"Unwraps the result to produce the error.\n\n    Returns:\n        The unwrapped error.\n\n    Raises:\n        UnwrapError: If the result was [`Ok`][wom.Ok] and not an\n            [`Err`][wom.Err].\n    \"\"\"\n</code></pre>"},{"location":"reference/routes/","title":"routes","text":"<p>Route/endpoint related items.</p>"},{"location":"reference/routes/#wom.routes.CompiledRoute","title":"CompiledRoute","text":"<p>A route that has been compiled to include uri variables.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Route</code> <p>The route to compile.</p> required Source code in <code>wom/routes.py</code> <pre><code>class CompiledRoute:\n    \"\"\"A route that has been compiled to include uri variables.\n\n    Args:\n        route: The route to compile.\n    \"\"\"\n\n    __slots__ = (\"_route\", \"_uri\", \"_params\")\n\n    def __init__(self, route: Route, uri: str) -&gt; None:\n        self._uri = uri\n        self._route = route\n        self._params: t.Dict[str, t.Union[str, int]] = {}\n\n    @property\n    def route(self) -&gt; Route:\n        \"\"\"The route itself.\"\"\"\n        return self._route\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"The routes uri endpoint.\"\"\"\n        return self._uri\n\n    @uri.setter\n    def uri(self, uri: str) -&gt; None:\n        self._uri = uri\n\n    @property\n    def method(self) -&gt; str:\n        \"\"\"The routes method, i.e. GET, POST...\"\"\"\n        return self.route.method\n\n    @property\n    def params(self) -&gt; t.Dict[str, t.Union[str, int]]:\n        \"\"\"The query params for the route.\"\"\"\n        return self._params\n\n    def with_params(self, params: t.Dict[str, t.Any]) -&gt; CompiledRoute:\n        \"\"\"Adds additional query params to this compiled route.\n\n        Args:\n            params: The query params to compile.\n\n        Returns:\n            The compiled route for chained calls.\n        \"\"\"\n        if params:\n            self.params.update(params)\n\n        return self\n</code></pre>"},{"location":"reference/routes/#wom.routes.CompiledRoute.method","title":"method  <code>property</code>","text":"<pre><code>method: str\n</code></pre> <p>The routes method, i.e. GET, POST...</p>"},{"location":"reference/routes/#wom.routes.CompiledRoute.params","title":"params  <code>property</code>","text":"<pre><code>params: Dict[str, Union[str, int]]\n</code></pre> <p>The query params for the route.</p>"},{"location":"reference/routes/#wom.routes.CompiledRoute.route","title":"route  <code>property</code>","text":"<pre><code>route: Route\n</code></pre> <p>The route itself.</p>"},{"location":"reference/routes/#wom.routes.CompiledRoute.uri","title":"uri  <code>property</code> <code>writable</code>","text":"<pre><code>uri: str\n</code></pre> <p>The routes uri endpoint.</p>"},{"location":"reference/routes/#wom.routes.CompiledRoute.with_params","title":"with_params","text":"<pre><code>with_params(params: t.Dict[str, t.Any]) -&gt; CompiledRoute\n</code></pre> <p>Adds additional query params to this compiled route.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Dict[str, Any]</code> <p>The query params to compile.</p> required <p>Returns:</p> Type Description <code>CompiledRoute</code> <p>The compiled route for chained calls.</p> Source code in <code>wom/routes.py</code> <pre><code>def with_params(self, params: t.Dict[str, t.Any]) -&gt; CompiledRoute:\n    \"\"\"Adds additional query params to this compiled route.\n\n    Args:\n        params: The query params to compile.\n\n    Returns:\n        The compiled route for chained calls.\n    \"\"\"\n    if params:\n        self.params.update(params)\n\n    return self\n</code></pre>"},{"location":"reference/routes/#wom.routes.Route","title":"Route","text":"<p>A route that has not been compiled yet.</p> Source code in <code>wom/routes.py</code> <pre><code>@attrs.define(weakref_slot=False)\nclass Route:\n    \"\"\"A route that has not been compiled yet.\"\"\"\n\n    method: str\n    \"\"\"The request method to use.\"\"\"\n    uri: str\n    \"\"\"The request uri.\"\"\"\n\n    def compile(self, *args: t.Union[str, int]) -&gt; CompiledRoute:\n        \"\"\"Turn this route into a compiled route.\n\n        Args:\n            *args: The arguments to insert into the uri.\n\n        Returns:\n            The compiled route.\n        \"\"\"\n        compiled = CompiledRoute(self, self.uri)\n\n        for arg in args:\n            compiled.uri = compiled.uri.replace(r\"{}\", str(arg), 1)\n\n        return compiled\n</code></pre>"},{"location":"reference/routes/#wom.routes.Route.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method: str\n</code></pre> <p>The request method to use.</p>"},{"location":"reference/routes/#wom.routes.Route.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: str\n</code></pre> <p>The request uri.</p>"},{"location":"reference/routes/#wom.routes.Route.compile","title":"compile","text":"<pre><code>compile(*args: t.Union[str, int]) -&gt; CompiledRoute\n</code></pre> <p>Turn this route into a compiled route.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Union[str, int]</code> <p>The arguments to insert into the uri.</p> <code>()</code> <p>Returns:</p> Type Description <code>CompiledRoute</code> <p>The compiled route.</p> Source code in <code>wom/routes.py</code> <pre><code>def compile(self, *args: t.Union[str, int]) -&gt; CompiledRoute:\n    \"\"\"Turn this route into a compiled route.\n\n    Args:\n        *args: The arguments to insert into the uri.\n\n    Returns:\n        The compiled route.\n    \"\"\"\n    compiled = CompiledRoute(self, self.uri)\n\n    for arg in args:\n        compiled.uri = compiled.uri.replace(r\"{}\", str(arg), 1)\n\n    return compiled\n</code></pre>"},{"location":"reference/serializer/","title":"serializer","text":"<p>This module contains the <code>Serializer</code> that is used to parse incoming network data into Python classes.</p>"},{"location":"reference/serializer/#wom.serializer.Serializer","title":"Serializer","text":"<p>Deserializes raw bytes into wom.py model classes.</p> Source code in <code>wom/serializer.py</code> <pre><code>class Serializer:\n    \"\"\"Deserializes raw bytes into wom.py model classes.\"\"\"\n\n    __slots__ = (\"_decoders\",)\n\n    def __init__(self) -&gt; None:\n        self._decoders: DecodersT = {}\n\n    def decode(self, data: bytes, model_type: t.Type[T]) -&gt; T:\n        \"\"\"Decodes the data into the given model type.\n\n        Args:\n            data: The JSON payload as bytes.\n\n            model_type: The type of model to decode into.\n\n        Returns:\n            The requested model.\n        \"\"\"\n        return self.get_decoder(model_type).decode(data)\n\n    def get_decoder(self, model_type: t.Type[T]) -&gt; Decoder[T]:\n        \"\"\"Lazily initializes decoders as they are requested and caches them.\n\n        Args:\n            model_type: The model type this decoder will target.\n\n        Returns:\n            The requested decoder.\n        \"\"\"\n        if not (decoder := self._decoders.get(model_type)):\n            decoder = self._decoders[model_type] = Decoder(model_type)\n\n        return decoder  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/serializer/#wom.serializer.Serializer.decode","title":"decode","text":"<pre><code>decode(data: bytes, model_type: t.Type[T]) -&gt; T\n</code></pre> <p>Decodes the data into the given model type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The JSON payload as bytes.</p> required <code>model_type</code> <code>Type[T]</code> <p>The type of model to decode into.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The requested model.</p> Source code in <code>wom/serializer.py</code> <pre><code>def decode(self, data: bytes, model_type: t.Type[T]) -&gt; T:\n    \"\"\"Decodes the data into the given model type.\n\n    Args:\n        data: The JSON payload as bytes.\n\n        model_type: The type of model to decode into.\n\n    Returns:\n        The requested model.\n    \"\"\"\n    return self.get_decoder(model_type).decode(data)\n</code></pre>"},{"location":"reference/serializer/#wom.serializer.Serializer.get_decoder","title":"get_decoder","text":"<pre><code>get_decoder(model_type: t.Type[T]) -&gt; Decoder[T]\n</code></pre> <p>Lazily initializes decoders as they are requested and caches them.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[T]</code> <p>The model type this decoder will target.</p> required <p>Returns:</p> Type Description <code>Decoder[T]</code> <p>The requested decoder.</p> Source code in <code>wom/serializer.py</code> <pre><code>def get_decoder(self, model_type: t.Type[T]) -&gt; Decoder[T]:\n    \"\"\"Lazily initializes decoders as they are requested and caches them.\n\n    Args:\n        model_type: The model type this decoder will target.\n\n    Returns:\n        The requested decoder.\n    \"\"\"\n    if not (decoder := self._decoders.get(model_type)):\n        decoder = self._decoders[model_type] = Decoder(model_type)\n\n    return decoder  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/services/","title":"services","text":"<p>This module contains the services used to interact with different portions of the WOM API.</p>"},{"location":"reference/services/#wom.services.BaseService","title":"BaseService","text":"<p>             Bases: <code>ABC</code></p> <p>The base service all API services inherit from.</p> <p>Parameters:</p> Name Type Description Default <code>http_service</code> <code>HttpService</code> <p>The http service to use for requests.</p> required <code>serializer</code> <code>Serializer</code> <p>The serializer to use for handling incoming JSON data from the API.</p> required Source code in <code>wom/services/base.py</code> <pre><code>class BaseService(abc.ABC):\n    \"\"\"The base service all API services inherit from.\n\n    Args:\n        http_service: The http service to use for requests.\n\n        serializer: The serializer to use for handling incoming\n            JSON data from the API.\n    \"\"\"\n\n    __slots__ = (\"_http\", \"_serializer\")\n\n    def __init__(self, http_service: HttpService, serializer: serializer.Serializer) -&gt; None:\n        self._http = http_service\n        self._serializer = serializer\n\n    def _generate_map(self, **kwargs: t.Any) -&gt; t.Dict[str, t.Any]:\n        return {k: v for k, v in kwargs.items() if v is not None}\n\n    def _ok(self, data: bytes, model_type: t.Type[T]) -&gt; ResultT[T]:\n        return result.Ok(self._serializer.decode(data, model_type))\n\n    def _ok_or_err(\n        self, data: t.Union[bytes, models.HttpErrorResponse], model_type: t.Type[T]\n    ) -&gt; ResultT[T]:\n        if isinstance(data, models.HttpErrorResponse):\n            return result.Err(data)\n\n        return self._ok(data, model_type)\n\n    def _success_or_err(\n        self,\n        data: t.Union[bytes, models.HttpErrorResponse],\n        *,\n        predicate: t.Optional[t.Callable[[str], bool]] = None,\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        if isinstance(data, bytes):\n            err = self._serializer.decode(data, models.HttpErrorResponse)\n            return result.Err(err)\n\n        predicate = predicate or (lambda m: m.startswith(\"Success\"))\n\n        if not predicate(data.message):\n            return result.Err(data)\n\n        return result.Ok(models.HttpSuccessResponse(data.message, data.status))\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService","title":"CompetitionService","text":"<p>             Bases: <code>BaseService</code></p> <p>Handles endpoints related to competitions.</p> Source code in <code>wom/services/competitions.py</code> <pre><code>class CompetitionService(BaseService):\n    \"\"\"Handles endpoints related to competitions.\"\"\"\n\n    __slots__ = ()\n\n    async def search_competitions(\n        self,\n        *,\n        title: t.Optional[str] = None,\n        type: t.Optional[models.CompetitionType] = None,\n        status: t.Optional[models.CompetitionStatus] = None,\n        metric: t.Optional[enums.Metric] = None,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n    ) -&gt; ResultT[t.List[models.Competition]]:\n        \"\"\"Searches for competitions with the given criteria.\n\n        Keyword Args:\n            title: The optional title of the competition. Defaults to\n                `None`.\n\n            type: The optional [`CompetitionType`][wom.CompetitionType]\n                filter. Defaults to `None`\n\n            status: The optional [`CompetitionStatus`]\n                [wom.CompetitionStatus] filter. Defaults to `None`.\n\n            metric: The optional [`Metric`][wom.Metric] filter. Defaults\n                to `None`.\n\n            limit: The maximum number of paginated items to receive.\n                Defaults to `None` (I think thats 20 items?).\n\n            offset: The page offset for requesting multiple pages.\n                Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of competitions\n                or an error.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.search_competitions(\n                title=\"Sick Competition\",\n                type=wom.CompetitionType.Classic,\n                status=wom.CompetitionStatus.Ongoing,\n                limit=3,\n                offset=1\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            title=title,\n            limit=limit,\n            offset=offset,\n            type=type.value if type else None,\n            status=status.value if status else None,\n            metric=metric.value if metric else None,\n        )\n\n        route = routes.SEARCH_COMPETITIONS.compile().with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.Competition])\n\n    async def get_details(\n        self, id: int, *, metric: t.Optional[enums.Metric] = None\n    ) -&gt; ResultT[models.CompetitionDetail]:\n        \"\"\"Gets details for the given competition.\n\n        Args:\n            id: The ID of the competition.\n\n        Keyword Args:\n            metric: The optional [`Metric`][wom.Metric] to view the\n                competition progress in. As if this competition was\n                actually for that metric. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the competition details.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.get_details(123)\n\n            result2 = await client.competitions.get_details(\n                123, wom.Metric.Attack\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(metric=metric.value if metric else None)\n        route = routes.COMPETITION_DETAILS.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, models.CompetitionDetail)\n\n    async def get_top_participant_history(\n        self, id: int, *, metric: t.Optional[enums.Metric] = None\n    ) -&gt; ResultT[t.List[models.Top5ProgressResult]]:\n        \"\"\"Gets details for the players with the top 5 progress in the\n        competition.\n\n        Args:\n            id: The ID of the competition.\n\n        Keyword Args:\n            metric: The optional [`Metric`][wom.Metric] to view the\n                competition progress in. As if this competition was\n                actually for that metric. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of top 5\n                progress players.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            result = await client.competitions.get_competition_details(123)\n\n            result2 = await client.competitions.get_competition_details(\n                123, wom.Metric.Attack\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(metric=metric.value if metric else None)\n        route = routes.TOP_PARTICIPANT_HISTORY.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.Top5ProgressResult])\n\n    async def create_competition(\n        self,\n        title: str,\n        metric: enums.Metric,\n        starts_at: datetime,\n        ends_at: datetime,\n        *,\n        group_id: t.Optional[int] = None,\n        group_verification_code: t.Optional[str] = None,\n        teams: t.Optional[t.List[models.Team]] = None,\n        participants: t.Optional[t.List[str]] = None,\n    ) -&gt; ResultT[models.CreatedCompetitionDetail]:\n        \"\"\"Creates a new competition.\n\n        Args:\n            title: The title of the competition.\n\n            metric: The [`Metric`][wom.Metric] the competition should\n                measure.\n\n            starts_at: The start date for the competition.\n\n            ends_at: The end date for the competition.\n\n        Keyword Args:\n            group_id: The optional group id to tie to this competition.\n                Defaults to `None`.\n\n            group_verification_code: The optional group verification\n                code. Required if group_id is supplied. Defaults to\n                `None`.\n\n            participants: The optional list of participants to include\n                in the competition. Defaults to `None`.\n\n            teams: The optional teams to include in the competition.\n                Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the newly created\n                competition detail.\n\n        !!! info\n\n            The `group_id`, `participants`, and `teams` parameters are\n            mutually exclusive.\n\n            - If `group_id` is provided, this method will create a\n                classic competition with all members of that group as\n                participants.\n\n            - If `participants` is provided and `group_id` isn't, this\n                method will create a classic competition with all those\n                participants included.\n\n            - If `teams` is provided, this endpoint will create a team\n                competition with all those participants included.\n                Also accepts `group_id` as a way to link this\n                competition to the group.\n\n        ??? example\n\n            ```py\n            from datetime import datetime, timedelta\n            import wom\n\n            client = wom.Client(...)\n\n            result = await client.competitions.create_competition(\n                \"Slayer week\",\n                wom.Metric.Slayer,\n                starts_at=datetime.now() + timedelta(days=7),\n                ends_at=datetime.now() + timedelta(days=14),\n                group_verification_code=\"111-111-111\",\n                group_id=123,\n            )\n            ```\n        \"\"\"\n        payload = self._generate_map(\n            title=title,\n            teams=teams,\n            groupId=group_id,\n            participants=participants,\n            endsAt=ends_at.isoformat(),\n            startsAt=starts_at.isoformat(),\n            metric=metric.value if metric else None,\n            groupVerificationCode=group_verification_code,\n        )\n\n        route = routes.CREATE_COMPETITION.compile()\n        data = await self._http.fetch(route, payload=payload)\n        return self._ok_or_err(data, models.CreatedCompetitionDetail)\n\n    async def edit_competition(\n        self,\n        id: int,\n        verification_code: str,\n        *,\n        title: t.Optional[str] = None,\n        metric: t.Optional[enums.Metric] = None,\n        starts_at: t.Optional[datetime] = None,\n        ends_at: t.Optional[datetime] = None,\n        teams: t.Optional[t.List[models.Team]] = None,\n        participants: t.Optional[t.List[str]] = None,\n    ) -&gt; ResultT[models.Competition]:\n        \"\"\"Edits an existing competition.\n\n        Args:\n            id: The ID of the competition.\n\n            verification_code: The verification code for the\n                competition.\n\n        Keyword Args:\n            title: The optional updated title of the competition.\n                Defaults to `None`.\n\n            metric: The optional new [`Metric`][wom.Metric] the\n                competition should measure. Defaults to `None`.\n\n            starts_at: The optional new start date for the competition.\n                Defaults to `None`.\n\n            ends_at: The optional new end date for the competition.\n                Defaults to `None`.\n\n            participants: The optional list of participants to replace\n                the existing participants with. Defaults to `None`.\n\n            teams: The optional list of teams to replace the existing\n                participants with. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the edited competition\n                with participations.\n\n        !!! warning\n\n            The teams/participants parameters will completely\n            overwrite the existing participants/teams. If you're looking\n            to add users, check out [`add_participants()`]\n            [wom.CompetitionService.add_participants].\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.edit_competition(\n                123, \"111-111-111\", title=\"New title\"\n            )\n            ```\n        \"\"\"\n        payload = self._generate_map(\n            title=title,\n            teams=teams,\n            participants=participants,\n            startsAt=starts_at.isoformat() if starts_at else None,\n            endsAt=ends_at.isoformat() if ends_at else None,\n            metric=metric.value if metric else None,\n            verificationCode=verification_code,\n        )\n\n        route = routes.EDIT_COMPETITION.compile(id)\n        data = await self._http.fetch(route, payload=payload)\n        return self._ok_or_err(data, models.Competition)\n\n    async def delete_competition(\n        self, id: int, verification_code: str\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Deletes a competition.\n\n        Args:\n            id: The ID of the competition.\n\n            verification_code: The verification code for the\n                competition.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        !!! warning\n\n            This action can not be reversed.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.delete_competition(\n                123, \"111-111-111\"\n            )\n            ```\n        \"\"\"\n        route = routes.DELETE_COMPETITION.compile(id)\n        payload = self._generate_map(verificationCode=verification_code)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data)\n\n    async def add_participants(\n        self, id: int, verification_code: str, *participants: str\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Adds participants to a competition. Only adds valid\n        participants, and ignores duplicates.\n\n        Args:\n            id: The ID of the competition.\n\n            verification_code: The verification code for the\n                competition.\n\n            *participants: The participants you would like to add.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.add_participants(\n                123, \"111-111-111\", \"Jonxslays\", \"Zezima\"\n            )\n            ```\n        \"\"\"\n        route = routes.ADD_PARTICIPANTS.compile(id)\n        payload = self._generate_map(verificationCode=verification_code, participants=participants)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data)\n\n    async def remove_participants(\n        self, id: int, verification_code: str, *participants: str\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Removes participants from a competition. Ignores usernames\n        that are not competing.\n\n        Args:\n            id: The ID of the competition.\n\n            verification_code: The verification code for the\n                competition.\n\n            *participants: The participants you would like to remove.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.remove_participants(\n                123, \"111-111-111\", \"Jonxslays\"\n            )\n            ```\n\n        \"\"\"\n        route = routes.REMOVE_PARTICIPANTS.compile(id)\n        payload = self._generate_map(verificationCode=verification_code, participants=participants)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data)\n\n    async def add_teams(\n        self, id: int, verification_code: str, *teams: models.Team\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Adds teams to a competition. Ignores duplicates.\n\n        Args:\n            id: The ID of the competition.\n\n            verification_code: The verification code for the\n                competition.\n\n            *teams: The teams you would like to add.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.add_teams(\n                123,\n                \"111-111-111\",\n                wom.Team(\"Team 1\", [\"Jonxslays\", \"lilyuffie88\"]),\n                wom.Team(\"Team 2\", [\"Zezima\", \"the old nite\"]),\n            )\n            ```\n        \"\"\"\n        route = routes.ADD_TEAMS.compile(id)\n        payload = self._generate_map(verificationCode=verification_code, teams=teams)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data)\n\n    async def remove_teams(\n        self, id: int, verification_code: str, *teams: str\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Removes teams from a competition. Ignores teams that don't\n        exist.\n\n        Args:\n            id: The ID of the competition.\n\n            verification_code: The verification code for the\n                competition.\n\n            *teams: The team names you would like to remove.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.remove_teams(\n                123, \"111-111-111\", \"Team 1\", \"Team 2\"\n            )\n            ```\n        \"\"\"\n        route = routes.REMOVE_TEAMS.compile(id)\n        payload = self._generate_map(verificationCode=verification_code, teamNames=teams)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data)\n\n    async def update_outdated_participants(\n        self, id: int, verification_code: str\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Attempts to update all outdated competition participants.\n\n        Args:\n            id: The ID of the competition.\n\n            verification_code: The verification code for the\n                competition.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        !!! info\n\n            Participants are outdated when either:\n\n            - Competition is ending or started within 6h of now and\n                the player hasn't been updated in over 1h.\n\n            - Player hasn't been updated in over 24h.\n\n        !!! warning\n\n            This method adds every outdated participant to an\n            \"update queue\", and the WOM servers try to update players\n            in the queue one by one, with a delay in between each. For\n            each player in the queue, an attempt is made to update it\n            up to 3 times, with 30s in between each attempt.\n\n            Please note that this is dependent on the OSRS hiscores\n            functioning correctly, and therefore this method does NOT\n            guarantee the players will be updated, it only guarantees\n            that an attempt will be made to update them, up to 3 times.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.update_outdated_participants(\n                123, \"111-111-111\"\n            )\n            ```\n        \"\"\"\n        route = routes.UPDATE_OUTDATED_PARTICIPANTS.compile(id)\n        payload = self._generate_map(verificationCode=verification_code)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data, predicate=lambda m: \"players are being updated\" in m)\n\n    async def get_details_csv(\n        self,\n        id: int,\n        *,\n        metric: t.Optional[enums.Metric] = None,\n        team_name: t.Optional[str] = None,\n        table_type: t.Optional[models.CompetitionCSVTableType] = None,\n    ) -&gt; ResultT[str]:\n        \"\"\"Gets details about the competition in CSV format.\n\n        Args:\n            id: The ID of the competition.\n\n        Keyword Args:\n            metric: The optional [`Metric`][wom.Metric] to view the\n                competition progress in. As if this competition was\n                actually for that metric. Defaults to `None`.\n\n            team_name: The optional team name you would like to get details\n                for. Defaults to `None`.\n\n            table_type: The optional table type formatting to apply.\n                Defaults to `Participants`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the CSV string.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.competitions.get_details_csv(\n                123, team_name=\"Cool team\"\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(metric=metric, teamName=team_name, table=table_type)\n        route = routes.COMPETITION_DETAILS_CSV.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n\n        if isinstance(data, models.HttpErrorResponse):\n            return result.Err(data)\n\n        return result.Ok(data.decode())\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.add_participants","title":"add_participants  <code>async</code>","text":"<pre><code>add_participants(\n    id: int, verification_code: str, *participants: str\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Adds participants to a competition. Only adds valid participants, and ignores duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <code>verification_code</code> <code>str</code> <p>The verification code for the competition.</p> required <code>*participants</code> <code>str</code> <p>The participants you would like to add.</p> <code>()</code> <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.add_participants(\n    123, \"111-111-111\", \"Jonxslays\", \"Zezima\"\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def add_participants(\n    self, id: int, verification_code: str, *participants: str\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Adds participants to a competition. Only adds valid\n    participants, and ignores duplicates.\n\n    Args:\n        id: The ID of the competition.\n\n        verification_code: The verification code for the\n            competition.\n\n        *participants: The participants you would like to add.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.add_participants(\n            123, \"111-111-111\", \"Jonxslays\", \"Zezima\"\n        )\n        ```\n    \"\"\"\n    route = routes.ADD_PARTICIPANTS.compile(id)\n    payload = self._generate_map(verificationCode=verification_code, participants=participants)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data)\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.add_teams","title":"add_teams  <code>async</code>","text":"<pre><code>add_teams(\n    id: int, verification_code: str, *teams: models.Team\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Adds teams to a competition. Ignores duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <code>verification_code</code> <code>str</code> <p>The verification code for the competition.</p> required <code>*teams</code> <code>Team</code> <p>The teams you would like to add.</p> <code>()</code> <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.add_teams(\n    123,\n    \"111-111-111\",\n    wom.Team(\"Team 1\", [\"Jonxslays\", \"lilyuffie88\"]),\n    wom.Team(\"Team 2\", [\"Zezima\", \"the old nite\"]),\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def add_teams(\n    self, id: int, verification_code: str, *teams: models.Team\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Adds teams to a competition. Ignores duplicates.\n\n    Args:\n        id: The ID of the competition.\n\n        verification_code: The verification code for the\n            competition.\n\n        *teams: The teams you would like to add.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.add_teams(\n            123,\n            \"111-111-111\",\n            wom.Team(\"Team 1\", [\"Jonxslays\", \"lilyuffie88\"]),\n            wom.Team(\"Team 2\", [\"Zezima\", \"the old nite\"]),\n        )\n        ```\n    \"\"\"\n    route = routes.ADD_TEAMS.compile(id)\n    payload = self._generate_map(verificationCode=verification_code, teams=teams)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data)\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.create_competition","title":"create_competition  <code>async</code>","text":"<pre><code>create_competition(\n    title: str,\n    metric: enums.Metric,\n    starts_at: datetime,\n    ends_at: datetime,\n    *,\n    group_id: t.Optional[int] = None,\n    group_verification_code: t.Optional[str] = None,\n    teams: t.Optional[t.List[models.Team]] = None,\n    participants: t.Optional[t.List[str]] = None\n) -&gt; ResultT[models.CreatedCompetitionDetail]\n</code></pre> <p>Creates a new competition.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the competition.</p> required <code>metric</code> <code>Metric</code> <p>The <code>Metric</code> the competition should measure.</p> required <code>starts_at</code> <code>datetime</code> <p>The start date for the competition.</p> required <code>ends_at</code> <code>datetime</code> <p>The end date for the competition.</p> required <p>Other Parameters:</p> Name Type Description <code>group_id</code> <code>Optional[int]</code> <p>The optional group id to tie to this competition. Defaults to <code>None</code>.</p> <code>group_verification_code</code> <code>Optional[str]</code> <p>The optional group verification code. Required if group_id is supplied. Defaults to <code>None</code>.</p> <code>participants</code> <code>Optional[List[str]]</code> <p>The optional list of participants to include in the competition. Defaults to <code>None</code>.</p> <code>teams</code> <code>Optional[List[Team]]</code> <p>The optional teams to include in the competition. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[CreatedCompetitionDetail]</code> <p>A <code>Result</code> containing the newly created competition detail.</p> <p>Info</p> <p>The <code>group_id</code>, <code>participants</code>, and <code>teams</code> parameters are mutually exclusive.</p> <ul> <li> <p>If <code>group_id</code> is provided, this method will create a     classic competition with all members of that group as     participants.</p> </li> <li> <p>If <code>participants</code> is provided and <code>group_id</code> isn't, this     method will create a classic competition with all those     participants included.</p> </li> <li> <p>If <code>teams</code> is provided, this endpoint will create a team     competition with all those participants included.     Also accepts <code>group_id</code> as a way to link this     competition to the group.</p> </li> </ul> Example <pre><code>from datetime import datetime, timedelta\nimport wom\n\nclient = wom.Client(...)\n\nresult = await client.competitions.create_competition(\n    \"Slayer week\",\n    wom.Metric.Slayer,\n    starts_at=datetime.now() + timedelta(days=7),\n    ends_at=datetime.now() + timedelta(days=14),\n    group_verification_code=\"111-111-111\",\n    group_id=123,\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def create_competition(\n    self,\n    title: str,\n    metric: enums.Metric,\n    starts_at: datetime,\n    ends_at: datetime,\n    *,\n    group_id: t.Optional[int] = None,\n    group_verification_code: t.Optional[str] = None,\n    teams: t.Optional[t.List[models.Team]] = None,\n    participants: t.Optional[t.List[str]] = None,\n) -&gt; ResultT[models.CreatedCompetitionDetail]:\n    \"\"\"Creates a new competition.\n\n    Args:\n        title: The title of the competition.\n\n        metric: The [`Metric`][wom.Metric] the competition should\n            measure.\n\n        starts_at: The start date for the competition.\n\n        ends_at: The end date for the competition.\n\n    Keyword Args:\n        group_id: The optional group id to tie to this competition.\n            Defaults to `None`.\n\n        group_verification_code: The optional group verification\n            code. Required if group_id is supplied. Defaults to\n            `None`.\n\n        participants: The optional list of participants to include\n            in the competition. Defaults to `None`.\n\n        teams: The optional teams to include in the competition.\n            Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the newly created\n            competition detail.\n\n    !!! info\n\n        The `group_id`, `participants`, and `teams` parameters are\n        mutually exclusive.\n\n        - If `group_id` is provided, this method will create a\n            classic competition with all members of that group as\n            participants.\n\n        - If `participants` is provided and `group_id` isn't, this\n            method will create a classic competition with all those\n            participants included.\n\n        - If `teams` is provided, this endpoint will create a team\n            competition with all those participants included.\n            Also accepts `group_id` as a way to link this\n            competition to the group.\n\n    ??? example\n\n        ```py\n        from datetime import datetime, timedelta\n        import wom\n\n        client = wom.Client(...)\n\n        result = await client.competitions.create_competition(\n            \"Slayer week\",\n            wom.Metric.Slayer,\n            starts_at=datetime.now() + timedelta(days=7),\n            ends_at=datetime.now() + timedelta(days=14),\n            group_verification_code=\"111-111-111\",\n            group_id=123,\n        )\n        ```\n    \"\"\"\n    payload = self._generate_map(\n        title=title,\n        teams=teams,\n        groupId=group_id,\n        participants=participants,\n        endsAt=ends_at.isoformat(),\n        startsAt=starts_at.isoformat(),\n        metric=metric.value if metric else None,\n        groupVerificationCode=group_verification_code,\n    )\n\n    route = routes.CREATE_COMPETITION.compile()\n    data = await self._http.fetch(route, payload=payload)\n    return self._ok_or_err(data, models.CreatedCompetitionDetail)\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.delete_competition","title":"delete_competition  <code>async</code>","text":"<pre><code>delete_competition(\n    id: int, verification_code: str\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Deletes a competition.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <code>verification_code</code> <code>str</code> <p>The verification code for the competition.</p> required <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> <p>Warning</p> <p>This action can not be reversed.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.delete_competition(\n    123, \"111-111-111\"\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def delete_competition(\n    self, id: int, verification_code: str\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Deletes a competition.\n\n    Args:\n        id: The ID of the competition.\n\n        verification_code: The verification code for the\n            competition.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    !!! warning\n\n        This action can not be reversed.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.delete_competition(\n            123, \"111-111-111\"\n        )\n        ```\n    \"\"\"\n    route = routes.DELETE_COMPETITION.compile(id)\n    payload = self._generate_map(verificationCode=verification_code)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data)\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.edit_competition","title":"edit_competition  <code>async</code>","text":"<pre><code>edit_competition(\n    id: int,\n    verification_code: str,\n    *,\n    title: t.Optional[str] = None,\n    metric: t.Optional[enums.Metric] = None,\n    starts_at: t.Optional[datetime] = None,\n    ends_at: t.Optional[datetime] = None,\n    teams: t.Optional[t.List[models.Team]] = None,\n    participants: t.Optional[t.List[str]] = None\n) -&gt; ResultT[models.Competition]\n</code></pre> <p>Edits an existing competition.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <code>verification_code</code> <code>str</code> <p>The verification code for the competition.</p> required <p>Other Parameters:</p> Name Type Description <code>title</code> <code>Optional[str]</code> <p>The optional updated title of the competition. Defaults to <code>None</code>.</p> <code>metric</code> <code>Optional[Metric]</code> <p>The optional new <code>Metric</code> the competition should measure. Defaults to <code>None</code>.</p> <code>starts_at</code> <code>Optional[datetime]</code> <p>The optional new start date for the competition. Defaults to <code>None</code>.</p> <code>ends_at</code> <code>Optional[datetime]</code> <p>The optional new end date for the competition. Defaults to <code>None</code>.</p> <code>participants</code> <code>Optional[List[str]]</code> <p>The optional list of participants to replace the existing participants with. Defaults to <code>None</code>.</p> <code>teams</code> <code>Optional[List[Team]]</code> <p>The optional list of teams to replace the existing participants with. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[Competition]</code> <p>A <code>Result</code> containing the edited competition with participations.</p> <p>Warning</p> <p>The teams/participants parameters will completely overwrite the existing participants/teams. If you're looking to add users, check out <code>add_participants()</code>.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.edit_competition(\n    123, \"111-111-111\", title=\"New title\"\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def edit_competition(\n    self,\n    id: int,\n    verification_code: str,\n    *,\n    title: t.Optional[str] = None,\n    metric: t.Optional[enums.Metric] = None,\n    starts_at: t.Optional[datetime] = None,\n    ends_at: t.Optional[datetime] = None,\n    teams: t.Optional[t.List[models.Team]] = None,\n    participants: t.Optional[t.List[str]] = None,\n) -&gt; ResultT[models.Competition]:\n    \"\"\"Edits an existing competition.\n\n    Args:\n        id: The ID of the competition.\n\n        verification_code: The verification code for the\n            competition.\n\n    Keyword Args:\n        title: The optional updated title of the competition.\n            Defaults to `None`.\n\n        metric: The optional new [`Metric`][wom.Metric] the\n            competition should measure. Defaults to `None`.\n\n        starts_at: The optional new start date for the competition.\n            Defaults to `None`.\n\n        ends_at: The optional new end date for the competition.\n            Defaults to `None`.\n\n        participants: The optional list of participants to replace\n            the existing participants with. Defaults to `None`.\n\n        teams: The optional list of teams to replace the existing\n            participants with. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the edited competition\n            with participations.\n\n    !!! warning\n\n        The teams/participants parameters will completely\n        overwrite the existing participants/teams. If you're looking\n        to add users, check out [`add_participants()`]\n        [wom.CompetitionService.add_participants].\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.edit_competition(\n            123, \"111-111-111\", title=\"New title\"\n        )\n        ```\n    \"\"\"\n    payload = self._generate_map(\n        title=title,\n        teams=teams,\n        participants=participants,\n        startsAt=starts_at.isoformat() if starts_at else None,\n        endsAt=ends_at.isoformat() if ends_at else None,\n        metric=metric.value if metric else None,\n        verificationCode=verification_code,\n    )\n\n    route = routes.EDIT_COMPETITION.compile(id)\n    data = await self._http.fetch(route, payload=payload)\n    return self._ok_or_err(data, models.Competition)\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.get_details","title":"get_details  <code>async</code>","text":"<pre><code>get_details(\n    id: int, *, metric: t.Optional[enums.Metric] = None\n) -&gt; ResultT[models.CompetitionDetail]\n</code></pre> <p>Gets details for the given competition.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <p>Other Parameters:</p> Name Type Description <code>metric</code> <code>Optional[Metric]</code> <p>The optional <code>Metric</code> to view the competition progress in. As if this competition was actually for that metric. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[CompetitionDetail]</code> <p>A <code>Result</code> containing the competition details.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.get_details(123)\n\nresult2 = await client.competitions.get_details(\n    123, wom.Metric.Attack\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def get_details(\n    self, id: int, *, metric: t.Optional[enums.Metric] = None\n) -&gt; ResultT[models.CompetitionDetail]:\n    \"\"\"Gets details for the given competition.\n\n    Args:\n        id: The ID of the competition.\n\n    Keyword Args:\n        metric: The optional [`Metric`][wom.Metric] to view the\n            competition progress in. As if this competition was\n            actually for that metric. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the competition details.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.get_details(123)\n\n        result2 = await client.competitions.get_details(\n            123, wom.Metric.Attack\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(metric=metric.value if metric else None)\n    route = routes.COMPETITION_DETAILS.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, models.CompetitionDetail)\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.get_details_csv","title":"get_details_csv  <code>async</code>","text":"<pre><code>get_details_csv(\n    id: int,\n    *,\n    metric: t.Optional[enums.Metric] = None,\n    team_name: t.Optional[str] = None,\n    table_type: t.Optional[\n        models.CompetitionCSVTableType\n    ] = None\n) -&gt; ResultT[str]\n</code></pre> <p>Gets details about the competition in CSV format.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <p>Other Parameters:</p> Name Type Description <code>metric</code> <code>Optional[Metric]</code> <p>The optional <code>Metric</code> to view the competition progress in. As if this competition was actually for that metric. Defaults to <code>None</code>.</p> <code>team_name</code> <code>Optional[str]</code> <p>The optional team name you would like to get details for. Defaults to <code>None</code>.</p> <code>table_type</code> <code>Optional[CompetitionCSVTableType]</code> <p>The optional table type formatting to apply. Defaults to <code>Participants</code>.</p> <p>Returns:</p> Type Description <code>ResultT[str]</code> <p>A <code>Result</code> containing the CSV string.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.get_details_csv(\n    123, team_name=\"Cool team\"\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def get_details_csv(\n    self,\n    id: int,\n    *,\n    metric: t.Optional[enums.Metric] = None,\n    team_name: t.Optional[str] = None,\n    table_type: t.Optional[models.CompetitionCSVTableType] = None,\n) -&gt; ResultT[str]:\n    \"\"\"Gets details about the competition in CSV format.\n\n    Args:\n        id: The ID of the competition.\n\n    Keyword Args:\n        metric: The optional [`Metric`][wom.Metric] to view the\n            competition progress in. As if this competition was\n            actually for that metric. Defaults to `None`.\n\n        team_name: The optional team name you would like to get details\n            for. Defaults to `None`.\n\n        table_type: The optional table type formatting to apply.\n            Defaults to `Participants`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the CSV string.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.get_details_csv(\n            123, team_name=\"Cool team\"\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(metric=metric, teamName=team_name, table=table_type)\n    route = routes.COMPETITION_DETAILS_CSV.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n\n    if isinstance(data, models.HttpErrorResponse):\n        return result.Err(data)\n\n    return result.Ok(data.decode())\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.get_top_participant_history","title":"get_top_participant_history  <code>async</code>","text":"<pre><code>get_top_participant_history(\n    id: int, *, metric: t.Optional[enums.Metric] = None\n) -&gt; ResultT[t.List[models.Top5ProgressResult]]\n</code></pre> <p>Gets details for the players with the top 5 progress in the competition.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <p>Other Parameters:</p> Name Type Description <code>metric</code> <code>Optional[Metric]</code> <p>The optional <code>Metric</code> to view the competition progress in. As if this competition was actually for that metric. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[Top5ProgressResult]]</code> <p>A <code>Result</code> containing the list of top 5 progress players.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nresult = await client.competitions.get_competition_details(123)\n\nresult2 = await client.competitions.get_competition_details(\n    123, wom.Metric.Attack\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def get_top_participant_history(\n    self, id: int, *, metric: t.Optional[enums.Metric] = None\n) -&gt; ResultT[t.List[models.Top5ProgressResult]]:\n    \"\"\"Gets details for the players with the top 5 progress in the\n    competition.\n\n    Args:\n        id: The ID of the competition.\n\n    Keyword Args:\n        metric: The optional [`Metric`][wom.Metric] to view the\n            competition progress in. As if this competition was\n            actually for that metric. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of top 5\n            progress players.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        result = await client.competitions.get_competition_details(123)\n\n        result2 = await client.competitions.get_competition_details(\n            123, wom.Metric.Attack\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(metric=metric.value if metric else None)\n    route = routes.TOP_PARTICIPANT_HISTORY.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.Top5ProgressResult])\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.remove_participants","title":"remove_participants  <code>async</code>","text":"<pre><code>remove_participants(\n    id: int, verification_code: str, *participants: str\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Removes participants from a competition. Ignores usernames that are not competing.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <code>verification_code</code> <code>str</code> <p>The verification code for the competition.</p> required <code>*participants</code> <code>str</code> <p>The participants you would like to remove.</p> <code>()</code> <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.remove_participants(\n    123, \"111-111-111\", \"Jonxslays\"\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def remove_participants(\n    self, id: int, verification_code: str, *participants: str\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Removes participants from a competition. Ignores usernames\n    that are not competing.\n\n    Args:\n        id: The ID of the competition.\n\n        verification_code: The verification code for the\n            competition.\n\n        *participants: The participants you would like to remove.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.remove_participants(\n            123, \"111-111-111\", \"Jonxslays\"\n        )\n        ```\n\n    \"\"\"\n    route = routes.REMOVE_PARTICIPANTS.compile(id)\n    payload = self._generate_map(verificationCode=verification_code, participants=participants)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data)\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.remove_teams","title":"remove_teams  <code>async</code>","text":"<pre><code>remove_teams(\n    id: int, verification_code: str, *teams: str\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Removes teams from a competition. Ignores teams that don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <code>verification_code</code> <code>str</code> <p>The verification code for the competition.</p> required <code>*teams</code> <code>str</code> <p>The team names you would like to remove.</p> <code>()</code> <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.remove_teams(\n    123, \"111-111-111\", \"Team 1\", \"Team 2\"\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def remove_teams(\n    self, id: int, verification_code: str, *teams: str\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Removes teams from a competition. Ignores teams that don't\n    exist.\n\n    Args:\n        id: The ID of the competition.\n\n        verification_code: The verification code for the\n            competition.\n\n        *teams: The team names you would like to remove.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.remove_teams(\n            123, \"111-111-111\", \"Team 1\", \"Team 2\"\n        )\n        ```\n    \"\"\"\n    route = routes.REMOVE_TEAMS.compile(id)\n    payload = self._generate_map(verificationCode=verification_code, teamNames=teams)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data)\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.search_competitions","title":"search_competitions  <code>async</code>","text":"<pre><code>search_competitions(\n    *,\n    title: t.Optional[str] = None,\n    type: t.Optional[models.CompetitionType] = None,\n    status: t.Optional[models.CompetitionStatus] = None,\n    metric: t.Optional[enums.Metric] = None,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.Competition]]\n</code></pre> <p>Searches for competitions with the given criteria.</p> <p>Other Parameters:</p> Name Type Description <code>title</code> <code>Optional[str]</code> <p>The optional title of the competition. Defaults to <code>None</code>.</p> <code>type</code> <code>Optional[CompetitionType]</code> <p>The optional <code>CompetitionType</code> filter. Defaults to <code>None</code></p> <code>status</code> <code>Optional[CompetitionStatus]</code> <p>The optional <code>CompetitionStatus</code> filter. Defaults to <code>None</code>.</p> <code>metric</code> <code>Optional[Metric]</code> <p>The optional <code>Metric</code> filter. Defaults to <code>None</code>.</p> <code>limit</code> <code>Optional[int]</code> <p>The maximum number of paginated items to receive. Defaults to <code>None</code> (I think thats 20 items?).</p> <code>offset</code> <code>Optional[int]</code> <p>The page offset for requesting multiple pages. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[Competition]]</code> <p>A <code>Result</code> containing the list of competitions or an error.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.search_competitions(\n    title=\"Sick Competition\",\n    type=wom.CompetitionType.Classic,\n    status=wom.CompetitionStatus.Ongoing,\n    limit=3,\n    offset=1\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def search_competitions(\n    self,\n    *,\n    title: t.Optional[str] = None,\n    type: t.Optional[models.CompetitionType] = None,\n    status: t.Optional[models.CompetitionStatus] = None,\n    metric: t.Optional[enums.Metric] = None,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.Competition]]:\n    \"\"\"Searches for competitions with the given criteria.\n\n    Keyword Args:\n        title: The optional title of the competition. Defaults to\n            `None`.\n\n        type: The optional [`CompetitionType`][wom.CompetitionType]\n            filter. Defaults to `None`\n\n        status: The optional [`CompetitionStatus`]\n            [wom.CompetitionStatus] filter. Defaults to `None`.\n\n        metric: The optional [`Metric`][wom.Metric] filter. Defaults\n            to `None`.\n\n        limit: The maximum number of paginated items to receive.\n            Defaults to `None` (I think thats 20 items?).\n\n        offset: The page offset for requesting multiple pages.\n            Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of competitions\n            or an error.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.search_competitions(\n            title=\"Sick Competition\",\n            type=wom.CompetitionType.Classic,\n            status=wom.CompetitionStatus.Ongoing,\n            limit=3,\n            offset=1\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        title=title,\n        limit=limit,\n        offset=offset,\n        type=type.value if type else None,\n        status=status.value if status else None,\n        metric=metric.value if metric else None,\n    )\n\n    route = routes.SEARCH_COMPETITIONS.compile().with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.Competition])\n</code></pre>"},{"location":"reference/services/#wom.services.CompetitionService.update_outdated_participants","title":"update_outdated_participants  <code>async</code>","text":"<pre><code>update_outdated_participants(\n    id: int, verification_code: str\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Attempts to update all outdated competition participants.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the competition.</p> required <code>verification_code</code> <code>str</code> <p>The verification code for the competition.</p> required <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> <p>Info</p> <p>Participants are outdated when either:</p> <ul> <li> <p>Competition is ending or started within 6h of now and     the player hasn't been updated in over 1h.</p> </li> <li> <p>Player hasn't been updated in over 24h.</p> </li> </ul> <p>Warning</p> <p>This method adds every outdated participant to an \"update queue\", and the WOM servers try to update players in the queue one by one, with a delay in between each. For each player in the queue, an attempt is made to update it up to 3 times, with 30s in between each attempt.</p> <p>Please note that this is dependent on the OSRS hiscores functioning correctly, and therefore this method does NOT guarantee the players will be updated, it only guarantees that an attempt will be made to update them, up to 3 times.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.competitions.update_outdated_participants(\n    123, \"111-111-111\"\n)\n</code></pre> Source code in <code>wom/services/competitions.py</code> <pre><code>async def update_outdated_participants(\n    self, id: int, verification_code: str\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Attempts to update all outdated competition participants.\n\n    Args:\n        id: The ID of the competition.\n\n        verification_code: The verification code for the\n            competition.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    !!! info\n\n        Participants are outdated when either:\n\n        - Competition is ending or started within 6h of now and\n            the player hasn't been updated in over 1h.\n\n        - Player hasn't been updated in over 24h.\n\n    !!! warning\n\n        This method adds every outdated participant to an\n        \"update queue\", and the WOM servers try to update players\n        in the queue one by one, with a delay in between each. For\n        each player in the queue, an attempt is made to update it\n        up to 3 times, with 30s in between each attempt.\n\n        Please note that this is dependent on the OSRS hiscores\n        functioning correctly, and therefore this method does NOT\n        guarantee the players will be updated, it only guarantees\n        that an attempt will be made to update them, up to 3 times.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.competitions.update_outdated_participants(\n            123, \"111-111-111\"\n        )\n        ```\n    \"\"\"\n    route = routes.UPDATE_OUTDATED_PARTICIPANTS.compile(id)\n    payload = self._generate_map(verificationCode=verification_code)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data, predicate=lambda m: \"players are being updated\" in m)\n</code></pre>"},{"location":"reference/services/#wom.services.DeltaService","title":"DeltaService","text":"<p>             Bases: <code>BaseService</code></p> <p>Handles endpoints related to deltas.</p> Source code in <code>wom/services/deltas.py</code> <pre><code>class DeltaService(BaseService):\n    \"\"\"Handles endpoints related to deltas.\"\"\"\n\n    __slots__ = ()\n\n    async def get_global_leaderboards(\n        self,\n        metric: enums.Metric,\n        period: enums.Period,\n        *,\n        player_type: t.Optional[models.PlayerType] = None,\n        player_build: t.Optional[models.PlayerBuild] = None,\n        country: t.Optional[models.Country] = None,\n    ) -&gt; ResultT[t.List[models.DeltaLeaderboardEntry]]:\n        \"\"\"Gets the top global delta leaderboard for a specific\n        metric and period.\n\n        Args:\n            metric: The metric to filter on.\n\n            period: The period of time to filter on.\n\n        Keyword Args:\n            player_type: The optional player type to filter on. Defaults\n                to `None`.\n\n            player_build: The optional player build to filter on.\n                Defaults to `None`.\n\n            country: The optional country to filter on. Defaults to\n                `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing a list of  delta\n                leaderboard entries.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.deltas.get_global_leaderboards(\n                wom.Metric.Attack,\n                wom.Period.Day,\n                country=wom.Country.Gb,\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            metric=metric.value,\n            period=period.value,\n            playerType=player_type.value if player_type else None,\n            playerBuild=player_build.value if player_build else None,\n            country=country.value if country else None,\n        )\n\n        route = routes.GLOBAL_DELTA_LEADERS.compile()\n        data = await self._http.fetch(route.with_params(params))\n        return self._ok_or_err(data, t.List[models.DeltaLeaderboardEntry])\n</code></pre>"},{"location":"reference/services/#wom.services.DeltaService.get_global_leaderboards","title":"get_global_leaderboards  <code>async</code>","text":"<pre><code>get_global_leaderboards(\n    metric: enums.Metric,\n    period: enums.Period,\n    *,\n    player_type: t.Optional[models.PlayerType] = None,\n    player_build: t.Optional[models.PlayerBuild] = None,\n    country: t.Optional[models.Country] = None\n) -&gt; ResultT[t.List[models.DeltaLeaderboardEntry]]\n</code></pre> <p>Gets the top global delta leaderboard for a specific metric and period.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>Metric</code> <p>The metric to filter on.</p> required <code>period</code> <code>Period</code> <p>The period of time to filter on.</p> required <p>Other Parameters:</p> Name Type Description <code>player_type</code> <code>Optional[PlayerType]</code> <p>The optional player type to filter on. Defaults to <code>None</code>.</p> <code>player_build</code> <code>Optional[PlayerBuild]</code> <p>The optional player build to filter on. Defaults to <code>None</code>.</p> <code>country</code> <code>Optional[Country]</code> <p>The optional country to filter on. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[DeltaLeaderboardEntry]]</code> <p>A <code>Result</code> containing a list of  delta leaderboard entries.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.deltas.get_global_leaderboards(\n    wom.Metric.Attack,\n    wom.Period.Day,\n    country=wom.Country.Gb,\n)\n</code></pre> Source code in <code>wom/services/deltas.py</code> <pre><code>async def get_global_leaderboards(\n    self,\n    metric: enums.Metric,\n    period: enums.Period,\n    *,\n    player_type: t.Optional[models.PlayerType] = None,\n    player_build: t.Optional[models.PlayerBuild] = None,\n    country: t.Optional[models.Country] = None,\n) -&gt; ResultT[t.List[models.DeltaLeaderboardEntry]]:\n    \"\"\"Gets the top global delta leaderboard for a specific\n    metric and period.\n\n    Args:\n        metric: The metric to filter on.\n\n        period: The period of time to filter on.\n\n    Keyword Args:\n        player_type: The optional player type to filter on. Defaults\n            to `None`.\n\n        player_build: The optional player build to filter on.\n            Defaults to `None`.\n\n        country: The optional country to filter on. Defaults to\n            `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing a list of  delta\n            leaderboard entries.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.deltas.get_global_leaderboards(\n            wom.Metric.Attack,\n            wom.Period.Day,\n            country=wom.Country.Gb,\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        metric=metric.value,\n        period=period.value,\n        playerType=player_type.value if player_type else None,\n        playerBuild=player_build.value if player_build else None,\n        country=country.value if country else None,\n    )\n\n    route = routes.GLOBAL_DELTA_LEADERS.compile()\n    data = await self._http.fetch(route.with_params(params))\n    return self._ok_or_err(data, t.List[models.DeltaLeaderboardEntry])\n</code></pre>"},{"location":"reference/services/#wom.services.EfficiencyService","title":"EfficiencyService","text":"<p>             Bases: <code>BaseService</code></p> <p>Handles endpoints related to efficiency.</p> Source code in <code>wom/services/efficiency.py</code> <pre><code>class EfficiencyService(BaseService):\n    \"\"\"Handles endpoints related to efficiency.\"\"\"\n\n    __slots__ = ()\n\n    async def get_global_leaderboards(\n        self,\n        metric: enums.Metric = enums.Metric.Ehp,\n        *,\n        player_type: t.Optional[models.PlayerType] = None,\n        player_build: t.Optional[models.PlayerBuild] = None,\n        country: t.Optional[models.Country] = None,\n        both: bool = False,\n    ) -&gt; ResultT[t.List[models.Player]]:\n        \"\"\"Gets the top global efficiency leaderboard.\n\n        Args:\n            metric: The computed metric to filter on. Defaults to `Ehp`,\n                must be one of `Ehp` or `Ehb` if supplied.\n\n        Keyword Args:\n            player_type: The optional player type to filter on. Defaults\n                to `None`.\n\n            player_build: The optional player build to filter on.\n                Defaults to `None`.\n\n            country: The optional country to filter on. Defaults to\n                `None`.\n\n            both: If `True`, request both ehp and ehb computed metric\n                leaderboards. This will override the `metric` if it was\n                provided. Defaults to `False`.\n\n        Returns:\n            A [`Result`][wom.Result] containing a list of the top\n                players.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.efficiency.get_global_leaderboards(\n                player_type=wom.PlayerType.Ironman,\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            playerType=player_type.value if player_type else None,\n            playerBuild=player_build.value if player_build else None,\n            country=country.value if country else None,\n            metric=(\n                metric.value\n                if not both\n                else \"+\".join(sorted((m.value for m in enums.ComputedMetrics), reverse=True))\n            ),\n        )\n\n        route = routes.GLOBAL_EFFICIENCY_LEADERS.compile()\n        data = await self._http.fetch(route.with_params(params))\n        return self._ok_or_err(data, t.List[models.Player])\n</code></pre>"},{"location":"reference/services/#wom.services.EfficiencyService.get_global_leaderboards","title":"get_global_leaderboards  <code>async</code>","text":"<pre><code>get_global_leaderboards(\n    metric: enums.Metric = enums.Metric.Ehp,\n    *,\n    player_type: t.Optional[models.PlayerType] = None,\n    player_build: t.Optional[models.PlayerBuild] = None,\n    country: t.Optional[models.Country] = None,\n    both: bool = False\n) -&gt; ResultT[t.List[models.Player]]\n</code></pre> <p>Gets the top global efficiency leaderboard.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>Metric</code> <p>The computed metric to filter on. Defaults to <code>Ehp</code>, must be one of <code>Ehp</code> or <code>Ehb</code> if supplied.</p> <code>Ehp</code> <p>Other Parameters:</p> Name Type Description <code>player_type</code> <code>Optional[PlayerType]</code> <p>The optional player type to filter on. Defaults to <code>None</code>.</p> <code>player_build</code> <code>Optional[PlayerBuild]</code> <p>The optional player build to filter on. Defaults to <code>None</code>.</p> <code>country</code> <code>Optional[Country]</code> <p>The optional country to filter on. Defaults to <code>None</code>.</p> <code>both</code> <code>bool</code> <p>If <code>True</code>, request both ehp and ehb computed metric leaderboards. This will override the <code>metric</code> if it was provided. Defaults to <code>False</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[Player]]</code> <p>A <code>Result</code> containing a list of the top players.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.efficiency.get_global_leaderboards(\n    player_type=wom.PlayerType.Ironman,\n)\n</code></pre> Source code in <code>wom/services/efficiency.py</code> <pre><code>async def get_global_leaderboards(\n    self,\n    metric: enums.Metric = enums.Metric.Ehp,\n    *,\n    player_type: t.Optional[models.PlayerType] = None,\n    player_build: t.Optional[models.PlayerBuild] = None,\n    country: t.Optional[models.Country] = None,\n    both: bool = False,\n) -&gt; ResultT[t.List[models.Player]]:\n    \"\"\"Gets the top global efficiency leaderboard.\n\n    Args:\n        metric: The computed metric to filter on. Defaults to `Ehp`,\n            must be one of `Ehp` or `Ehb` if supplied.\n\n    Keyword Args:\n        player_type: The optional player type to filter on. Defaults\n            to `None`.\n\n        player_build: The optional player build to filter on.\n            Defaults to `None`.\n\n        country: The optional country to filter on. Defaults to\n            `None`.\n\n        both: If `True`, request both ehp and ehb computed metric\n            leaderboards. This will override the `metric` if it was\n            provided. Defaults to `False`.\n\n    Returns:\n        A [`Result`][wom.Result] containing a list of the top\n            players.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.efficiency.get_global_leaderboards(\n            player_type=wom.PlayerType.Ironman,\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        playerType=player_type.value if player_type else None,\n        playerBuild=player_build.value if player_build else None,\n        country=country.value if country else None,\n        metric=(\n            metric.value\n            if not both\n            else \"+\".join(sorted((m.value for m in enums.ComputedMetrics), reverse=True))\n        ),\n    )\n\n    route = routes.GLOBAL_EFFICIENCY_LEADERS.compile()\n    data = await self._http.fetch(route.with_params(params))\n    return self._ok_or_err(data, t.List[models.Player])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService","title":"GroupService","text":"<p>             Bases: <code>BaseService</code></p> <p>Handles endpoints related to groups.</p> Source code in <code>wom/services/groups.py</code> <pre><code>class GroupService(BaseService):\n    \"\"\"Handles endpoints related to groups.\"\"\"\n\n    __slots__ = ()\n\n    def _prepare_member_fragments(\n        self, members: t.Iterable[t.Union[str, models.GroupMemberFragment]]\n    ) -&gt; tuple[t.Dict[str, t.Any], ...]:\n        return tuple(\n            {k: str(v) for k, v in m.to_dict().items() if v}\n            for m in self._parse_member_fragments(members)\n        )\n\n    def _parse_member_fragments(\n        self, members: t.Iterable[t.Union[str, models.GroupMemberFragment]]\n    ) -&gt; t.Generator[models.GroupMemberFragment, None, None]:\n        return (models.GroupMemberFragment(m, None) if isinstance(m, str) else m for m in members)\n\n    async def search_groups(\n        self,\n        name: t.Optional[str] = None,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n    ) -&gt; ResultT[t.List[models.Group]]:\n        \"\"\"Searches for groups that at least partially match the given\n        name.\n\n        Args:\n            name: The group name to search for.\n\n            limit: The pagination limit.\n\n            offset: The pagination offset.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of matching\n                groups.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.search_groups(\"Some group\", limit=3)\n            ```\n        \"\"\"\n        params = self._generate_map(name=name, limit=limit, offset=offset)\n        route = routes.SEARCH_GROUPS.compile().with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.Group])\n\n    async def get_details(self, id: int) -&gt; ResultT[models.GroupDetail]:\n        \"\"\"Gets the details for the given group id.\n\n        Args:\n            id: The group ID to get details for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the group details.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_details(1234)\n            ```\n        \"\"\"\n        route = routes.GROUP_DETAILS.compile(id)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, models.GroupDetail)\n\n    async def create_group(\n        self,\n        name: str,\n        *members: t.Union[str, models.GroupMemberFragment],\n        clan_chat: t.Optional[str] = None,\n        description: t.Optional[str] = None,\n        homeworld: t.Optional[int] = None,\n    ) -&gt; ResultT[models.CreatedGroupDetail]:\n        \"\"\"Creates a new group.\n\n        Args:\n            name: The name for the group.\n\n            *members: The optional members to add to the group.\n\n        Keyword Args:\n            clan_chat: The optional clan chat for the group. Defaults to\n                `None`.\n\n            description: The optional group description. Defaults to\n                `None`.\n\n            homeworld: The optional homeworld for the group. Defaults to\n                `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the created group details.\n\n        !!! note\n\n            A mixture of strings and GroupMemberFragments can be passed for\n            members. If a string is passed, no role will be added for that\n            member.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.create_group(\n                \"My new group\",\n                wom.GroupMemberFragment(\"Jonxslays\", wom.GroupRole.Owner),\n                \"Faabvk\",\n                \"psikoi\",\n                \"rro\",\n                description=\"The most epic group.\"\n            )\n            ```\n        \"\"\"\n        payload = self._generate_map(\n            name=name,\n            clanChat=clan_chat,\n            homeworld=homeworld,\n            description=description,\n            members=self._prepare_member_fragments(members),\n        )\n\n        route = routes.CREATE_GROUP.compile()\n        data = await self._http.fetch(route, payload=payload)\n        return self._ok_or_err(data, models.CreatedGroupDetail)\n\n    async def edit_group(\n        self,\n        id: int,\n        verification_code: str,\n        *,\n        name: t.Optional[str] = None,\n        members: t.Optional[t.Iterable[t.Union[str, models.GroupMemberFragment]]] = None,\n        clan_chat: t.Optional[str] = None,\n        description: t.Optional[str] = None,\n        homeworld: t.Optional[int] = None,\n        social_links: t.Optional[models.SocialLinks] = None,\n    ) -&gt; ResultT[models.GroupDetail]:\n        \"\"\"Edits an existing group.\n\n        Args:\n            id: The ID of the group.\n\n            verification_code: The group verification code.\n\n        Keyword Args:\n            name: The optional new name for the group. Defaults to\n                `None`.\n\n            members: The optional iterable of members to replace the\n                existing group members with. Defaults to `None`.\n\n            clan_chat: The optional new clan chat for the group.\n                Defaults to `None`.\n\n            description: The optional new group description. Defaults to\n                `None`.\n\n            homeworld: The optional new homeworld for the group.\n                Defaults to `None`.\n\n            social_links: The optional new social links for the group.\n                Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the group details.\n\n        !!! warning\n\n            The members list provided will completely replace the\n            existing members. If you want to add members, see\n            [`add_members()`][wom.GroupService.add_members]\n\n        !!! note\n\n             A mixture of strings and GroupMemberFragments can be passed for\n             members. If a string is passed, no role will be added for that\n             member.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.edit_group(\n                123,\n                \"111-111-111\",\n                name=\"My new group name\",\n                members=[\n                    wom.GroupMemberFragment(\"Jonxslays\", wom.GroupRole.Owner),\n                    \"Faabvk\",\n                ],\n                description=\"Some new description.\"\n            )\n            ```\n        \"\"\"\n        payload = self._generate_map(\n            name=name,\n            clanChat=clan_chat,\n            homeworld=homeworld,\n            description=description,\n            verificationCode=verification_code,\n            members=self._prepare_member_fragments(members) if members else None,\n            socialLinks=social_links.to_dict() if social_links else None,\n        )\n\n        route = routes.EDIT_GROUP.compile(id)\n        data = await self._http.fetch(route, payload=payload)\n        return self._ok_or_err(data, models.GroupDetail)\n\n    async def delete_group(\n        self, id: int, verification_code: str\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Deletes an existing group.\n\n        Args:\n            id: The ID of the group.\n\n            verification_code: The group verification code.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        !!! warning\n\n            This action is irreversible.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.delete_group(123, \"111-111-111\")\n            ```\n        \"\"\"\n        route = routes.DELETE_GROUP.compile(id)\n        payload = self._generate_map(verificationCode=verification_code)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data)\n\n    async def add_members(\n        self, id: int, verification_code: str, *members: t.Union[str, models.GroupMemberFragment]\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Adds members to an existing group.\n\n        Args:\n            id: The ID of the group.\n\n            verification_code: The group verification code.\n\n            *members: The members to add to the group.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        !!! note\n\n             A mixture of strings and GroupMemberFragments can be passed for\n             members. If a string is passed, no role will be added for that\n             member.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.add_members(\n                123,\n                \"111-111-111\",\n                wom.GroupMemberFragment(\n                    \"Jonxslays\", wom.GroupRole.Administrator\n                ),\n                \"Zezima\",\n                \"Psikoi\",\n            )\n            ```\n        \"\"\"\n        payload = self._generate_map(\n            verificationCode=verification_code,\n            members=self._prepare_member_fragments(members),\n        )\n\n        route = routes.ADD_MEMBERS.compile(id)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data)\n\n    async def remove_members(\n        self, id: int, verification_code: str, *members: str\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Removes members from an existing group.\n\n        Args:\n            id: The ID of the group.\n\n            verification_code: The group verification code.\n\n            *members: The usernames of members to remove from the group.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.remove_members(\n                123,\n                \"111-111-111\",\n                \"Jonxslays\",\n                \"Zezima\",\n            )\n            ```\n        \"\"\"\n        route = routes.REMOVE_MEMBERS.compile(id)\n        payload = self._generate_map(verificationCode=verification_code, members=members)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data)\n\n    async def change_member_role(\n        self, id: int, verification_code: str, username: str, role: models.GroupRole\n    ) -&gt; ResultT[models.GroupMembership]:\n        \"\"\"Changes the role for a member in an existing group.\n\n        Args:\n            id: The ID of the group.\n\n            verification_code: The group verification code.\n\n            username: The username of the player to update.\n\n            role: The players new group role.\n\n        Returns:\n            A [`Result`][wom.Result] containing the players group\n                membership.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.change_member_role(\n                123,\n                \"111-111-111\",\n                \"Jonxslays\",\n                wom.GroupRole.Admiral\n            )\n            ```\n        \"\"\"\n        payload = self._generate_map(\n            verificationCode=verification_code, username=username, role=role.value\n        )\n\n        route = routes.CHANGE_MEMBER_ROLE.compile(id)\n        data = await self._http.fetch(route, payload=payload)\n        return self._ok_or_err(data, models.GroupMembership)\n\n    async def update_outdated_members(\n        self, id: int, verification_code: str\n    ) -&gt; ResultT[models.HttpSuccessResponse]:\n        \"\"\"Attempts to update all outdated group members.\n\n        Args:\n            id: The ID of the group.\n\n            verification_code: The verification code for the group.\n\n        Returns:\n            A [`Result`][wom.Result] containing the success response\n                message.\n\n        !!! info\n\n            Group members are considered outdated when they haven't been\n            updated in over 24h.\n\n        !!! warning\n\n            This method adds every outdated member to an \"update queue\",\n            and the WOM servers try to update players in the queue one\n            by one, with a delay in between each. For each player in the\n            queue, an attempt is made to update it up to 3 times, with\n            30s in between each attempt.\n\n            Please note that this is dependent on the OSRS hiscores\n            functioning correctly, and therefore this method does NOT\n            guarantee the players will be updated, it only guarantees\n            that an attempt will be made to update them, up to 3 times.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.groups.update_outdated_members(\n                123, \"111-111-111\"\n            )\n            ```\n        \"\"\"\n        route = routes.UPDATE_OUTDATED_MEMBERS.compile(id)\n        payload = self._generate_map(verificationCode=verification_code)\n        data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n        return self._success_or_err(data, predicate=lambda m: \"players are being updated\" in m)\n\n    async def get_competitions(\n        self, id: int, *, limit: t.Optional[int] = None, offset: t.Optional[int] = None\n    ) -&gt; ResultT[t.List[models.Competition]]:\n        \"\"\"Gets competitions for a given group.\n\n        Args:\n            id: The ID of the group.\n\n        Keyword Args:\n            limit: The optional pagination limit. Defaults to `None`.\n\n            offset: The optional pagination offset. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of\n                competitions.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_competitions(123, limit=10)\n            ```\n        \"\"\"\n        params = self._generate_map(limit=limit, offset=offset)\n        route = routes.GROUP_COMPETITIONS.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.Competition])\n\n    async def get_gains(\n        self,\n        id: int,\n        metric: enums.Metric,\n        *,\n        period: t.Optional[enums.Period] = None,\n        start_date: t.Optional[datetime] = None,\n        end_date: t.Optional[datetime] = None,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n    ) -&gt; ResultT[t.List[models.GroupMemberGains]]:\n        \"\"\"Gets the gains for a group over a particular time frame.\n\n        Args:\n            id: The ID of the group.\n\n            metric: The metric to filter on.\n\n        Keyword Args:\n            period: The optional period of time to get gains for.\n                Defaults to `None`.\n\n            start_date: The minimum date to get the gains from. Defaults\n                to `None`.\n\n            end_date: The maximum date to get the gains from. Defaults\n                to `None`.\n\n            limit: The optional pagination limit. Defaults to `None`.\n\n            offset: The optional pagination offset. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of delta\n                leaderboard entries.\n\n        !!! info\n\n            You must pass one of (`period`) or (`start_date` +\n            `end_date`), but not both.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_gains(\n                123, wom.Metric.Zulrah, limit=10\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            limit=limit,\n            offset=offset,\n            metric=metric.value,\n            period=period.value if period else None,\n            endDate=end_date.isoformat() if end_date else None,\n            startDate=start_date.isoformat() if start_date else None,\n        )\n\n        route = routes.GROUP_GAINS.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.GroupMemberGains])\n\n    async def get_achievements(\n        self,\n        id: int,\n        *,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n    ) -&gt; ResultT[t.List[models.Achievement]]:\n        \"\"\"Gets the achievements for the group.\n\n        Args:\n            id: The ID of the group.\n\n        Keyword Args:\n            limit: The optional pagination limit. Defaults to `None`.\n\n            offset: The optional pagination offset. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of achievements.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_achievements(123, limit=10)\n            ```\n        \"\"\"\n        params = self._generate_map(limit=limit, offset=offset)\n        route = routes.GROUP_ACHIEVEMENTS.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.Achievement])\n\n    async def get_records(\n        self,\n        id: int,\n        metric: enums.Metric,\n        period: enums.Period,\n        *,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n    ) -&gt; ResultT[t.List[models.RecordLeaderboardEntry]]:\n        \"\"\"Gets the records held by players in the group.\n\n        Args:\n            id: The ID of the group.\n\n            metric: The metric to filter on.\n\n            period: The period of time to get records for.\n\n        Keyword Args:\n            limit: The optional pagination limit. Defaults to `None`.\n\n            offset: The optional pagination offset. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of record\n                leaderboard entries.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_records(\n                123, wom.Metric.Zulrah, wom.Period.Day, limit=3\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            limit=limit,\n            offset=offset,\n            metric=metric.value,\n            period=period.value,\n        )\n\n        route = routes.GROUP_RECORDS.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.RecordLeaderboardEntry])\n\n    async def get_hiscores(\n        self,\n        id: int,\n        metric: enums.Metric,\n        *,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n    ) -&gt; ResultT[t.List[models.GroupHiscoresEntry]]:\n        \"\"\"Gets the hiscores for the group.\n\n        Args:\n            id: The ID of the group.\n\n            metric: The metric to filter on.\n\n        Keyword Args:\n            limit: The optional pagination limit. Defaults to `None`.\n\n            offset: The optional pagination offset. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of hiscores\n                entries.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_hiscores(\n                123, wom.Metric.Runecrafting, limit=10\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(limit=limit, offset=offset, metric=metric.value)\n        route = routes.GROUP_HISCORES.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.GroupHiscoresEntry])\n\n    async def get_name_changes(\n        self, id: int, *, limit: t.Optional[int] = None, offset: t.Optional[int] = None\n    ) -&gt; ResultT[t.List[models.NameChange]]:\n        \"\"\"Gets the past name changes for the group.\n\n        Args:\n            id: The ID of the group.\n\n        Keyword Args:\n            limit: The optional pagination limit. Defaults to `None`.\n\n            offset: The optional pagination offset. Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list name changes.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_name_changes(123, limit=10)\n            ```\n        \"\"\"\n        params = self._generate_map(limit=limit, offset=offset)\n        route = routes.GROUP_NAME_CHANGES.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.NameChange])\n\n    async def get_statistics(self, id: int) -&gt; ResultT[models.GroupStatistics]:\n        \"\"\"Gets the statistics for the group.\n\n        Args:\n            id: The ID of the group.\n\n        Returns:\n            A [`Result`][wom.Result] containing the statistics.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_statistics(123)\n            ```\n        \"\"\"\n        route = routes.GROUP_STATISTICS.compile(id)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, models.GroupStatistics)\n\n    async def get_activity(\n        self,\n        id: int,\n        *,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n    ) -&gt; ResultT[t.List[models.GroupActivity]]:\n        \"\"\"Gets the activity for the group. This is a paginated endpoint.\n\n        Args:\n            id: The ID of the group to fetch activity for.\n\n        Keyword Args:\n            limit: The pagination limit.\n\n            offset: The pagination offset.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of activities.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            await client.groups.get_activity(69, limit=5)\n            ```\n        \"\"\"\n        params = self._generate_map(limit=limit, offset=offset)\n        route = routes.GROUP_ACTIVITY.compile(id).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.GroupActivity])\n\n    async def get_members_csv(self, id: int) -&gt; ResultT[str]:\n        \"\"\"Gets members in this group in CSV format.\n\n        Args:\n            id: The ID of the group.\n\n        Returns:\n            A [`Result`][wom.Result] containing the CSV string.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.groups.get_members_csv(123)\n            ```\n        \"\"\"\n        route = routes.GROUP_MEMBERS_CSV.compile(id)\n        data = await self._http.fetch(route)\n\n        if isinstance(data, models.HttpErrorResponse):\n            return result.Err(data)\n\n        return result.Ok(data.decode())\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.add_members","title":"add_members  <code>async</code>","text":"<pre><code>add_members(\n    id: int,\n    verification_code: str,\n    *members: t.Union[str, models.GroupMemberFragment]\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Adds members to an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>verification_code</code> <code>str</code> <p>The group verification code.</p> required <code>*members</code> <code>Union[str, GroupMemberFragment]</code> <p>The members to add to the group.</p> <code>()</code> <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> <p>Note</p> <p>A mixture of strings and GroupMemberFragments can be passed for  members. If a string is passed, no role will be added for that  member.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.add_members(\n    123,\n    \"111-111-111\",\n    wom.GroupMemberFragment(\n        \"Jonxslays\", wom.GroupRole.Administrator\n    ),\n    \"Zezima\",\n    \"Psikoi\",\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def add_members(\n    self, id: int, verification_code: str, *members: t.Union[str, models.GroupMemberFragment]\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Adds members to an existing group.\n\n    Args:\n        id: The ID of the group.\n\n        verification_code: The group verification code.\n\n        *members: The members to add to the group.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    !!! note\n\n         A mixture of strings and GroupMemberFragments can be passed for\n         members. If a string is passed, no role will be added for that\n         member.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.add_members(\n            123,\n            \"111-111-111\",\n            wom.GroupMemberFragment(\n                \"Jonxslays\", wom.GroupRole.Administrator\n            ),\n            \"Zezima\",\n            \"Psikoi\",\n        )\n        ```\n    \"\"\"\n    payload = self._generate_map(\n        verificationCode=verification_code,\n        members=self._prepare_member_fragments(members),\n    )\n\n    route = routes.ADD_MEMBERS.compile(id)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data)\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.change_member_role","title":"change_member_role  <code>async</code>","text":"<pre><code>change_member_role(\n    id: int,\n    verification_code: str,\n    username: str,\n    role: models.GroupRole,\n) -&gt; ResultT[models.GroupMembership]\n</code></pre> <p>Changes the role for a member in an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>verification_code</code> <code>str</code> <p>The group verification code.</p> required <code>username</code> <code>str</code> <p>The username of the player to update.</p> required <code>role</code> <code>GroupRole</code> <p>The players new group role.</p> required <p>Returns:</p> Type Description <code>ResultT[GroupMembership]</code> <p>A <code>Result</code> containing the players group membership.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.change_member_role(\n    123,\n    \"111-111-111\",\n    \"Jonxslays\",\n    wom.GroupRole.Admiral\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def change_member_role(\n    self, id: int, verification_code: str, username: str, role: models.GroupRole\n) -&gt; ResultT[models.GroupMembership]:\n    \"\"\"Changes the role for a member in an existing group.\n\n    Args:\n        id: The ID of the group.\n\n        verification_code: The group verification code.\n\n        username: The username of the player to update.\n\n        role: The players new group role.\n\n    Returns:\n        A [`Result`][wom.Result] containing the players group\n            membership.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.change_member_role(\n            123,\n            \"111-111-111\",\n            \"Jonxslays\",\n            wom.GroupRole.Admiral\n        )\n        ```\n    \"\"\"\n    payload = self._generate_map(\n        verificationCode=verification_code, username=username, role=role.value\n    )\n\n    route = routes.CHANGE_MEMBER_ROLE.compile(id)\n    data = await self._http.fetch(route, payload=payload)\n    return self._ok_or_err(data, models.GroupMembership)\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.create_group","title":"create_group  <code>async</code>","text":"<pre><code>create_group(\n    name: str,\n    *members: t.Union[str, models.GroupMemberFragment],\n    clan_chat: t.Optional[str] = None,\n    description: t.Optional[str] = None,\n    homeworld: t.Optional[int] = None\n) -&gt; ResultT[models.CreatedGroupDetail]\n</code></pre> <p>Creates a new group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the group.</p> required <code>*members</code> <code>Union[str, GroupMemberFragment]</code> <p>The optional members to add to the group.</p> <code>()</code> <p>Other Parameters:</p> Name Type Description <code>clan_chat</code> <code>Optional[str]</code> <p>The optional clan chat for the group. Defaults to <code>None</code>.</p> <code>description</code> <code>Optional[str]</code> <p>The optional group description. Defaults to <code>None</code>.</p> <code>homeworld</code> <code>Optional[int]</code> <p>The optional homeworld for the group. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[CreatedGroupDetail]</code> <p>A <code>Result</code> containing the created group details.</p> <p>Note</p> <p>A mixture of strings and GroupMemberFragments can be passed for members. If a string is passed, no role will be added for that member.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.create_group(\n    \"My new group\",\n    wom.GroupMemberFragment(\"Jonxslays\", wom.GroupRole.Owner),\n    \"Faabvk\",\n    \"psikoi\",\n    \"rro\",\n    description=\"The most epic group.\"\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def create_group(\n    self,\n    name: str,\n    *members: t.Union[str, models.GroupMemberFragment],\n    clan_chat: t.Optional[str] = None,\n    description: t.Optional[str] = None,\n    homeworld: t.Optional[int] = None,\n) -&gt; ResultT[models.CreatedGroupDetail]:\n    \"\"\"Creates a new group.\n\n    Args:\n        name: The name for the group.\n\n        *members: The optional members to add to the group.\n\n    Keyword Args:\n        clan_chat: The optional clan chat for the group. Defaults to\n            `None`.\n\n        description: The optional group description. Defaults to\n            `None`.\n\n        homeworld: The optional homeworld for the group. Defaults to\n            `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the created group details.\n\n    !!! note\n\n        A mixture of strings and GroupMemberFragments can be passed for\n        members. If a string is passed, no role will be added for that\n        member.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.create_group(\n            \"My new group\",\n            wom.GroupMemberFragment(\"Jonxslays\", wom.GroupRole.Owner),\n            \"Faabvk\",\n            \"psikoi\",\n            \"rro\",\n            description=\"The most epic group.\"\n        )\n        ```\n    \"\"\"\n    payload = self._generate_map(\n        name=name,\n        clanChat=clan_chat,\n        homeworld=homeworld,\n        description=description,\n        members=self._prepare_member_fragments(members),\n    )\n\n    route = routes.CREATE_GROUP.compile()\n    data = await self._http.fetch(route, payload=payload)\n    return self._ok_or_err(data, models.CreatedGroupDetail)\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.delete_group","title":"delete_group  <code>async</code>","text":"<pre><code>delete_group(\n    id: int, verification_code: str\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Deletes an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>verification_code</code> <code>str</code> <p>The group verification code.</p> required <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> <p>Warning</p> <p>This action is irreversible.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.delete_group(123, \"111-111-111\")\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def delete_group(\n    self, id: int, verification_code: str\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Deletes an existing group.\n\n    Args:\n        id: The ID of the group.\n\n        verification_code: The group verification code.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    !!! warning\n\n        This action is irreversible.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.delete_group(123, \"111-111-111\")\n        ```\n    \"\"\"\n    route = routes.DELETE_GROUP.compile(id)\n    payload = self._generate_map(verificationCode=verification_code)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data)\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.edit_group","title":"edit_group  <code>async</code>","text":"<pre><code>edit_group(\n    id: int,\n    verification_code: str,\n    *,\n    name: t.Optional[str] = None,\n    members: t.Optional[\n        t.Iterable[t.Union[str, models.GroupMemberFragment]]\n    ] = None,\n    clan_chat: t.Optional[str] = None,\n    description: t.Optional[str] = None,\n    homeworld: t.Optional[int] = None,\n    social_links: t.Optional[models.SocialLinks] = None\n) -&gt; ResultT[models.GroupDetail]\n</code></pre> <p>Edits an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>verification_code</code> <code>str</code> <p>The group verification code.</p> required <p>Other Parameters:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>The optional new name for the group. Defaults to <code>None</code>.</p> <code>members</code> <code>Optional[Iterable[Union[str, GroupMemberFragment]]]</code> <p>The optional iterable of members to replace the existing group members with. Defaults to <code>None</code>.</p> <code>clan_chat</code> <code>Optional[str]</code> <p>The optional new clan chat for the group. Defaults to <code>None</code>.</p> <code>description</code> <code>Optional[str]</code> <p>The optional new group description. Defaults to <code>None</code>.</p> <code>homeworld</code> <code>Optional[int]</code> <p>The optional new homeworld for the group. Defaults to <code>None</code>.</p> <code>social_links</code> <code>Optional[SocialLinks]</code> <p>The optional new social links for the group. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[GroupDetail]</code> <p>A <code>Result</code> containing the group details.</p> <p>Warning</p> <p>The members list provided will completely replace the existing members. If you want to add members, see <code>add_members()</code></p> <p>Note</p> <p>A mixture of strings and GroupMemberFragments can be passed for  members. If a string is passed, no role will be added for that  member.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.edit_group(\n    123,\n    \"111-111-111\",\n    name=\"My new group name\",\n    members=[\n        wom.GroupMemberFragment(\"Jonxslays\", wom.GroupRole.Owner),\n        \"Faabvk\",\n    ],\n    description=\"Some new description.\"\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def edit_group(\n    self,\n    id: int,\n    verification_code: str,\n    *,\n    name: t.Optional[str] = None,\n    members: t.Optional[t.Iterable[t.Union[str, models.GroupMemberFragment]]] = None,\n    clan_chat: t.Optional[str] = None,\n    description: t.Optional[str] = None,\n    homeworld: t.Optional[int] = None,\n    social_links: t.Optional[models.SocialLinks] = None,\n) -&gt; ResultT[models.GroupDetail]:\n    \"\"\"Edits an existing group.\n\n    Args:\n        id: The ID of the group.\n\n        verification_code: The group verification code.\n\n    Keyword Args:\n        name: The optional new name for the group. Defaults to\n            `None`.\n\n        members: The optional iterable of members to replace the\n            existing group members with. Defaults to `None`.\n\n        clan_chat: The optional new clan chat for the group.\n            Defaults to `None`.\n\n        description: The optional new group description. Defaults to\n            `None`.\n\n        homeworld: The optional new homeworld for the group.\n            Defaults to `None`.\n\n        social_links: The optional new social links for the group.\n            Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the group details.\n\n    !!! warning\n\n        The members list provided will completely replace the\n        existing members. If you want to add members, see\n        [`add_members()`][wom.GroupService.add_members]\n\n    !!! note\n\n         A mixture of strings and GroupMemberFragments can be passed for\n         members. If a string is passed, no role will be added for that\n         member.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.edit_group(\n            123,\n            \"111-111-111\",\n            name=\"My new group name\",\n            members=[\n                wom.GroupMemberFragment(\"Jonxslays\", wom.GroupRole.Owner),\n                \"Faabvk\",\n            ],\n            description=\"Some new description.\"\n        )\n        ```\n    \"\"\"\n    payload = self._generate_map(\n        name=name,\n        clanChat=clan_chat,\n        homeworld=homeworld,\n        description=description,\n        verificationCode=verification_code,\n        members=self._prepare_member_fragments(members) if members else None,\n        socialLinks=social_links.to_dict() if social_links else None,\n    )\n\n    route = routes.EDIT_GROUP.compile(id)\n    data = await self._http.fetch(route, payload=payload)\n    return self._ok_or_err(data, models.GroupDetail)\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_achievements","title":"get_achievements  <code>async</code>","text":"<pre><code>get_achievements(\n    id: int,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.Achievement]]\n</code></pre> <p>Gets the achievements for the group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The optional pagination limit. Defaults to <code>None</code>.</p> <code>offset</code> <code>Optional[int]</code> <p>The optional pagination offset. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[Achievement]]</code> <p>A <code>Result</code> containing the list of achievements.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_achievements(123, limit=10)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_achievements(\n    self,\n    id: int,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.Achievement]]:\n    \"\"\"Gets the achievements for the group.\n\n    Args:\n        id: The ID of the group.\n\n    Keyword Args:\n        limit: The optional pagination limit. Defaults to `None`.\n\n        offset: The optional pagination offset. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of achievements.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_achievements(123, limit=10)\n        ```\n    \"\"\"\n    params = self._generate_map(limit=limit, offset=offset)\n    route = routes.GROUP_ACHIEVEMENTS.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.Achievement])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_activity","title":"get_activity  <code>async</code>","text":"<pre><code>get_activity(\n    id: int,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.GroupActivity]]\n</code></pre> <p>Gets the activity for the group. This is a paginated endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group to fetch activity for.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The pagination limit.</p> <code>offset</code> <code>Optional[int]</code> <p>The pagination offset.</p> <p>Returns:</p> Type Description <code>ResultT[List[GroupActivity]]</code> <p>A <code>Result</code> containing the list of activities.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_activity(69, limit=5)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_activity(\n    self,\n    id: int,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.GroupActivity]]:\n    \"\"\"Gets the activity for the group. This is a paginated endpoint.\n\n    Args:\n        id: The ID of the group to fetch activity for.\n\n    Keyword Args:\n        limit: The pagination limit.\n\n        offset: The pagination offset.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of activities.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_activity(69, limit=5)\n        ```\n    \"\"\"\n    params = self._generate_map(limit=limit, offset=offset)\n    route = routes.GROUP_ACTIVITY.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.GroupActivity])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_competitions","title":"get_competitions  <code>async</code>","text":"<pre><code>get_competitions(\n    id: int,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.Competition]]\n</code></pre> <p>Gets competitions for a given group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The optional pagination limit. Defaults to <code>None</code>.</p> <code>offset</code> <code>Optional[int]</code> <p>The optional pagination offset. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[Competition]]</code> <p>A <code>Result</code> containing the list of competitions.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_competitions(123, limit=10)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_competitions(\n    self, id: int, *, limit: t.Optional[int] = None, offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.Competition]]:\n    \"\"\"Gets competitions for a given group.\n\n    Args:\n        id: The ID of the group.\n\n    Keyword Args:\n        limit: The optional pagination limit. Defaults to `None`.\n\n        offset: The optional pagination offset. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of\n            competitions.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_competitions(123, limit=10)\n        ```\n    \"\"\"\n    params = self._generate_map(limit=limit, offset=offset)\n    route = routes.GROUP_COMPETITIONS.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.Competition])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_details","title":"get_details  <code>async</code>","text":"<pre><code>get_details(id: int) -&gt; ResultT[models.GroupDetail]\n</code></pre> <p>Gets the details for the given group id.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The group ID to get details for.</p> required <p>Returns:</p> Type Description <code>ResultT[GroupDetail]</code> <p>A <code>Result</code> containing the group details.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_details(1234)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_details(self, id: int) -&gt; ResultT[models.GroupDetail]:\n    \"\"\"Gets the details for the given group id.\n\n    Args:\n        id: The group ID to get details for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the group details.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_details(1234)\n        ```\n    \"\"\"\n    route = routes.GROUP_DETAILS.compile(id)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, models.GroupDetail)\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_gains","title":"get_gains  <code>async</code>","text":"<pre><code>get_gains(\n    id: int,\n    metric: enums.Metric,\n    *,\n    period: t.Optional[enums.Period] = None,\n    start_date: t.Optional[datetime] = None,\n    end_date: t.Optional[datetime] = None,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.GroupMemberGains]]\n</code></pre> <p>Gets the gains for a group over a particular time frame.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>metric</code> <code>Metric</code> <p>The metric to filter on.</p> required <p>Other Parameters:</p> Name Type Description <code>period</code> <code>Optional[Period]</code> <p>The optional period of time to get gains for. Defaults to <code>None</code>.</p> <code>start_date</code> <code>Optional[datetime]</code> <p>The minimum date to get the gains from. Defaults to <code>None</code>.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>The maximum date to get the gains from. Defaults to <code>None</code>.</p> <code>limit</code> <code>Optional[int]</code> <p>The optional pagination limit. Defaults to <code>None</code>.</p> <code>offset</code> <code>Optional[int]</code> <p>The optional pagination offset. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[GroupMemberGains]]</code> <p>A <code>Result</code> containing the list of delta leaderboard entries.</p> <p>Info</p> <p>You must pass one of (<code>period</code>) or (<code>start_date</code> + <code>end_date</code>), but not both.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_gains(\n    123, wom.Metric.Zulrah, limit=10\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_gains(\n    self,\n    id: int,\n    metric: enums.Metric,\n    *,\n    period: t.Optional[enums.Period] = None,\n    start_date: t.Optional[datetime] = None,\n    end_date: t.Optional[datetime] = None,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.GroupMemberGains]]:\n    \"\"\"Gets the gains for a group over a particular time frame.\n\n    Args:\n        id: The ID of the group.\n\n        metric: The metric to filter on.\n\n    Keyword Args:\n        period: The optional period of time to get gains for.\n            Defaults to `None`.\n\n        start_date: The minimum date to get the gains from. Defaults\n            to `None`.\n\n        end_date: The maximum date to get the gains from. Defaults\n            to `None`.\n\n        limit: The optional pagination limit. Defaults to `None`.\n\n        offset: The optional pagination offset. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of delta\n            leaderboard entries.\n\n    !!! info\n\n        You must pass one of (`period`) or (`start_date` +\n        `end_date`), but not both.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_gains(\n            123, wom.Metric.Zulrah, limit=10\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        limit=limit,\n        offset=offset,\n        metric=metric.value,\n        period=period.value if period else None,\n        endDate=end_date.isoformat() if end_date else None,\n        startDate=start_date.isoformat() if start_date else None,\n    )\n\n    route = routes.GROUP_GAINS.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.GroupMemberGains])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_hiscores","title":"get_hiscores  <code>async</code>","text":"<pre><code>get_hiscores(\n    id: int,\n    metric: enums.Metric,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.GroupHiscoresEntry]]\n</code></pre> <p>Gets the hiscores for the group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>metric</code> <code>Metric</code> <p>The metric to filter on.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The optional pagination limit. Defaults to <code>None</code>.</p> <code>offset</code> <code>Optional[int]</code> <p>The optional pagination offset. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[GroupHiscoresEntry]]</code> <p>A <code>Result</code> containing the list of hiscores entries.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_hiscores(\n    123, wom.Metric.Runecrafting, limit=10\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_hiscores(\n    self,\n    id: int,\n    metric: enums.Metric,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.GroupHiscoresEntry]]:\n    \"\"\"Gets the hiscores for the group.\n\n    Args:\n        id: The ID of the group.\n\n        metric: The metric to filter on.\n\n    Keyword Args:\n        limit: The optional pagination limit. Defaults to `None`.\n\n        offset: The optional pagination offset. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of hiscores\n            entries.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_hiscores(\n            123, wom.Metric.Runecrafting, limit=10\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(limit=limit, offset=offset, metric=metric.value)\n    route = routes.GROUP_HISCORES.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.GroupHiscoresEntry])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_members_csv","title":"get_members_csv  <code>async</code>","text":"<pre><code>get_members_csv(id: int) -&gt; ResultT[str]\n</code></pre> <p>Gets members in this group in CSV format.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <p>Returns:</p> Type Description <code>ResultT[str]</code> <p>A <code>Result</code> containing the CSV string.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.groups.get_members_csv(123)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_members_csv(self, id: int) -&gt; ResultT[str]:\n    \"\"\"Gets members in this group in CSV format.\n\n    Args:\n        id: The ID of the group.\n\n    Returns:\n        A [`Result`][wom.Result] containing the CSV string.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.groups.get_members_csv(123)\n        ```\n    \"\"\"\n    route = routes.GROUP_MEMBERS_CSV.compile(id)\n    data = await self._http.fetch(route)\n\n    if isinstance(data, models.HttpErrorResponse):\n        return result.Err(data)\n\n    return result.Ok(data.decode())\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_name_changes","title":"get_name_changes  <code>async</code>","text":"<pre><code>get_name_changes(\n    id: int,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.NameChange]]\n</code></pre> <p>Gets the past name changes for the group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The optional pagination limit. Defaults to <code>None</code>.</p> <code>offset</code> <code>Optional[int]</code> <p>The optional pagination offset. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[NameChange]]</code> <p>A <code>Result</code> containing the list name changes.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_name_changes(123, limit=10)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_name_changes(\n    self, id: int, *, limit: t.Optional[int] = None, offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.NameChange]]:\n    \"\"\"Gets the past name changes for the group.\n\n    Args:\n        id: The ID of the group.\n\n    Keyword Args:\n        limit: The optional pagination limit. Defaults to `None`.\n\n        offset: The optional pagination offset. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list name changes.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_name_changes(123, limit=10)\n        ```\n    \"\"\"\n    params = self._generate_map(limit=limit, offset=offset)\n    route = routes.GROUP_NAME_CHANGES.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.NameChange])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_records","title":"get_records  <code>async</code>","text":"<pre><code>get_records(\n    id: int,\n    metric: enums.Metric,\n    period: enums.Period,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.RecordLeaderboardEntry]]\n</code></pre> <p>Gets the records held by players in the group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>metric</code> <code>Metric</code> <p>The metric to filter on.</p> required <code>period</code> <code>Period</code> <p>The period of time to get records for.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The optional pagination limit. Defaults to <code>None</code>.</p> <code>offset</code> <code>Optional[int]</code> <p>The optional pagination offset. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[RecordLeaderboardEntry]]</code> <p>A <code>Result</code> containing the list of record leaderboard entries.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_records(\n    123, wom.Metric.Zulrah, wom.Period.Day, limit=3\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_records(\n    self,\n    id: int,\n    metric: enums.Metric,\n    period: enums.Period,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.RecordLeaderboardEntry]]:\n    \"\"\"Gets the records held by players in the group.\n\n    Args:\n        id: The ID of the group.\n\n        metric: The metric to filter on.\n\n        period: The period of time to get records for.\n\n    Keyword Args:\n        limit: The optional pagination limit. Defaults to `None`.\n\n        offset: The optional pagination offset. Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of record\n            leaderboard entries.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_records(\n            123, wom.Metric.Zulrah, wom.Period.Day, limit=3\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        limit=limit,\n        offset=offset,\n        metric=metric.value,\n        period=period.value,\n    )\n\n    route = routes.GROUP_RECORDS.compile(id).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.RecordLeaderboardEntry])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.get_statistics","title":"get_statistics  <code>async</code>","text":"<pre><code>get_statistics(id: int) -&gt; ResultT[models.GroupStatistics]\n</code></pre> <p>Gets the statistics for the group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <p>Returns:</p> Type Description <code>ResultT[GroupStatistics]</code> <p>A <code>Result</code> containing the statistics.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.get_statistics(123)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def get_statistics(self, id: int) -&gt; ResultT[models.GroupStatistics]:\n    \"\"\"Gets the statistics for the group.\n\n    Args:\n        id: The ID of the group.\n\n    Returns:\n        A [`Result`][wom.Result] containing the statistics.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.get_statistics(123)\n        ```\n    \"\"\"\n    route = routes.GROUP_STATISTICS.compile(id)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, models.GroupStatistics)\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.remove_members","title":"remove_members  <code>async</code>","text":"<pre><code>remove_members(\n    id: int, verification_code: str, *members: str\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Removes members from an existing group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>verification_code</code> <code>str</code> <p>The group verification code.</p> required <code>*members</code> <code>str</code> <p>The usernames of members to remove from the group.</p> <code>()</code> <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.remove_members(\n    123,\n    \"111-111-111\",\n    \"Jonxslays\",\n    \"Zezima\",\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def remove_members(\n    self, id: int, verification_code: str, *members: str\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Removes members from an existing group.\n\n    Args:\n        id: The ID of the group.\n\n        verification_code: The group verification code.\n\n        *members: The usernames of members to remove from the group.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.remove_members(\n            123,\n            \"111-111-111\",\n            \"Jonxslays\",\n            \"Zezima\",\n        )\n        ```\n    \"\"\"\n    route = routes.REMOVE_MEMBERS.compile(id)\n    payload = self._generate_map(verificationCode=verification_code, members=members)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data)\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.search_groups","title":"search_groups  <code>async</code>","text":"<pre><code>search_groups(\n    name: t.Optional[str] = None,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.Group]]\n</code></pre> <p>Searches for groups that at least partially match the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The group name to search for.</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>The pagination limit.</p> <code>None</code> <code>offset</code> <code>Optional[int]</code> <p>The pagination offset.</p> <code>None</code> <p>Returns:</p> Type Description <code>ResultT[List[Group]]</code> <p>A <code>Result</code> containing the list of matching groups.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nawait client.groups.search_groups(\"Some group\", limit=3)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def search_groups(\n    self,\n    name: t.Optional[str] = None,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.Group]]:\n    \"\"\"Searches for groups that at least partially match the given\n    name.\n\n    Args:\n        name: The group name to search for.\n\n        limit: The pagination limit.\n\n        offset: The pagination offset.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of matching\n            groups.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        await client.groups.search_groups(\"Some group\", limit=3)\n        ```\n    \"\"\"\n    params = self._generate_map(name=name, limit=limit, offset=offset)\n    route = routes.SEARCH_GROUPS.compile().with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.Group])\n</code></pre>"},{"location":"reference/services/#wom.services.GroupService.update_outdated_members","title":"update_outdated_members  <code>async</code>","text":"<pre><code>update_outdated_members(\n    id: int, verification_code: str\n) -&gt; ResultT[models.HttpSuccessResponse]\n</code></pre> <p>Attempts to update all outdated group members.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the group.</p> required <code>verification_code</code> <code>str</code> <p>The verification code for the group.</p> required <p>Returns:</p> Type Description <code>ResultT[HttpSuccessResponse]</code> <p>A <code>Result</code> containing the success response message.</p> <p>Info</p> <p>Group members are considered outdated when they haven't been updated in over 24h.</p> <p>Warning</p> <p>This method adds every outdated member to an \"update queue\", and the WOM servers try to update players in the queue one by one, with a delay in between each. For each player in the queue, an attempt is made to update it up to 3 times, with 30s in between each attempt.</p> <p>Please note that this is dependent on the OSRS hiscores functioning correctly, and therefore this method does NOT guarantee the players will be updated, it only guarantees that an attempt will be made to update them, up to 3 times.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.groups.update_outdated_members(\n    123, \"111-111-111\"\n)\n</code></pre> Source code in <code>wom/services/groups.py</code> <pre><code>async def update_outdated_members(\n    self, id: int, verification_code: str\n) -&gt; ResultT[models.HttpSuccessResponse]:\n    \"\"\"Attempts to update all outdated group members.\n\n    Args:\n        id: The ID of the group.\n\n        verification_code: The verification code for the group.\n\n    Returns:\n        A [`Result`][wom.Result] containing the success response\n            message.\n\n    !!! info\n\n        Group members are considered outdated when they haven't been\n        updated in over 24h.\n\n    !!! warning\n\n        This method adds every outdated member to an \"update queue\",\n        and the WOM servers try to update players in the queue one\n        by one, with a delay in between each. For each player in the\n        queue, an attempt is made to update it up to 3 times, with\n        30s in between each attempt.\n\n        Please note that this is dependent on the OSRS hiscores\n        functioning correctly, and therefore this method does NOT\n        guarantee the players will be updated, it only guarantees\n        that an attempt will be made to update them, up to 3 times.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.groups.update_outdated_members(\n            123, \"111-111-111\"\n        )\n        ```\n    \"\"\"\n    route = routes.UPDATE_OUTDATED_MEMBERS.compile(id)\n    payload = self._generate_map(verificationCode=verification_code)\n    data = await self._http.fetch(route, payload=payload, allow_http_success=True)\n    return self._success_or_err(data, predicate=lambda m: \"players are being updated\" in m)\n</code></pre>"},{"location":"reference/services/#wom.services.HttpService","title":"HttpService","text":"<p>The HTTP service used to make requests to the WOM API.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>The optional api key to use.</p> required <code>user_agent</code> <code>Optional[str]</code> <p>The optional user agent to use.</p> required <code>api_base_url</code> <code>Optional[str]</code> <p>The optional api base url to use.</p> required Source code in <code>wom/services/http.py</code> <pre><code>class HttpService:\n    \"\"\"The HTTP service used to make requests to the WOM API.\n\n    Args:\n        api_key: The optional api key to use.\n\n        user_agent: The optional user agent to use.\n\n        api_base_url: The optional api base url to use.\n    \"\"\"\n\n    __slots__ = (\"_base_url\", \"_decoder\", \"_encoder\", \"_headers\", \"_method_mapping\", \"_session\")\n\n    def __init__(\n        self,\n        api_key: t.Optional[str],\n        user_agent: t.Optional[str],\n        api_base_url: t.Optional[str],\n    ) -&gt; None:\n        user_agent = (\n            f\"{constants.USER_AGENT_BASE} {user_agent}\"\n            if user_agent\n            else constants.DEFAULT_USER_AGENT\n        )\n\n        self._headers = {\n            \"x-user-agent\": user_agent,\n            \"User-Agent\": user_agent,\n        }\n\n        if api_key:\n            self._headers[\"x-api-key\"] = api_key\n\n        self._base_url = api_base_url or constants.WOM_BASE_URL\n        self._decoder = msgspec.json.Decoder()\n        self._encoder = msgspec.json.Encoder()\n\n    async def _read_content(\n        self, response: aiohttp.ClientResponse\n    ) -&gt; t.Union[bytes, models.HttpErrorResponse]:\n        try:\n            return await response.content.read()\n        except Exception:\n            return models.HttpErrorResponse(\"Failed to read response content.\", response.status)\n\n    async def _request(\n        self,\n        req: t.Callable[..., t.Awaitable[t.Any]],\n        url: str,\n        allow_http_success: bool = False,\n        **kwargs: t.Any,\n    ) -&gt; t.Union[bytes, models.HttpErrorResponse]:\n        response = await req(url, **kwargs)\n        content = await self._read_content(response)\n\n        if isinstance(content, models.HttpErrorResponse):\n            return content\n\n        if not response.ok or allow_http_success:\n            error = self._decoder.decode(content)\n\n            return models.HttpErrorResponse(\n                error.get(\"message\", \"An unexpected error occurred while making the request.\"),\n                response.status,\n            )\n\n        return content\n\n    def _get_request_func(self, method: str) -&gt; t.Callable[..., t.Awaitable[t.Any]]:\n        if not hasattr(self, \"_method_mapping\"):\n            raise RuntimeError(\"HttpService.start was never called, aborting...\")\n\n        return self._method_mapping[method]  # type: ignore[return-value]\n\n    async def _init_session(self) -&gt; None:\n        self._session = aiohttp.ClientSession(\n            json_serialize=lambda o: self._encoder.encode(o).decode()\n        )\n\n        self._method_mapping = {\n            \"GET\": self._session.get,\n            \"POST\": self._session.post,\n            \"PUT\": self._session.put,\n            \"PATCH\": self._session.patch,\n            \"DELETE\": self._session.delete,\n        }\n\n    def set_api_key(self, api_key: str) -&gt; None:\n        \"\"\"Sets the api key used by the http service.\n\n        Args:\n            api_key: The new api key to use.\n        \"\"\"\n        self._headers[\"x-api-key\"] = api_key\n\n    def unset_api_key(self) -&gt; None:\n        \"\"\"Un-sets the current api key so it isn't sent with requests.\"\"\"\n        if \"x-api-key\" in self._headers:\n            del self._headers[\"x-api-key\"]\n\n    def set_user_agent(self, user_agent: str) -&gt; None:\n        \"\"\"Sets the user agent used by the http service.\n\n        Args:\n            user_agent: The new user agent to use.\n        \"\"\"\n        self._headers[\"x-user-agent\"] = user_agent\n        self._headers[\"User-Agent\"] = user_agent\n\n    def set_base_url(self, base_url: str) -&gt; None:\n        \"\"\"Sets the api base url used by the http service.\n\n        Args:\n            base_url: The new base url to use.\n        \"\"\"\n        self._base_url = base_url\n\n    async def start(self) -&gt; None:\n        \"\"\"Starts the client session to be used by the http service.\"\"\"\n        if not hasattr(self, \"_session\"):\n            await self._init_session()\n\n    async def close(self) -&gt; None:\n        \"\"\"Closes the existing client session, if it's still open.\"\"\"\n        if hasattr(self, \"_session\") and not self._session.closed:\n            await self._session.close()\n\n    async def fetch(\n        self,\n        route: routes.CompiledRoute,\n        *,\n        payload: t.Optional[t.Dict[str, t.Any]] = None,\n        allow_http_success: bool = False,\n    ) -&gt; bytes | models.HttpErrorResponse:\n        \"\"\"Fetches the given route.\n\n        Args:\n            route: The route to make the request to.\n\n            payload: The optional payload to send in the request\n                body.\n\n            allow_http_success: Whether or not the caller is planning\n                to return http success.\n\n        Returns:\n            The requested bytes or the error response.\n        \"\"\"\n        return await self._request(\n            self._get_request_func(route.method),\n            self._base_url + route.uri,\n            allow_http_success,\n            headers=self._headers,\n            params=route.params,\n            json=payload or None,\n        )\n</code></pre>"},{"location":"reference/services/#wom.services.HttpService.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Closes the existing client session, if it's still open.</p> Source code in <code>wom/services/http.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Closes the existing client session, if it's still open.\"\"\"\n    if hasattr(self, \"_session\") and not self._session.closed:\n        await self._session.close()\n</code></pre>"},{"location":"reference/services/#wom.services.HttpService.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch(\n    route: routes.CompiledRoute,\n    *,\n    payload: t.Optional[t.Dict[str, t.Any]] = None,\n    allow_http_success: bool = False\n) -&gt; bytes | models.HttpErrorResponse\n</code></pre> <p>Fetches the given route.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>CompiledRoute</code> <p>The route to make the request to.</p> required <code>payload</code> <code>Optional[Dict[str, Any]]</code> <p>The optional payload to send in the request body.</p> <code>None</code> <code>allow_http_success</code> <code>bool</code> <p>Whether or not the caller is planning to return http success.</p> <code>False</code> <p>Returns:</p> Type Description <code>bytes | HttpErrorResponse</code> <p>The requested bytes or the error response.</p> Source code in <code>wom/services/http.py</code> <pre><code>async def fetch(\n    self,\n    route: routes.CompiledRoute,\n    *,\n    payload: t.Optional[t.Dict[str, t.Any]] = None,\n    allow_http_success: bool = False,\n) -&gt; bytes | models.HttpErrorResponse:\n    \"\"\"Fetches the given route.\n\n    Args:\n        route: The route to make the request to.\n\n        payload: The optional payload to send in the request\n            body.\n\n        allow_http_success: Whether or not the caller is planning\n            to return http success.\n\n    Returns:\n        The requested bytes or the error response.\n    \"\"\"\n    return await self._request(\n        self._get_request_func(route.method),\n        self._base_url + route.uri,\n        allow_http_success,\n        headers=self._headers,\n        params=route.params,\n        json=payload or None,\n    )\n</code></pre>"},{"location":"reference/services/#wom.services.HttpService.set_api_key","title":"set_api_key","text":"<pre><code>set_api_key(api_key: str) -&gt; None\n</code></pre> <p>Sets the api key used by the http service.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The new api key to use.</p> required Source code in <code>wom/services/http.py</code> <pre><code>def set_api_key(self, api_key: str) -&gt; None:\n    \"\"\"Sets the api key used by the http service.\n\n    Args:\n        api_key: The new api key to use.\n    \"\"\"\n    self._headers[\"x-api-key\"] = api_key\n</code></pre>"},{"location":"reference/services/#wom.services.HttpService.set_base_url","title":"set_base_url","text":"<pre><code>set_base_url(base_url: str) -&gt; None\n</code></pre> <p>Sets the api base url used by the http service.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The new base url to use.</p> required Source code in <code>wom/services/http.py</code> <pre><code>def set_base_url(self, base_url: str) -&gt; None:\n    \"\"\"Sets the api base url used by the http service.\n\n    Args:\n        base_url: The new base url to use.\n    \"\"\"\n    self._base_url = base_url\n</code></pre>"},{"location":"reference/services/#wom.services.HttpService.set_user_agent","title":"set_user_agent","text":"<pre><code>set_user_agent(user_agent: str) -&gt; None\n</code></pre> <p>Sets the user agent used by the http service.</p> <p>Parameters:</p> Name Type Description Default <code>user_agent</code> <code>str</code> <p>The new user agent to use.</p> required Source code in <code>wom/services/http.py</code> <pre><code>def set_user_agent(self, user_agent: str) -&gt; None:\n    \"\"\"Sets the user agent used by the http service.\n\n    Args:\n        user_agent: The new user agent to use.\n    \"\"\"\n    self._headers[\"x-user-agent\"] = user_agent\n    self._headers[\"User-Agent\"] = user_agent\n</code></pre>"},{"location":"reference/services/#wom.services.HttpService.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Starts the client session to be used by the http service.</p> Source code in <code>wom/services/http.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Starts the client session to be used by the http service.\"\"\"\n    if not hasattr(self, \"_session\"):\n        await self._init_session()\n</code></pre>"},{"location":"reference/services/#wom.services.HttpService.unset_api_key","title":"unset_api_key","text":"<pre><code>unset_api_key() -&gt; None\n</code></pre> <p>Un-sets the current api key so it isn't sent with requests.</p> Source code in <code>wom/services/http.py</code> <pre><code>def unset_api_key(self) -&gt; None:\n    \"\"\"Un-sets the current api key so it isn't sent with requests.\"\"\"\n    if \"x-api-key\" in self._headers:\n        del self._headers[\"x-api-key\"]\n</code></pre>"},{"location":"reference/services/#wom.services.NameChangeService","title":"NameChangeService","text":"<p>             Bases: <code>BaseService</code></p> <p>Handles endpoints related to name changes.</p> Source code in <code>wom/services/names.py</code> <pre><code>class NameChangeService(BaseService):\n    \"\"\"Handles endpoints related to name changes.\"\"\"\n\n    __slots__ = ()\n\n    async def search_name_changes(\n        self,\n        username: t.Optional[str] = None,\n        *,\n        status: t.Optional[models.NameChangeStatus] = None,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n    ) -&gt; ResultT[t.List[models.NameChange]]:\n        \"\"\"Searches for name changes.\n\n        Args:\n            username: The optional username to search for.\n\n        Keyword Args:\n            status: The optional name change status to filter on.\n                Defaults to `None`.\n\n            limit: The optional maximum items to return on this page\n                from the API. Defaults to `None`.\n\n            offset: The optional page offset. Defaults to\n                `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing a list of name changes.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.names.search_name_changes(\n                \"Jonxslays\", limit=1\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(username=username, status=status, limit=limit, offset=offset)\n        route = routes.SEARCH_NAME_CHANGES.compile().with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.NameChange])\n\n    async def submit_name_change(self, old_name: str, new_name: str) -&gt; ResultT[models.NameChange]:\n        \"\"\"Submits a new name change.\n\n        Args:\n            old_name: The old name for the player.\n\n            new_name: The new name for the player.\n\n        Returns:\n            A [`Result`][wom.Result] containing the name change.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.names.submit_name_change(\n                \"Jonxslays\", \"I Mahatma I\"\n            )\n            ```\n        \"\"\"\n        payload = self._generate_map(oldName=old_name, newName=new_name)\n        route = routes.SUBMIT_NAME_CHANGE.compile()\n        data = await self._http.fetch(route, payload=payload)\n        return self._ok_or_err(data, models.NameChange)\n</code></pre>"},{"location":"reference/services/#wom.services.NameChangeService.search_name_changes","title":"search_name_changes  <code>async</code>","text":"<pre><code>search_name_changes(\n    username: t.Optional[str] = None,\n    *,\n    status: t.Optional[models.NameChangeStatus] = None,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.NameChange]]\n</code></pre> <p>Searches for name changes.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>Optional[str]</code> <p>The optional username to search for.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>status</code> <code>Optional[NameChangeStatus]</code> <p>The optional name change status to filter on. Defaults to <code>None</code>.</p> <code>limit</code> <code>Optional[int]</code> <p>The optional maximum items to return on this page from the API. Defaults to <code>None</code>.</p> <code>offset</code> <code>Optional[int]</code> <p>The optional page offset. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[NameChange]]</code> <p>A <code>Result</code> containing a list of name changes.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.names.search_name_changes(\n    \"Jonxslays\", limit=1\n)\n</code></pre> Source code in <code>wom/services/names.py</code> <pre><code>async def search_name_changes(\n    self,\n    username: t.Optional[str] = None,\n    *,\n    status: t.Optional[models.NameChangeStatus] = None,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n) -&gt; ResultT[t.List[models.NameChange]]:\n    \"\"\"Searches for name changes.\n\n    Args:\n        username: The optional username to search for.\n\n    Keyword Args:\n        status: The optional name change status to filter on.\n            Defaults to `None`.\n\n        limit: The optional maximum items to return on this page\n            from the API. Defaults to `None`.\n\n        offset: The optional page offset. Defaults to\n            `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing a list of name changes.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.names.search_name_changes(\n            \"Jonxslays\", limit=1\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(username=username, status=status, limit=limit, offset=offset)\n    route = routes.SEARCH_NAME_CHANGES.compile().with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.NameChange])\n</code></pre>"},{"location":"reference/services/#wom.services.NameChangeService.submit_name_change","title":"submit_name_change  <code>async</code>","text":"<pre><code>submit_name_change(\n    old_name: str, new_name: str\n) -&gt; ResultT[models.NameChange]\n</code></pre> <p>Submits a new name change.</p> <p>Parameters:</p> Name Type Description Default <code>old_name</code> <code>str</code> <p>The old name for the player.</p> required <code>new_name</code> <code>str</code> <p>The new name for the player.</p> required <p>Returns:</p> Type Description <code>ResultT[NameChange]</code> <p>A <code>Result</code> containing the name change.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.names.submit_name_change(\n    \"Jonxslays\", \"I Mahatma I\"\n)\n</code></pre> Source code in <code>wom/services/names.py</code> <pre><code>async def submit_name_change(self, old_name: str, new_name: str) -&gt; ResultT[models.NameChange]:\n    \"\"\"Submits a new name change.\n\n    Args:\n        old_name: The old name for the player.\n\n        new_name: The new name for the player.\n\n    Returns:\n        A [`Result`][wom.Result] containing the name change.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.names.submit_name_change(\n            \"Jonxslays\", \"I Mahatma I\"\n        )\n        ```\n    \"\"\"\n    payload = self._generate_map(oldName=old_name, newName=new_name)\n    route = routes.SUBMIT_NAME_CHANGE.compile()\n    data = await self._http.fetch(route, payload=payload)\n    return self._ok_or_err(data, models.NameChange)\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService","title":"PlayerService","text":"<p>             Bases: <code>BaseService</code></p> <p>Handles endpoints related to players.</p> Source code in <code>wom/services/players.py</code> <pre><code>class PlayerService(BaseService):\n    \"\"\"Handles endpoints related to players.\"\"\"\n\n    __slots__ = ()\n\n    async def search_players(\n        self, username: str, *, limit: t.Optional[int] = None, offset: t.Optional[int] = None\n    ) -&gt; ResultT[t.List[models.Player]]:\n        \"\"\"Searches for a player by partial username.\n\n        Args:\n            username: The username to search for.\n\n        Keyword Args:\n            limit: The maximum number of paginated items to receive.\n                Defaults to `None` (I think thats 20 items?).\n\n            offset: The page offset for requesting multiple pages.\n                Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of matching\n                players.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.search_players(\"Jonxslays\", limit=3)\n            ```\n        \"\"\"\n        params = self._generate_map(username=username, limit=limit, offset=offset)\n        route = routes.SEARCH_PLAYERS.compile().with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.Player])\n\n    async def update_player(self, username: str) -&gt; ResultT[models.PlayerDetail]:\n        \"\"\"Updates the given player.\n\n        Args:\n            username: The username to update.\n\n        Returns:\n            A [`Result`][wom.Result] containing the updated player\n                details.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.update_player(\"Jonxslays\")\n            ```\n        \"\"\"\n        route = routes.UPDATE_PLAYER.compile(username)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, models.PlayerDetail)\n\n    async def assert_player_type(self, username: str) -&gt; ResultT[models.AssertPlayerType]:\n        \"\"\"Asserts, and fixes, a players type.\n\n        Args:\n            username: The username to assert the type for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the asserted player\n                type.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.assert_player_type(\"Jonxslays\")\n            ```\n        \"\"\"\n        route = routes.ASSERT_PLAYER_TYPE.compile(username)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, models.AssertPlayerType)\n\n    async def get_details(self, username: str) -&gt; ResultT[models.PlayerDetail]:\n        \"\"\"Gets the details for a given player.\n\n        Args:\n            username: The username to get the details for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the player details.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_details(\"Jonxslays\")\n            ```\n        \"\"\"\n        route = routes.PLAYER_DETAILS.compile(username)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, models.PlayerDetail)\n\n    async def get_details_by_id(self, player_id: int) -&gt; ResultT[models.PlayerDetail]:\n        \"\"\"Gets the details for a given player id.\n\n        Args:\n            player_id: The is of the player to get the details for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the player details.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_details_by_id(1234)\n            ```\n        \"\"\"\n        route = routes.PLAYER_DETAILS_BY_ID.compile(player_id)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, models.PlayerDetail)\n\n    async def get_achievements(self, username: str) -&gt; ResultT[t.List[models.Achievement]]:\n        \"\"\"Gets the achievements for a given player.\n\n        Args:\n            username: The username to get the achievements for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of player\n                achievements.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_achievements(\"Jonxslays\")\n            ```\n        \"\"\"\n        route = routes.PLAYER_ACHIEVEMENTS.compile(username)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.Achievement])\n\n    async def get_achievement_progress(\n        self, username: str\n    ) -&gt; ResultT[t.List[models.PlayerAchievementProgress]]:\n        \"\"\"Gets the progress towards achievements for a given player.\n\n        Args:\n            username: The username to get the achievement progress for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of player\n                achievement progress.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_achievement_progress(\"Jonxslays\")\n            ```\n        \"\"\"\n        route = routes.PLAYER_ACHIEVEMENT_PROGRESS.compile(username)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.PlayerAchievementProgress])\n\n    async def get_competition_participations(\n        self,\n        username: str,\n        *,\n        limit: t.Optional[int] = None,\n        offset: t.Optional[int] = None,\n        status: t.Optional[models.CompetitionStatus] = None,\n    ) -&gt; ResultT[t.List[models.PlayerParticipation]]:\n        \"\"\"Gets the competition participations for a given player.\n\n        Args:\n            username: The username to get the participations for.\n\n        Keyword Args:\n            limit: The maximum number of paginated items to receive.\n                Defaults to `None` (I think thats 20 items?).\n\n            offset: The page offset for requesting multiple pages.\n                Defaults to `None`.\n\n            status: The optional [`CompetitionStatus`]\n                [wom.CompetitionStatus] to filter on. Defaults to\n                `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of competition\n                participations.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_competition_participations(\n                \"Jonxslays\", limit=3\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            status=status.value if status else None,\n            offset=offset,\n            limit=limit,\n        )\n\n        route = routes.PLAYER_COMPETITION_PARTICIPATION.compile(username)\n        data = await self._http.fetch(route.with_params(params))\n        return self._ok_or_err(data, t.List[models.PlayerParticipation])\n\n    async def get_competition_standings(\n        self,\n        username: str,\n        status: models.CompetitionStatus,\n    ) -&gt; ResultT[t.List[models.PlayerCompetitionStanding]]:\n        \"\"\"Gets the competition standings for a given player.\n\n        Args:\n            username: The username to get the standings for.\n\n            status: The competition status to get standings for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of competition\n                standings.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_competition_standings(\n                \"Jonxslays\", wom.CompetitionStatus.Ongoing\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(status=status.value)\n        route = routes.PLAYER_COMPETITION_STANDINGS.compile(username)\n        data = await self._http.fetch(route.with_params(params))\n        return self._ok_or_err(data, t.List[models.PlayerCompetitionStanding])\n\n    async def get_group_memberships(\n        self, username: str, *, limit: t.Optional[int] = None, offset: t.Optional[int] = None\n    ) -&gt; ResultT[t.List[models.PlayerMembership]]:\n        \"\"\"Gets the group memberships for the given player.\n\n        Args:\n            username: The username to get the memberships for.\n\n        Keyword Args:\n            limit: The maximum number of paginated items to receive.\n                Defaults to `None` (I think thats 20 items?).\n\n            offset: The page offset for requesting multiple pages.\n                Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of group\n                memberships.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_group_memberships(\n                \"Jonxslays\", limit=3\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(limit=limit, offset=offset)\n        route = routes.PLAYER_GROUP_MEMBERSHIPS.compile(username)\n        data = await self._http.fetch(route.with_params(params))\n        return self._ok_or_err(data, t.List[models.PlayerMembership])\n\n    async def get_gains(\n        self,\n        username: str,\n        *,\n        period: t.Optional[enums.Period] = None,\n        start_date: t.Optional[datetime] = None,\n        end_date: t.Optional[datetime] = None,\n    ) -&gt; ResultT[models.PlayerGains]:\n        \"\"\"Gets the gains made by this player over the given time span.\n\n        Args:\n            username: The username to get the gains for.\n\n        Keyword Args:\n            period: The optional period of time to get gains for.\n                Defaults to `None`.\n\n            start_date: The minimum date to get the gains from. Defaults\n                to `None`.\n\n            end_date: The maximum date to get the gains from. Defaults\n                to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the players gains.\n\n        !!! info\n\n            You must pass one of (`period`) or (`start_date` +\n            `end_date`), but not both.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_gains(\n                \"Jonxslays\", period=wom.Period.Day\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            period=period.value if period else None,\n            startDate=start_date.isoformat() if start_date else None,\n            endDate=end_date.isoformat() if end_date else None,\n        )\n\n        route = routes.PLAYER_GAINS.compile(username).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, models.PlayerGains)\n\n    async def get_records(\n        self,\n        username: str,\n        *,\n        period: t.Optional[enums.Period] = None,\n        metric: t.Optional[enums.Metric] = None,\n    ) -&gt; ResultT[t.List[models.Record]]:\n        \"\"\"Gets the records held by this player.\n\n        Args:\n            username: The username to get the gains for.\n\n        Keyword Args:\n            period: The optional period of time to get records for.\n                Defaults to `None`.\n\n            metric: The optional metric to filter the records on.\n                Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing a list of the players\n                records.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_records(\n                \"Jonxslays\", period=wom.Period.Day, metric=wom.Metric.Attack\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            period=period.value if period else None, metric=metric.value if metric else None\n        )\n\n        route = routes.PLAYER_RECORDS.compile(username).with_params(params)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.Record])\n\n    async def get_snapshots(\n        self,\n        username: str,\n        *,\n        period: t.Optional[enums.Period] = None,\n        start_date: t.Optional[datetime] = None,\n        end_date: t.Optional[datetime] = None,\n    ) -&gt; ResultT[t.List[models.Snapshot]]:\n        \"\"\"Gets the snapshots for the player.\n\n        Args:\n            username: The username to get the snapshots for.\n\n        Keyword Args:\n            period: The optional period of time to get snapshots for.\n                Defaults to `None`.\n\n            start_date: The minimum date to get the snapshots from.\n                Defaults to `None`.\n\n            end_date: The maximum date to get the snapshots from.\n                Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of snapshots.\n\n        !!! info\n\n            You can pass either (`period`) or (`start_date` +\n            `end_date`), but not both.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_snapshots(\n                \"Jonxslays\", period=wom.Period.Week\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            period=period.value if period else None,\n            startDate=start_date.isoformat() if start_date else None,\n            endDate=end_date.isoformat() if end_date else None,\n        )\n\n        route = routes.PLAYER_SNAPSHOTS.compile(username)\n        data = await self._http.fetch(route.with_params(params))\n        return self._ok_or_err(data, t.List[models.Snapshot])\n\n    async def get_name_changes(self, username: str) -&gt; ResultT[t.List[models.NameChange]]:\n        \"\"\"Gets the name changes for the player.\n\n        Args:\n            username: The username to get the name changes for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of name changes.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_name_changes(\"Jonxslays\")\n            ```\n        \"\"\"\n        route = routes.PLAYER_NAME_CHANGES.compile(username)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.NameChange])\n\n    async def get_snapshots_timeline(\n        self,\n        username: str,\n        metric: enums.Metric,\n        *,\n        period: t.Optional[enums.Period] = None,\n        start_date: t.Optional[datetime] = None,\n        end_date: t.Optional[datetime] = None,\n    ) -&gt; ResultT[t.List[models.SnapshotTimelineEntry]]:\n        \"\"\"Gets the snapshots timeline for the given player and metric.\n\n        Args:\n            username: The username to get the timeline for.\n\n            metric: The metric to get the timeline for.\n\n        Keyword Args:\n            period: The optional period of time to get snapshots for.\n                Defaults to `None`.\n\n            start_date: The minimum date to get the snapshots from.\n                Defaults to `None`.\n\n            end_date: The maximum date to get the snapshots from.\n                Defaults to `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of snapshots timeline\n                entries.\n\n        !!! info\n\n            You can pass either (`period`) or (`start_date` +\n            `end_date`), but not both.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_snapshots_timeline(\n                \"Jonxslays\", wom.Skills.Attack, period=wom.Period.Week\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            period=period.value if period else None,\n            startDate=start_date.isoformat() if start_date else None,\n            endDate=end_date.isoformat() if end_date else None,\n            metric=metric.value,\n        )\n\n        route = routes.PLAYER_SNAPSHOTS_TIMELINE.compile(username)\n        data = await self._http.fetch(route.with_params(params))\n        return self._ok_or_err(data, t.List[models.SnapshotTimelineEntry])\n\n    async def get_archives(\n        self,\n        username: str,\n    ) -&gt; ResultT[t.List[models.PlayerArchive]]:\n        \"\"\"Gets the archives for the given player.\n\n        Args:\n            username: The username to get archives for.\n\n        Returns:\n            A [`Result`][wom.Result] containing the list of archives.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.players.get_archives(\"Jonxslays\")\n            ```\n        \"\"\"\n        route = routes.PLAYER_ARCHIVES.compile(username)\n        data = await self._http.fetch(route)\n        return self._ok_or_err(data, t.List[models.PlayerArchive])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.assert_player_type","title":"assert_player_type  <code>async</code>","text":"<pre><code>assert_player_type(\n    username: str,\n) -&gt; ResultT[models.AssertPlayerType]\n</code></pre> <p>Asserts, and fixes, a players type.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to assert the type for.</p> required <p>Returns:</p> Type Description <code>ResultT[AssertPlayerType]</code> <p>A <code>Result</code> containing the asserted player type.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.assert_player_type(\"Jonxslays\")\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def assert_player_type(self, username: str) -&gt; ResultT[models.AssertPlayerType]:\n    \"\"\"Asserts, and fixes, a players type.\n\n    Args:\n        username: The username to assert the type for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the asserted player\n            type.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.assert_player_type(\"Jonxslays\")\n        ```\n    \"\"\"\n    route = routes.ASSERT_PLAYER_TYPE.compile(username)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, models.AssertPlayerType)\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_achievement_progress","title":"get_achievement_progress  <code>async</code>","text":"<pre><code>get_achievement_progress(\n    username: str,\n) -&gt; ResultT[t.List[models.PlayerAchievementProgress]]\n</code></pre> <p>Gets the progress towards achievements for a given player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the achievement progress for.</p> required <p>Returns:</p> Type Description <code>ResultT[List[PlayerAchievementProgress]]</code> <p>A <code>Result</code> containing the list of player achievement progress.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_achievement_progress(\"Jonxslays\")\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_achievement_progress(\n    self, username: str\n) -&gt; ResultT[t.List[models.PlayerAchievementProgress]]:\n    \"\"\"Gets the progress towards achievements for a given player.\n\n    Args:\n        username: The username to get the achievement progress for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of player\n            achievement progress.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_achievement_progress(\"Jonxslays\")\n        ```\n    \"\"\"\n    route = routes.PLAYER_ACHIEVEMENT_PROGRESS.compile(username)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.PlayerAchievementProgress])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_achievements","title":"get_achievements  <code>async</code>","text":"<pre><code>get_achievements(\n    username: str,\n) -&gt; ResultT[t.List[models.Achievement]]\n</code></pre> <p>Gets the achievements for a given player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the achievements for.</p> required <p>Returns:</p> Type Description <code>ResultT[List[Achievement]]</code> <p>A <code>Result</code> containing the list of player achievements.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_achievements(\"Jonxslays\")\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_achievements(self, username: str) -&gt; ResultT[t.List[models.Achievement]]:\n    \"\"\"Gets the achievements for a given player.\n\n    Args:\n        username: The username to get the achievements for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of player\n            achievements.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_achievements(\"Jonxslays\")\n        ```\n    \"\"\"\n    route = routes.PLAYER_ACHIEVEMENTS.compile(username)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.Achievement])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_archives","title":"get_archives  <code>async</code>","text":"<pre><code>get_archives(\n    username: str,\n) -&gt; ResultT[t.List[models.PlayerArchive]]\n</code></pre> <p>Gets the archives for the given player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get archives for.</p> required <p>Returns:</p> Type Description <code>ResultT[List[PlayerArchive]]</code> <p>A <code>Result</code> containing the list of archives.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_archives(\"Jonxslays\")\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_archives(\n    self,\n    username: str,\n) -&gt; ResultT[t.List[models.PlayerArchive]]:\n    \"\"\"Gets the archives for the given player.\n\n    Args:\n        username: The username to get archives for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of archives.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_archives(\"Jonxslays\")\n        ```\n    \"\"\"\n    route = routes.PLAYER_ARCHIVES.compile(username)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.PlayerArchive])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_competition_participations","title":"get_competition_participations  <code>async</code>","text":"<pre><code>get_competition_participations(\n    username: str,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n    status: t.Optional[models.CompetitionStatus] = None\n) -&gt; ResultT[t.List[models.PlayerParticipation]]\n</code></pre> <p>Gets the competition participations for a given player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the participations for.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The maximum number of paginated items to receive. Defaults to <code>None</code> (I think thats 20 items?).</p> <code>offset</code> <code>Optional[int]</code> <p>The page offset for requesting multiple pages. Defaults to <code>None</code>.</p> <code>status</code> <code>Optional[CompetitionStatus]</code> <p>The optional <code>CompetitionStatus</code> to filter on. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[PlayerParticipation]]</code> <p>A <code>Result</code> containing the list of competition participations.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_competition_participations(\n    \"Jonxslays\", limit=3\n)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_competition_participations(\n    self,\n    username: str,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None,\n    status: t.Optional[models.CompetitionStatus] = None,\n) -&gt; ResultT[t.List[models.PlayerParticipation]]:\n    \"\"\"Gets the competition participations for a given player.\n\n    Args:\n        username: The username to get the participations for.\n\n    Keyword Args:\n        limit: The maximum number of paginated items to receive.\n            Defaults to `None` (I think thats 20 items?).\n\n        offset: The page offset for requesting multiple pages.\n            Defaults to `None`.\n\n        status: The optional [`CompetitionStatus`]\n            [wom.CompetitionStatus] to filter on. Defaults to\n            `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of competition\n            participations.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_competition_participations(\n            \"Jonxslays\", limit=3\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        status=status.value if status else None,\n        offset=offset,\n        limit=limit,\n    )\n\n    route = routes.PLAYER_COMPETITION_PARTICIPATION.compile(username)\n    data = await self._http.fetch(route.with_params(params))\n    return self._ok_or_err(data, t.List[models.PlayerParticipation])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_competition_standings","title":"get_competition_standings  <code>async</code>","text":"<pre><code>get_competition_standings(\n    username: str, status: models.CompetitionStatus\n) -&gt; ResultT[t.List[models.PlayerCompetitionStanding]]\n</code></pre> <p>Gets the competition standings for a given player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the standings for.</p> required <code>status</code> <code>CompetitionStatus</code> <p>The competition status to get standings for.</p> required <p>Returns:</p> Type Description <code>ResultT[List[PlayerCompetitionStanding]]</code> <p>A <code>Result</code> containing the list of competition standings.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_competition_standings(\n    \"Jonxslays\", wom.CompetitionStatus.Ongoing\n)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_competition_standings(\n    self,\n    username: str,\n    status: models.CompetitionStatus,\n) -&gt; ResultT[t.List[models.PlayerCompetitionStanding]]:\n    \"\"\"Gets the competition standings for a given player.\n\n    Args:\n        username: The username to get the standings for.\n\n        status: The competition status to get standings for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of competition\n            standings.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_competition_standings(\n            \"Jonxslays\", wom.CompetitionStatus.Ongoing\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(status=status.value)\n    route = routes.PLAYER_COMPETITION_STANDINGS.compile(username)\n    data = await self._http.fetch(route.with_params(params))\n    return self._ok_or_err(data, t.List[models.PlayerCompetitionStanding])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_details","title":"get_details  <code>async</code>","text":"<pre><code>get_details(username: str) -&gt; ResultT[models.PlayerDetail]\n</code></pre> <p>Gets the details for a given player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the details for.</p> required <p>Returns:</p> Type Description <code>ResultT[PlayerDetail]</code> <p>A <code>Result</code> containing the player details.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_details(\"Jonxslays\")\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_details(self, username: str) -&gt; ResultT[models.PlayerDetail]:\n    \"\"\"Gets the details for a given player.\n\n    Args:\n        username: The username to get the details for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the player details.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_details(\"Jonxslays\")\n        ```\n    \"\"\"\n    route = routes.PLAYER_DETAILS.compile(username)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, models.PlayerDetail)\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_details_by_id","title":"get_details_by_id  <code>async</code>","text":"<pre><code>get_details_by_id(\n    player_id: int,\n) -&gt; ResultT[models.PlayerDetail]\n</code></pre> <p>Gets the details for a given player id.</p> <p>Parameters:</p> Name Type Description Default <code>player_id</code> <code>int</code> <p>The is of the player to get the details for.</p> required <p>Returns:</p> Type Description <code>ResultT[PlayerDetail]</code> <p>A <code>Result</code> containing the player details.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_details_by_id(1234)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_details_by_id(self, player_id: int) -&gt; ResultT[models.PlayerDetail]:\n    \"\"\"Gets the details for a given player id.\n\n    Args:\n        player_id: The is of the player to get the details for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the player details.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_details_by_id(1234)\n        ```\n    \"\"\"\n    route = routes.PLAYER_DETAILS_BY_ID.compile(player_id)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, models.PlayerDetail)\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_gains","title":"get_gains  <code>async</code>","text":"<pre><code>get_gains(\n    username: str,\n    *,\n    period: t.Optional[enums.Period] = None,\n    start_date: t.Optional[datetime] = None,\n    end_date: t.Optional[datetime] = None\n) -&gt; ResultT[models.PlayerGains]\n</code></pre> <p>Gets the gains made by this player over the given time span.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the gains for.</p> required <p>Other Parameters:</p> Name Type Description <code>period</code> <code>Optional[Period]</code> <p>The optional period of time to get gains for. Defaults to <code>None</code>.</p> <code>start_date</code> <code>Optional[datetime]</code> <p>The minimum date to get the gains from. Defaults to <code>None</code>.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>The maximum date to get the gains from. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[PlayerGains]</code> <p>A <code>Result</code> containing the players gains.</p> <p>Info</p> <p>You must pass one of (<code>period</code>) or (<code>start_date</code> + <code>end_date</code>), but not both.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_gains(\n    \"Jonxslays\", period=wom.Period.Day\n)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_gains(\n    self,\n    username: str,\n    *,\n    period: t.Optional[enums.Period] = None,\n    start_date: t.Optional[datetime] = None,\n    end_date: t.Optional[datetime] = None,\n) -&gt; ResultT[models.PlayerGains]:\n    \"\"\"Gets the gains made by this player over the given time span.\n\n    Args:\n        username: The username to get the gains for.\n\n    Keyword Args:\n        period: The optional period of time to get gains for.\n            Defaults to `None`.\n\n        start_date: The minimum date to get the gains from. Defaults\n            to `None`.\n\n        end_date: The maximum date to get the gains from. Defaults\n            to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the players gains.\n\n    !!! info\n\n        You must pass one of (`period`) or (`start_date` +\n        `end_date`), but not both.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_gains(\n            \"Jonxslays\", period=wom.Period.Day\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        period=period.value if period else None,\n        startDate=start_date.isoformat() if start_date else None,\n        endDate=end_date.isoformat() if end_date else None,\n    )\n\n    route = routes.PLAYER_GAINS.compile(username).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, models.PlayerGains)\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_group_memberships","title":"get_group_memberships  <code>async</code>","text":"<pre><code>get_group_memberships(\n    username: str,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.PlayerMembership]]\n</code></pre> <p>Gets the group memberships for the given player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the memberships for.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The maximum number of paginated items to receive. Defaults to <code>None</code> (I think thats 20 items?).</p> <code>offset</code> <code>Optional[int]</code> <p>The page offset for requesting multiple pages. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[PlayerMembership]]</code> <p>A <code>Result</code> containing the list of group memberships.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_group_memberships(\n    \"Jonxslays\", limit=3\n)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_group_memberships(\n    self, username: str, *, limit: t.Optional[int] = None, offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.PlayerMembership]]:\n    \"\"\"Gets the group memberships for the given player.\n\n    Args:\n        username: The username to get the memberships for.\n\n    Keyword Args:\n        limit: The maximum number of paginated items to receive.\n            Defaults to `None` (I think thats 20 items?).\n\n        offset: The page offset for requesting multiple pages.\n            Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of group\n            memberships.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_group_memberships(\n            \"Jonxslays\", limit=3\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(limit=limit, offset=offset)\n    route = routes.PLAYER_GROUP_MEMBERSHIPS.compile(username)\n    data = await self._http.fetch(route.with_params(params))\n    return self._ok_or_err(data, t.List[models.PlayerMembership])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_name_changes","title":"get_name_changes  <code>async</code>","text":"<pre><code>get_name_changes(\n    username: str,\n) -&gt; ResultT[t.List[models.NameChange]]\n</code></pre> <p>Gets the name changes for the player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the name changes for.</p> required <p>Returns:</p> Type Description <code>ResultT[List[NameChange]]</code> <p>A <code>Result</code> containing the list of name changes.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_name_changes(\"Jonxslays\")\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_name_changes(self, username: str) -&gt; ResultT[t.List[models.NameChange]]:\n    \"\"\"Gets the name changes for the player.\n\n    Args:\n        username: The username to get the name changes for.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of name changes.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_name_changes(\"Jonxslays\")\n        ```\n    \"\"\"\n    route = routes.PLAYER_NAME_CHANGES.compile(username)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.NameChange])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_records","title":"get_records  <code>async</code>","text":"<pre><code>get_records(\n    username: str,\n    *,\n    period: t.Optional[enums.Period] = None,\n    metric: t.Optional[enums.Metric] = None\n) -&gt; ResultT[t.List[models.Record]]\n</code></pre> <p>Gets the records held by this player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the gains for.</p> required <p>Other Parameters:</p> Name Type Description <code>period</code> <code>Optional[Period]</code> <p>The optional period of time to get records for. Defaults to <code>None</code>.</p> <code>metric</code> <code>Optional[Metric]</code> <p>The optional metric to filter the records on. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[Record]]</code> <p>A <code>Result</code> containing a list of the players records.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_records(\n    \"Jonxslays\", period=wom.Period.Day, metric=wom.Metric.Attack\n)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_records(\n    self,\n    username: str,\n    *,\n    period: t.Optional[enums.Period] = None,\n    metric: t.Optional[enums.Metric] = None,\n) -&gt; ResultT[t.List[models.Record]]:\n    \"\"\"Gets the records held by this player.\n\n    Args:\n        username: The username to get the gains for.\n\n    Keyword Args:\n        period: The optional period of time to get records for.\n            Defaults to `None`.\n\n        metric: The optional metric to filter the records on.\n            Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing a list of the players\n            records.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_records(\n            \"Jonxslays\", period=wom.Period.Day, metric=wom.Metric.Attack\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        period=period.value if period else None, metric=metric.value if metric else None\n    )\n\n    route = routes.PLAYER_RECORDS.compile(username).with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.Record])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_snapshots","title":"get_snapshots  <code>async</code>","text":"<pre><code>get_snapshots(\n    username: str,\n    *,\n    period: t.Optional[enums.Period] = None,\n    start_date: t.Optional[datetime] = None,\n    end_date: t.Optional[datetime] = None\n) -&gt; ResultT[t.List[models.Snapshot]]\n</code></pre> <p>Gets the snapshots for the player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the snapshots for.</p> required <p>Other Parameters:</p> Name Type Description <code>period</code> <code>Optional[Period]</code> <p>The optional period of time to get snapshots for. Defaults to <code>None</code>.</p> <code>start_date</code> <code>Optional[datetime]</code> <p>The minimum date to get the snapshots from. Defaults to <code>None</code>.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>The maximum date to get the snapshots from. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[Snapshot]]</code> <p>A <code>Result</code> containing the list of snapshots.</p> <p>Info</p> <p>You can pass either (<code>period</code>) or (<code>start_date</code> + <code>end_date</code>), but not both.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_snapshots(\n    \"Jonxslays\", period=wom.Period.Week\n)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_snapshots(\n    self,\n    username: str,\n    *,\n    period: t.Optional[enums.Period] = None,\n    start_date: t.Optional[datetime] = None,\n    end_date: t.Optional[datetime] = None,\n) -&gt; ResultT[t.List[models.Snapshot]]:\n    \"\"\"Gets the snapshots for the player.\n\n    Args:\n        username: The username to get the snapshots for.\n\n    Keyword Args:\n        period: The optional period of time to get snapshots for.\n            Defaults to `None`.\n\n        start_date: The minimum date to get the snapshots from.\n            Defaults to `None`.\n\n        end_date: The maximum date to get the snapshots from.\n            Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of snapshots.\n\n    !!! info\n\n        You can pass either (`period`) or (`start_date` +\n        `end_date`), but not both.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_snapshots(\n            \"Jonxslays\", period=wom.Period.Week\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        period=period.value if period else None,\n        startDate=start_date.isoformat() if start_date else None,\n        endDate=end_date.isoformat() if end_date else None,\n    )\n\n    route = routes.PLAYER_SNAPSHOTS.compile(username)\n    data = await self._http.fetch(route.with_params(params))\n    return self._ok_or_err(data, t.List[models.Snapshot])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.get_snapshots_timeline","title":"get_snapshots_timeline  <code>async</code>","text":"<pre><code>get_snapshots_timeline(\n    username: str,\n    metric: enums.Metric,\n    *,\n    period: t.Optional[enums.Period] = None,\n    start_date: t.Optional[datetime] = None,\n    end_date: t.Optional[datetime] = None\n) -&gt; ResultT[t.List[models.SnapshotTimelineEntry]]\n</code></pre> <p>Gets the snapshots timeline for the given player and metric.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to get the timeline for.</p> required <code>metric</code> <code>Metric</code> <p>The metric to get the timeline for.</p> required <p>Other Parameters:</p> Name Type Description <code>period</code> <code>Optional[Period]</code> <p>The optional period of time to get snapshots for. Defaults to <code>None</code>.</p> <code>start_date</code> <code>Optional[datetime]</code> <p>The minimum date to get the snapshots from. Defaults to <code>None</code>.</p> <code>end_date</code> <code>Optional[datetime]</code> <p>The maximum date to get the snapshots from. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[SnapshotTimelineEntry]]</code> <p>A <code>Result</code> containing the list of snapshots timeline entries.</p> <p>Info</p> <p>You can pass either (<code>period</code>) or (<code>start_date</code> + <code>end_date</code>), but not both.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.get_snapshots_timeline(\n    \"Jonxslays\", wom.Skills.Attack, period=wom.Period.Week\n)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def get_snapshots_timeline(\n    self,\n    username: str,\n    metric: enums.Metric,\n    *,\n    period: t.Optional[enums.Period] = None,\n    start_date: t.Optional[datetime] = None,\n    end_date: t.Optional[datetime] = None,\n) -&gt; ResultT[t.List[models.SnapshotTimelineEntry]]:\n    \"\"\"Gets the snapshots timeline for the given player and metric.\n\n    Args:\n        username: The username to get the timeline for.\n\n        metric: The metric to get the timeline for.\n\n    Keyword Args:\n        period: The optional period of time to get snapshots for.\n            Defaults to `None`.\n\n        start_date: The minimum date to get the snapshots from.\n            Defaults to `None`.\n\n        end_date: The maximum date to get the snapshots from.\n            Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of snapshots timeline\n            entries.\n\n    !!! info\n\n        You can pass either (`period`) or (`start_date` +\n        `end_date`), but not both.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.get_snapshots_timeline(\n            \"Jonxslays\", wom.Skills.Attack, period=wom.Period.Week\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        period=period.value if period else None,\n        startDate=start_date.isoformat() if start_date else None,\n        endDate=end_date.isoformat() if end_date else None,\n        metric=metric.value,\n    )\n\n    route = routes.PLAYER_SNAPSHOTS_TIMELINE.compile(username)\n    data = await self._http.fetch(route.with_params(params))\n    return self._ok_or_err(data, t.List[models.SnapshotTimelineEntry])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.search_players","title":"search_players  <code>async</code>","text":"<pre><code>search_players(\n    username: str,\n    *,\n    limit: t.Optional[int] = None,\n    offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.Player]]\n</code></pre> <p>Searches for a player by partial username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to search for.</p> required <p>Other Parameters:</p> Name Type Description <code>limit</code> <code>Optional[int]</code> <p>The maximum number of paginated items to receive. Defaults to <code>None</code> (I think thats 20 items?).</p> <code>offset</code> <code>Optional[int]</code> <p>The page offset for requesting multiple pages. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[Player]]</code> <p>A <code>Result</code> containing the list of matching players.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.search_players(\"Jonxslays\", limit=3)\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def search_players(\n    self, username: str, *, limit: t.Optional[int] = None, offset: t.Optional[int] = None\n) -&gt; ResultT[t.List[models.Player]]:\n    \"\"\"Searches for a player by partial username.\n\n    Args:\n        username: The username to search for.\n\n    Keyword Args:\n        limit: The maximum number of paginated items to receive.\n            Defaults to `None` (I think thats 20 items?).\n\n        offset: The page offset for requesting multiple pages.\n            Defaults to `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing the list of matching\n            players.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.search_players(\"Jonxslays\", limit=3)\n        ```\n    \"\"\"\n    params = self._generate_map(username=username, limit=limit, offset=offset)\n    route = routes.SEARCH_PLAYERS.compile().with_params(params)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, t.List[models.Player])\n</code></pre>"},{"location":"reference/services/#wom.services.PlayerService.update_player","title":"update_player  <code>async</code>","text":"<pre><code>update_player(\n    username: str,\n) -&gt; ResultT[models.PlayerDetail]\n</code></pre> <p>Updates the given player.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to update.</p> required <p>Returns:</p> Type Description <code>ResultT[PlayerDetail]</code> <p>A <code>Result</code> containing the updated player details.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.players.update_player(\"Jonxslays\")\n</code></pre> Source code in <code>wom/services/players.py</code> <pre><code>async def update_player(self, username: str) -&gt; ResultT[models.PlayerDetail]:\n    \"\"\"Updates the given player.\n\n    Args:\n        username: The username to update.\n\n    Returns:\n        A [`Result`][wom.Result] containing the updated player\n            details.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.players.update_player(\"Jonxslays\")\n        ```\n    \"\"\"\n    route = routes.UPDATE_PLAYER.compile(username)\n    data = await self._http.fetch(route)\n    return self._ok_or_err(data, models.PlayerDetail)\n</code></pre>"},{"location":"reference/services/#wom.services.RecordService","title":"RecordService","text":"<p>             Bases: <code>BaseService</code></p> <p>Handles endpoints related to records.</p> Source code in <code>wom/services/records.py</code> <pre><code>class RecordService(BaseService):\n    \"\"\"Handles endpoints related to records.\"\"\"\n\n    __slots__ = ()\n\n    async def get_global_leaderboards(\n        self,\n        metric: enums.Metric,\n        period: enums.Period,\n        *,\n        player_type: t.Optional[models.PlayerType] = None,\n        player_build: t.Optional[models.PlayerBuild] = None,\n        country: t.Optional[models.Country] = None,\n    ) -&gt; ResultT[t.List[models.RecordLeaderboardEntry]]:\n        \"\"\"Gets the global record leaderboards.\n\n        Args:\n            metric: The metric to filter on.\n\n            period: The period of time to filter on.\n\n        Keyword Args:\n            player_type: The optional player type to filter on. Defaults\n                to `None`.\n\n            player_build: The optional player build to filter on.\n                Defaults to `None`.\n\n            country: The optional country to filter on. Defaults to\n                `None`.\n\n        Returns:\n            A [`Result`][wom.Result] containing a list of record\n                leaderboard entries.\n\n        ??? example\n\n            ```py\n            import wom\n\n            client = wom.Client(...)\n\n            await client.start()\n\n            result = await client.records.get_global_leaderboards(\n                wom.Metric.Attack,\n                wom.Period.Day,\n                country=wom.Country.Us,\n            )\n            ```\n        \"\"\"\n        params = self._generate_map(\n            metric=metric.value,\n            period=period.value,\n            playerType=player_type.value if player_type else None,\n            playerBuild=player_build.value if player_build else None,\n            country=country.value if country else None,\n        )\n\n        route = routes.GLOBAL_RECORD_LEADERS.compile()\n        data = await self._http.fetch(route.with_params(params))\n        return self._ok_or_err(data, t.List[models.RecordLeaderboardEntry])\n</code></pre>"},{"location":"reference/services/#wom.services.RecordService.get_global_leaderboards","title":"get_global_leaderboards  <code>async</code>","text":"<pre><code>get_global_leaderboards(\n    metric: enums.Metric,\n    period: enums.Period,\n    *,\n    player_type: t.Optional[models.PlayerType] = None,\n    player_build: t.Optional[models.PlayerBuild] = None,\n    country: t.Optional[models.Country] = None\n) -&gt; ResultT[t.List[models.RecordLeaderboardEntry]]\n</code></pre> <p>Gets the global record leaderboards.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>Metric</code> <p>The metric to filter on.</p> required <code>period</code> <code>Period</code> <p>The period of time to filter on.</p> required <p>Other Parameters:</p> Name Type Description <code>player_type</code> <code>Optional[PlayerType]</code> <p>The optional player type to filter on. Defaults to <code>None</code>.</p> <code>player_build</code> <code>Optional[PlayerBuild]</code> <p>The optional player build to filter on. Defaults to <code>None</code>.</p> <code>country</code> <code>Optional[Country]</code> <p>The optional country to filter on. Defaults to <code>None</code>.</p> <p>Returns:</p> Type Description <code>ResultT[List[RecordLeaderboardEntry]]</code> <p>A <code>Result</code> containing a list of record leaderboard entries.</p> Example <pre><code>import wom\n\nclient = wom.Client(...)\n\nawait client.start()\n\nresult = await client.records.get_global_leaderboards(\n    wom.Metric.Attack,\n    wom.Period.Day,\n    country=wom.Country.Us,\n)\n</code></pre> Source code in <code>wom/services/records.py</code> <pre><code>async def get_global_leaderboards(\n    self,\n    metric: enums.Metric,\n    period: enums.Period,\n    *,\n    player_type: t.Optional[models.PlayerType] = None,\n    player_build: t.Optional[models.PlayerBuild] = None,\n    country: t.Optional[models.Country] = None,\n) -&gt; ResultT[t.List[models.RecordLeaderboardEntry]]:\n    \"\"\"Gets the global record leaderboards.\n\n    Args:\n        metric: The metric to filter on.\n\n        period: The period of time to filter on.\n\n    Keyword Args:\n        player_type: The optional player type to filter on. Defaults\n            to `None`.\n\n        player_build: The optional player build to filter on.\n            Defaults to `None`.\n\n        country: The optional country to filter on. Defaults to\n            `None`.\n\n    Returns:\n        A [`Result`][wom.Result] containing a list of record\n            leaderboard entries.\n\n    ??? example\n\n        ```py\n        import wom\n\n        client = wom.Client(...)\n\n        await client.start()\n\n        result = await client.records.get_global_leaderboards(\n            wom.Metric.Attack,\n            wom.Period.Day,\n            country=wom.Country.Us,\n        )\n        ```\n    \"\"\"\n    params = self._generate_map(\n        metric=metric.value,\n        period=period.value,\n        playerType=player_type.value if player_type else None,\n        playerBuild=player_build.value if player_build else None,\n        country=country.value if country else None,\n    )\n\n    route = routes.GLOBAL_RECORD_LEADERS.compile()\n    data = await self._http.fetch(route.with_params(params))\n    return self._ok_or_err(data, t.List[models.RecordLeaderboardEntry])\n</code></pre>"}]}